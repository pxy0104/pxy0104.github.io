---
title: JVM垃圾回收算法
date: 2023-06-05 00:19:01
tags:
- 八股文
- Java
- JVM
categories: Java
---

JVM中几种常见的垃圾回收算法总结
<!-- more -->
# 垃圾回收算法

JVM中有几种垃圾收集算法，包括标记-清除算法、复制算法、标记-整理算法和分代收集算法。其中，标记-清除算法适用于存活对象较多的情况，适用于年老代；复制算法适用于存活对象较少的情况，适用于年轻代；标记-整理算法适用于老年代；分代收集算法将内存分为各个年代，在不同年代使用不同的算法，新生代使用复制算法，老年代使用标记-整理算法。

## 标记阶段

### 方式一：引用计数算法（Reference Counting）

引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

缺点：

- 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
- 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
- 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

![01.png](1682060906429-a6d50377-7540-4666-b791-66b4322d6abf.png)
### 方式二：可达性分析算法
#### 可达性分析算法（根搜索算法、追踪性垃圾收集）
相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）
所谓"GCRoots”根集合就是一组必须活跃的引用。
#### 基本思路

- 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
- 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
- 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

![02.png](1682062370296-0e309ae3-f4c9-4757-bab6-294b9fb42b08.png)

**注意**

如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。
这点也是导致GC进行时必须“Stop The World”的一个重要原因。

- 即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

## 清除阶段

当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。
目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）

### 标记-清除算法（Mark-Sweep）

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

- 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
- 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 

![03.png](1685895435093-835c7156-1b12-4abd-a1ab-eb5b7c884881.png)

- 标记清除算法中的标记用的是可达性分析算法中的标记。标记清除算法是一种最基础的垃圾回收算法，它分为两个阶段：标记和清除。标记阶段就是通过可达性分析算法，从根节点开始遍历，标记所有被引用的对象。清除阶段就是对堆内存进行线性遍历，回收所有没有被标记的对象。

#### 缺点

- 标记清除算法的效率不算高（遍历递归，O(n)级别复杂度）
- 在进行GC的时候，需要停止整个应用程序，用户体验较差
- 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表

#### 何为清除？

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。

### 复制算法（Copying）

为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。

#### 核心思想

将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
![04.png](1685895483302-f07d0aeb-737a-4053-9e60-628b8cb1b293.png)

#### 优点

- 没有标记和清除过程，实现简单，运行高效
- 复制过去以后保证空间的连续性，不会出现“碎片”问题。

#### 缺点

- 此算法的缺点也是很明显的，就是需要两倍的内存空间。
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小

#### 特别的

如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行

#### 应用场景

在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。
![05.png](01.png)

### 标记-压缩算法（Mark - Compact）

#### 背景

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。
标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。
1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。

#### 执行过程

1. 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。
3. 之后，清理边界外所有的空间。

![06.png](02.png)

#### 特点

- 它分为两个阶段：标记和压缩。标记阶段和标记-清除算法一样，从根节点开始标记所有的引用对象；压缩阶段将所有内存对象压缩到内存的一端，按顺序排放，之后清理边界外的所有空间。
- 它可以消除内存碎片，提高内存利用率。因为它将所有存活对象都移动到一起，所以可以使用指针碰撞的方式进行内存分配，而不需要维护一个空闲列表。
- 它是一种移动式的回收算法，所以在移动对象的同时，需要更新对象的引用地址。这会增加一定的开销，并且需要暂停用户程序（STW）。
- 它的效率一般低于复制算法，因为它需要遍历整个堆空间进行标记和压缩。

#### 指针碰撞（Bump the Pointer）

如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。

#### 优点

- 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
- 消除了复制算法当中，内存减半的高额代价。

#### 缺点

- 从效率上来说，标记-整理算法要低于复制算法。
- 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序。即：STW

#### 标记-压缩算法和标记-清除算法的区别

- 标记-压缩算法在标记阶段后，会将存活对象移动到一端，而标记-清除算法只会清除死亡对象，不会移动存活对象。
- 标记-压缩算法可以消除内存碎片，而标记-清除算法会产生内存碎片。
- 标记-压缩算法需要更新对象的引用地址，而标记-清除算法不需要。
- 标记-压缩算法的效率一般低于标记-清除算法，因为它需要多次遍历堆空间。

### 小结

| Mark-Sweep | Mark-Compact | Copying |
| --- | --- | --- |
| 中等 | 最慢 | 最快 |
| 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| 否 | 是 | 是 |

效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。
而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。
