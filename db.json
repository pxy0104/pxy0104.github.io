{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/dog.jpg","path":"images/dog.jpg","modified":0,"renderable":0},{"_id":"themes/sky/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/sky/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/sky/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/sky/source/css/common/third-part.scss","path":"css/common/third-part.scss","modified":0,"renderable":1},{"_id":"source/img/0001.png","path":"img/0001.png","modified":0,"renderable":0},{"_id":"source/img/0002.png","path":"img/0002.png","modified":0,"renderable":0},{"_id":"source/img/0003.png","path":"img/0003.png","modified":0,"renderable":0},{"_id":"source/img/0004.png","path":"img/0004.png","modified":0,"renderable":0},{"_id":"source/img/0005.png","path":"img/0005.png","modified":0,"renderable":0},{"_id":"source/img/0006.png","path":"img/0006.png","modified":0,"renderable":0},{"_id":"source/img/0007.png","path":"img/0007.png","modified":0,"renderable":0},{"_id":"source/img/0009.png","path":"img/0009.png","modified":0,"renderable":0},{"_id":"source/img/0008.png","path":"img/0008.png","modified":0,"renderable":0},{"_id":"source/img/0010.png","path":"img/0010.png","modified":0,"renderable":0},{"_id":"source/img/0011.png","path":"img/0011.png","modified":0,"renderable":0},{"_id":"source/img/0012.png","path":"img/0012.png","modified":0,"renderable":0},{"_id":"source/img/0013.png","path":"img/0013.png","modified":0,"renderable":0},{"_id":"source/img/0014.png","path":"img/0014.png","modified":0,"renderable":0},{"_id":"source/img/0015.png","path":"img/0015.png","modified":0,"renderable":0},{"_id":"source/img/0017.png","path":"img/0017.png","modified":0,"renderable":0},{"_id":"source/img/0016.png","path":"img/0016.png","modified":0,"renderable":0},{"_id":"source/img/0019.png","path":"img/0019.png","modified":0,"renderable":0},{"_id":"source/img/0018.png","path":"img/0018.png","modified":0,"renderable":0},{"_id":"source/img/0020.png","path":"img/0020.png","modified":0,"renderable":0},{"_id":"source/img/0021.png","path":"img/0021.png","modified":0,"renderable":0},{"_id":"source/img/0022.png","path":"img/0022.png","modified":0,"renderable":0},{"_id":"source/img/0024.png","path":"img/0024.png","modified":0,"renderable":0},{"_id":"source/img/0023.png","path":"img/0023.png","modified":0,"renderable":0},{"_id":"source/img/0025.png","path":"img/0025.png","modified":0,"renderable":0},{"_id":"source/img/0026.png","path":"img/0026.png","modified":0,"renderable":0},{"_id":"source/img/0027.png","path":"img/0027.png","modified":0,"renderable":0},{"_id":"source/img/0028.jpg","path":"img/0028.jpg","modified":0,"renderable":0},{"_id":"source/img/0029.jpg","path":"img/0029.jpg","modified":0,"renderable":0},{"_id":"source/img/0030.jpg","path":"img/0030.jpg","modified":0,"renderable":0},{"_id":"source/img/0032.png","path":"img/0032.png","modified":0,"renderable":0},{"_id":"source/img/0031.jpg","path":"img/0031.jpg","modified":0,"renderable":0},{"_id":"source/img/0033.png","path":"img/0033.png","modified":0,"renderable":0},{"_id":"source/img/0034.png","path":"img/0034.png","modified":0,"renderable":0},{"_id":"source/img/0035.png","path":"img/0035.png","modified":0,"renderable":0},{"_id":"source/img/0036.png","path":"img/0036.png","modified":0,"renderable":0},{"_id":"source/img/0037.png","path":"img/0037.png","modified":0,"renderable":0},{"_id":"source/img/0038.png","path":"img/0038.png","modified":0,"renderable":0},{"_id":"source/img/0039.png","path":"img/0039.png","modified":0,"renderable":0},{"_id":"source/img/0040.png","path":"img/0040.png","modified":0,"renderable":0},{"_id":"source/img/0041.png","path":"img/0041.png","modified":0,"renderable":0},{"_id":"source/img/0042.png","path":"img/0042.png","modified":0,"renderable":0},{"_id":"source/img/0043.png","path":"img/0043.png","modified":0,"renderable":0},{"_id":"source/img/0044.png","path":"img/0044.png","modified":0,"renderable":0},{"_id":"source/img/0046.png","path":"img/0046.png","modified":0,"renderable":0},{"_id":"source/img/0047.png","path":"img/0047.png","modified":0,"renderable":0},{"_id":"source/img/0048.png","path":"img/0048.png","modified":0,"renderable":0},{"_id":"source/img/0049.png","path":"img/0049.png","modified":0,"renderable":0},{"_id":"source/img/0050.png","path":"img/0050.png","modified":0,"renderable":0},{"_id":"source/img/0051.png","path":"img/0051.png","modified":0,"renderable":0},{"_id":"source/pdf/最新面试文档.pdf","path":"pdf/最新面试文档.pdf","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2023-05-06-hello.md","hash":"a2eec44674a1d642a471c295180d57005cbbe8a0","modified":1683371084943},{"_id":"source/_posts/2023-05-05-hahaha.md","hash":"279d738c23562c21fa7048ef02d5ba493d5ee110","modified":1683371067202},{"_id":"source/about/index.md","hash":"3cfe6e3ae082d20645cef545ea05d3b7abc1c18f","modified":1683379883506},{"_id":"source/_posts/2023-05-06-imgtest.md","hash":"d10bb0c646ec8f0c3159e59d9600a6fae22ce7ee","modified":1683304536965},{"_id":"source/_posts/hello-world.md","hash":"63b9651d17aa34659fc47db2c45eb50a446bee15","modified":1683371124274},{"_id":"source/tags/index.md","hash":"248d282c6efe8ef0333c30f48ed1fb2b62ab4237","modified":1683280513472},{"_id":"source/images/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1622676726087},{"_id":"source/_posts/2023-05-05-hahaha/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1622676726087},{"_id":"source/_posts/2023-05-06-imgtest/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1622676726087},{"_id":"themes/sky/layout/_partial/categorys.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1683278393471},{"_id":"themes/sky/_config.yml","hash":"c60ec65367d586631bce2f51fa021ed661b86b3a","modified":1683371050956},{"_id":"themes/sky/README.md","hash":"09dbed10c11d9b553a2c6f4cb94d52a92059bda7","modified":1683278393469},{"_id":"themes/sky/layout/about.ejs","hash":"76b3601cb6103746d5e630209cd8b266e32991c3","modified":1683278393473},{"_id":"themes/sky/layout/archive.ejs","hash":"76e4a586a1651e11dd68184b8d57280ec518c487","modified":1683278393473},{"_id":"themes/sky/layout/categories.ejs","hash":"8f948a44125620fa62ca24887eca515c6cf9d64e","modified":1683278393474},{"_id":"themes/sky/layout/index.ejs","hash":"4e3a2e8b3972e74faa530a9c6a2f5f757ccc5535","modified":1683278393474},{"_id":"themes/sky/languages/en.yml","hash":"1cbbb9cac7753903aa55c739d8805cd3d4e7cae0","modified":1683278393470},{"_id":"themes/sky/layout/layout.ejs","hash":"c1601dcfa435ec603a3de0422f0d543c15c806a0","modified":1683278393474},{"_id":"themes/sky/languages/zh-CN.yml","hash":"fcac8318f44201d3047869b6c795886bf4d7a380","modified":1683278393470},{"_id":"themes/sky/layout/post.ejs","hash":"28fc2e70f5a8c98d5177b4639e6adb19b63c410d","modified":1683278393474},{"_id":"themes/sky/languages/default.yml","hash":"fcac8318f44201d3047869b6c795886bf4d7a380","modified":1683278393469},{"_id":"themes/sky/layout/tags.ejs","hash":"926231b0bb373c67fd5ced2bd2c7a74df36429d4","modified":1683278393475},{"_id":"themes/sky/layout/_partial/head.ejs","hash":"59c2f21b2757fe9e225cc1c1587b84ce079abab0","modified":1683278393471},{"_id":"themes/sky/layout/_partial/copyright.ejs","hash":"6181b792dcbab376880826ef7d988682201dfddd","modified":1683278393471},{"_id":"themes/sky/layout/_partial/header.ejs","hash":"f7ce3e651ef299ba10bbf0fd2e67561466faca12","modified":1683278393471},{"_id":"themes/sky/layout/_partial/mobile-header.ejs","hash":"c6865a03f907829f9043680265b6c6f029c146d9","modified":1683278393472},{"_id":"themes/sky/layout/_partial/social.ejs","hash":"0740b2c42d97ff3ff9968322bcd8bd41697f8e5f","modified":1683365998599},{"_id":"themes/sky/layout/_partial/paginator.ejs","hash":"8390ff839e440ad6bd458543ed5b3b0e52bf7e78","modified":1683278393472},{"_id":"themes/sky/layout/_partial/toc.ejs","hash":"152da61440963d08fe17190d3657907b3fb8d006","modified":1683278393473},{"_id":"themes/sky/source/css/_variables.scss","hash":"e12dd6adf8777df4839491c6f8d6ee39e288afad","modified":1683278393479},{"_id":"themes/sky/source/css/_reset.scss","hash":"05572018b6da81f21a9acfd12a73226a16a6d036","modified":1683278393479},{"_id":"themes/sky/source/css/gitment.css","hash":"c6951e8c4d709f1917c2cf78b9777d9610cb6532","modified":1683278393480},{"_id":"themes/sky/source/css/style.scss","hash":"69e0c5fe524ded6d1d69e9d66d3ff988de469571","modified":1683278393481},{"_id":"themes/sky/source/js/index.js","hash":"d920bfbafa72d5bc76eaa2870850c215b0503163","modified":1683278393481},{"_id":"themes/sky/source/css/_partial/_header.scss","hash":"4490dd9e14887e0d194d48a457e16e3700181276","modified":1683278393476},{"_id":"themes/sky/source/css/_partial/_paginator.scss","hash":"3936f82d0728589d95a0243b798771bb3278f621","modified":1683278393476},{"_id":"themes/sky/source/css/_partial/_post.scss","hash":"b0d0b07f8dc4c17f0f435124f2d2bcc0a1eead2a","modified":1683278393476},{"_id":"themes/sky/source/css/_partial/archive.scss","hash":"b150551b69c45673c19b9d65cffbb135fcbd2e7f","modified":1683278393477},{"_id":"themes/sky/source/css/_partial/_tags.scss","hash":"abd235a70cb0f5edb2042e412ddde5aa63a6618a","modified":1683278393477},{"_id":"themes/sky/source/css/_partial/mobile.scss","hash":"968812f56630bd98cf2277f912d8ac634244a5e5","modified":1683278393477},{"_id":"themes/sky/source/css/_partial/social.scss","hash":"f4126828c799557f177d24ee4d68277b6c3d2aa7","modified":1683278393478},{"_id":"themes/sky/source/css/_partial/copyright.scss","hash":"8265d6b06dc3c9474475e3bce7aef71e6a185c1b","modified":1683278393477},{"_id":"themes/sky/source/css/common/third-part.scss","hash":"9e6c9d7bab372df6983206b169ce5f9e6a7a5f9f","modified":1683278393480},{"_id":"themes/sky/source/css/_partial/post/code.scss","hash":"7372a76bf7c8d8828c670708e42f096fb9e8b918","modified":1683278393478},{"_id":"themes/sky/source/css/_partial/post/toc.scss","hash":"c70f20162c5eaaea6d9f87c85aee1483cfd4a6d5","modified":1683278393478},{"_id":"themes/sky/source/css/common/_utils.scss","hash":"4dab0d4bbd787c78550d6d3a45d94aee93ba1b76","modified":1683278393480},{"_id":"public/about/index.html","hash":"ab127c568839093f19fc51e1cdc2767e1ddb75c8","modified":1683305445967},{"_id":"public/tags/index.html","hash":"371883ccecffba1ca4e793e09af5ca27cdfe45dc","modified":1683305445967},{"_id":"public/2023/05/06/imgtest/index.html","hash":"bf49ce656ee1b23a8fefe0560c995b1d510a011d","modified":1683305445967},{"_id":"public/2023/05/06/hello/index.html","hash":"ef7745f76461d0de9c24ae018ef4564b3333aea6","modified":1683305445967},{"_id":"public/2023/05/05/hahaha/index.html","hash":"1b7911c52872c1ee1098ec5a2ec050a5492f2838","modified":1683305445967},{"_id":"public/2023/05/05/hello-world/index.html","hash":"98e701dcec8b8007d7da264893ca427bd41adf7a","modified":1683305445967},{"_id":"public/archives/index.html","hash":"5a8eb21fbc6547c0d023d07351e376b90c489b5b","modified":1683305445967},{"_id":"public/archives/2023/index.html","hash":"5a8eb21fbc6547c0d023d07351e376b90c489b5b","modified":1683305445967},{"_id":"public/archives/2023/05/index.html","hash":"5a8eb21fbc6547c0d023d07351e376b90c489b5b","modified":1683305445967},{"_id":"public/index.html","hash":"cb58f739b920746e12cfdd660c75076698905c33","modified":1683305445967},{"_id":"public/css/style.css","hash":"b6d4afb2e85679da41ad5fc845e4aa661acba3f2","modified":1683305445967},{"_id":"public/css/common/third-part.css","hash":"90b3753ca86ce3992ea70b3b8ade30add817f3a1","modified":1683305445967},{"_id":"public/js/index.js","hash":"907faae45c668d3650efa971da364dddb674fb19","modified":1683305445967},{"_id":"public/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1683305445967},{"_id":"public/2023/05/05/hahaha/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1683305445967},{"_id":"public/images/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1683305445967},{"_id":"public/2023/05/06/imgtest/dog.jpg","hash":"a5bb132ac160061ab83c4c7b04a2f441b11a46c1","modified":1683305445967},{"_id":"source/_posts/2023-05-06-56.md","hash":"def297253e625389e1b264fe599ed382118ac19a","modified":1683383966274},{"_id":"source/_posts/2023-05-06-redis应用问题解决.md","hash":"dd3a75901f1f606c3f45b8ee784261a1d3ee171e","modified":1683368990422},{"_id":"source/categories/index.md","hash":"1be552089d7cd7085c717ff7130688bb29acd77c","modified":1683369645276},{"_id":"source/_posts/2023-05-06-redis应用问题解决/1.png","hash":"67a0ba529d303261c378fc6e1b33bda2c10c8a04","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存击穿方案.png","hash":"cccd5f058f98d3b30fccecda1cf441a69826ea70","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存击穿.png","hash":"db1d2a396722b20f362cc5eab778c3e1f660c39c","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/4cb065a31ddd414e8c45a4a08754c823.jpg","hash":"9da1c134f36064307e9c4c25e8ecfbebfc53bafe","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/75fad2d93da642fcb6006e7d538cba88.jpg","hash":"552a9e900c63eb8dda135925e6303026169d2765","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/a6179f036c6a428fa92a5a541482490c.jpg","hash":"7d7374d7307ce2091051a47c9e6a209b06319361","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存穿透.png","hash":"5918159f51ffd4dbd6b8ca1d83ec3b4b014467ba","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存雪崩.png","hash":"d1f4aa9971741ce480b4a70135ab81b1120c4338","modified":1683366298000},{"_id":"source/_posts/2023-05-06-redis应用问题解决/雪崩失效.png","hash":"9265f2dbab25bf3199d57bddffc65c482a46141a","modified":1683366298000},{"_id":"source/_posts/2023-05-06-一、NIO基础.md","hash":"137f57dc03ebc7f04e4e852d46e47d8e037bcbdf","modified":1683378574958},{"_id":"source/img/0002.png","hash":"76e8ec4a329305df75e686e1499a1fcfef28a48b","modified":1576465397802},{"_id":"source/img/0003.png","hash":"f88160bfdfa7d18b6ec581832048bd115b350978","modified":1576467757524},{"_id":"source/img/0004.png","hash":"56e8063afd3100cd71d02e5d643275ebf6182224","modified":1576468444467},{"_id":"source/img/0009.png","hash":"245587e00e32a3c8f254622c78da8768dc1ea0ae","modified":1580602751536},{"_id":"source/img/0007.png","hash":"1bf830cd4d9266f17885a0015dc507182869b24b","modified":1580548532607},{"_id":"source/img/0006.png","hash":"2edeec19dca4f2c7e443f407f16b4eabe6c7cb1f","modified":1580547899096},{"_id":"source/img/0011.png","hash":"3df876cc1b2484ddaccfbbb23b4560f95ba395e2","modified":1580689327536},{"_id":"source/img/0010.png","hash":"154b0fe38f17b0a3a2274678c46d904c81992e3b","modified":1580611912643},{"_id":"source/img/0012.png","hash":"db9a6ffaa093d18056fa703b100e31e8805d81df","modified":1580690587254},{"_id":"source/img/0008.png","hash":"d23ea1f639c13ceea108f5bc6d03dcee6ba3ef81","modified":1580600424891},{"_id":"source/img/0013.png","hash":"3189592e9908d11b786f59b2f43931f909e8abe5","modified":1580782624517},{"_id":"source/img/0018.png","hash":"63d721d63500789ee8909cd0ee04adeb6c6b8974","modified":1582773856623},{"_id":"source/img/0020.png","hash":"4674c073279b7888edae9ab0a394d59d2a539aa8","modified":1582774177522},{"_id":"source/img/0019.png","hash":"55ade7c8191b0ec5e14f71fc0dc0301e14347cb7","modified":1582773953627},{"_id":"source/img/0021.png","hash":"5efb2e98c80b9e86dd3031259710c3700c37d27b","modified":1582789544096},{"_id":"source/img/0022.png","hash":"ed862f95d75a8b992465ab88f055dc3bd0e58662","modified":1582789882657},{"_id":"source/img/0024.png","hash":"b22abaded76964b91b4a56b575c38adde7d29f01","modified":1582936752600},{"_id":"source/img/0023.png","hash":"df92b9c5eea09bdd395912342c2f79661addb92c","modified":1582888604899},{"_id":"source/img/0025.png","hash":"13e61cd02557c8d157ab089dbe0a9ac308b3e06a","modified":1582938452076},{"_id":"source/img/0026.png","hash":"92e1a42c25cab686d9015c192298bf76f6dd71cb","modified":1582939249814},{"_id":"source/img/0027.png","hash":"933392922d2d7cc72a2af6f48e2cf98e68d18e4f","modified":1582939749190},{"_id":"source/img/0034.png","hash":"cfc68a88844e120e29e31195accfea6daafcefae","modified":1588901119971},{"_id":"source/img/0033.png","hash":"4356ac6e209098902474dcd055f77ef673f4ff85","modified":1588812634143},{"_id":"source/img/0035.png","hash":"feca8a338df0a24ce109bdc27c229f0becaa2f02","modified":1588901138282},{"_id":"source/img/0037.png","hash":"6bfdffeccd1c2b2a2d7f4d1f2c5bcaaa70d9a021","modified":1588901161667},{"_id":"source/img/0039.png","hash":"9f37a4dbd61027d9ee191bd2e5b7d0573776be42","modified":1588901314785},{"_id":"source/img/0038.png","hash":"11cd3ffc851b57396a3aed27d6b25d8f1c82199f","modified":1588901301427},{"_id":"source/img/0036.png","hash":"5718d91d2234e8ea26125e32a2c34c530f130884","modified":1588901149600},{"_id":"source/img/0041.png","hash":"6002118331cbaa548ce8f5f9240444888c5bcbaa","modified":1588932341293},{"_id":"source/img/0043.png","hash":"50a67207d7845537fde236023a90d956e0f23204","modified":1588982843314},{"_id":"source/img/0042.png","hash":"b2c47cb1d4ea434e2aff96799d63792cec924d81","modified":1588932460871},{"_id":"source/img/0046.png","hash":"4f2149005076b1eecaaaee2fe094c3ba2e22ef9c","modified":1588984645182},{"_id":"source/img/0048.png","hash":"ff10d24f9841e21bed39cd9b0810e5fd3457c639","modified":1588985494471},{"_id":"source/img/0044.png","hash":"c6a068d2680b3550e4e3151b18b268a66ddfc792","modified":1588984292594},{"_id":"source/img/0049.png","hash":"cc7052276940a81eafea9989611cae2e87f904de","modified":1589116988340},{"_id":"source/img/0047.png","hash":"c55624f5976d3703e98704ff29c908891a670dcb","modified":1588985170541},{"_id":"source/_posts/2023-05-06-Netty01-nio.md","hash":"5953a5012840d56911a15cd7b0917e006c1e49bf","modified":1683379669808},{"_id":"source/img/0050.png","hash":"29e833537e09cd6e3b4d58438fc7dbae72153b84","modified":1589117403386},{"_id":"source/img/0001.png","hash":"4170ac5fdcb6c5cbedfbf924069256f1a737a744","modified":1577061603837},{"_id":"source/img/0005.png","hash":"765eaf6756aa86f2a2d4f5e475b7aba7670c9ab7","modified":1580543948670},{"_id":"source/img/0014.png","hash":"1e02282b73a7efbf3c412d7a9894b90aa8e32c92","modified":1582418030478},{"_id":"source/img/0017.png","hash":"15de689308e6065a83f09677656b503f50aeccb7","modified":1582464850217},{"_id":"source/img/0015.png","hash":"f4ea37e94d14672d9218c1c8e136beb2c53731e9","modified":1582458640890},{"_id":"source/img/0016.png","hash":"33beede5cae9bb6b4ca1a7fc4771f6ace9b6c2c2","modified":1582464526224},{"_id":"source/img/0032.png","hash":"ef86fa62fa99a8ad37829611dc505131880c8229","modified":1587859741142},{"_id":"source/img/0031.jpg","hash":"0c26b8166787344ec72a9e038efcd250e989c167","modified":1586832370229},{"_id":"source/img/0051.png","hash":"0d1de02660bbc9cddb63790d4ce198eda785d2fe","modified":1589117633820},{"_id":"source/img/0028.jpg","hash":"db629619cb128f44e56c697b0a23ff9ec2380a2e","modified":1586827114643},{"_id":"source/img/0040.png","hash":"cb457d4f1d518f1517373177aacbcf42decbddcf","modified":1588918528647},{"_id":"source/img/0029.jpg","hash":"838454e5c0ec853e840f61bc64359bd40b1622c5","modified":1586827355229},{"_id":"source/img/0030.jpg","hash":"1eb9f9d7d086986e7a09e7a7ce2e3146e99d9d6c","modified":1586827952242},{"_id":"source/_posts/2023-05-06-Netty04-优化与源码.md","hash":"a85c9f5fda9bfd5f2c735d80ba0fe68c6093a06b","modified":1683379682746},{"_id":"source/_posts/2023-05-06-Netty02-入门.md","hash":"5df10e22429ac1f947009e39a426f1df0e4d2af6","modified":1683379676452},{"_id":"source/_posts/2023-05-06-Netty03-进阶.md","hash":"fec76e5ed474469d84121d0b196d061e257e406c","modified":1683379679734},{"_id":"source/pdf/最新面试文档.pdf","hash":"f5008ef782e717080411d16ec75d136a46dfee05","modified":1680801277184},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1683441870711},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"30e3f4ccfef8474c05cf0b1eb02e91bd0a152807","modified":1683441870661},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"088788e149051fc0a3c6096ba95e35a8344de04b","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1683441870532},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1683441870661},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1683441870721},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1683441870721},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1683441870551},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1683441870721},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1683441870560},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1683441870610},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1683441870611},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1683441870611},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1683441870661},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1683441870630},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1683441870631},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1683441870661},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1683441870650},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1683441870651},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1683441870652},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1683441870661},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1683441870552},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1683441870613},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1683441870592},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1683441870561},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1683441870540},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1683441870632},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1683441870640},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1683441870641},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1683441870601},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1683441870621},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1683441870700},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1683441870691},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1683441870711},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1683441870671},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1683441870681},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1683441870692},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1683441870701},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1683441870710},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1683441870712},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1683441870671}],"Category":[{"name":"基础","_id":"clhbvc46q00025sweh2wj1313"},{"name":"入门","_id":"clhbvc46w00055swe2igy3696"},{"name":"poem","parent":"clhbvc46q00025sweh2wj1313","_id":"clhbvc46x00085swe8ib0h57j"},{"name":"redis","_id":"clhbvc46y000b5swec8c9avpe"},{"name":"基础","parent":"clhbvc46w00055swe2igy3696","_id":"clhbvc46y000f5sweatpfecfi"},{"name":"base","parent":"clhbvc46y000f5sweatpfecfi","_id":"clhbvc46z000k5swec7mfd7mz"},{"name":"poem","_id":"clhbvdtey000p5swefoq65ef3"},{"name":"诗词","_id":"clhbvo2qh000r5swe8h826yri"},{"name":"Netty","_id":"clhc0tpow0001d8we03td8on6"}],"Data":[],"Page":[{"layout":"about","_content":"# 联系\n\nI really **like** using Markdown.\n\nI **think** I'll use it to format all of my documents from now on.\n\n```\nJava 是世界上最好的语言！\n```\n\n![123](/images/dog.jpg)\n<!-- 以上是有效格式 -->\n## 这是郭旭东,此人是一名兽医\n\n郭医生QQ:13004331**\n","source":"about/index.md","raw":"---\nlayout: about\n---\n# 联系\n\nI really **like** using Markdown.\n\nI **think** I'll use it to format all of my documents from now on.\n\n```\nJava 是世界上最好的语言！\n```\n\n![123](/images/dog.jpg)\n<!-- 以上是有效格式 -->\n## 这是郭旭东,此人是一名兽医\n\n郭医生QQ:13004331**\n","date":"2023-05-06T13:31:23.506Z","updated":"2023-05-06T13:31:23.506Z","path":"about/index.html","_id":"clhasln990000mkwehjz75v8w","title":"","comments":1,"content":"<h1 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h1><p>I really <strong>like</strong> using Markdown.</p>\n<p>I <strong>think</strong> I’ll use it to format all of my documents from now on.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java 是世界上最好的语言！</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/dog.jpg\" alt=\"123\"></p>\n<!-- 以上是有效格式 -->\n<h2 id=\"这是郭旭东-此人是一名兽医\"><a href=\"#这是郭旭东-此人是一名兽医\" class=\"headerlink\" title=\"这是郭旭东,此人是一名兽医\"></a>这是郭旭东,此人是一名兽医</h2><p>郭医生QQ:13004331**</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h1><p>I really <strong>like</strong> using Markdown.</p>\n<p>I <strong>think</strong> I’ll use it to format all of my documents from now on.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java 是世界上最好的语言！</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/dog.jpg\" alt=\"123\"></p>\n<!-- 以上是有效格式 -->\n<h2 id=\"这是郭旭东-此人是一名兽医\"><a href=\"#这是郭旭东-此人是一名兽医\" class=\"headerlink\" title=\"这是郭旭东,此人是一名兽医\"></a>这是郭旭东,此人是一名兽医</h2><p>郭医生QQ:13004331**</p>\n"},{"layout":"tags","_content":"","source":"tags/index.md","raw":"---\nlayout: tags\n---\n","date":"2023-05-05T09:55:13.472Z","updated":"2023-05-05T09:55:13.472Z","path":"tags/index.html","title":"","comments":1,"_id":"clhasln9g0002mkweh9717z0a","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"categories","_content":"","source":"categories/index.md","raw":"---\nlayout: categories\n---\n","date":"2023-05-06T10:40:45.276Z","updated":"2023-05-06T10:40:45.276Z","path":"categories/index.html","title":"","comments":1,"_id":"clhbvc46k00005swedugb4b59","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"hahaha","date":"2023-05-05T15:51:04.000Z","_content":"\n衣带渐宽终不悔,为伊消得人憔悴\n\n<!-- more -->\n蓦然回首,那人竟在灯火阑珊处。\n<!-- ![这是图片](blog\\source\\_posts\\2023-05-05-hahaha\\dog.jpg \"Magic Gardens\") #无效格式1 -->\n\n![123](/images/dog.jpg) # 有效格式1\n\n++++++++++\n\n![222](dog.jpg) #无效格式\n\n+++++++++++\n\n![123](/images/dog.jpg) # 有效格式1\n++++++++++++\n![12](/images/dog.jpg) # 有效格式2\n","source":"_posts/2023-05-05-hahaha.md","raw":"---\ntitle: hahaha\ndate: 2023-05-05 23:51:04\ntags: 诗词歌赋\ncategories: 诗词\n---\n\n衣带渐宽终不悔,为伊消得人憔悴\n\n<!-- more -->\n蓦然回首,那人竟在灯火阑珊处。\n<!-- ![这是图片](blog\\source\\_posts\\2023-05-05-hahaha\\dog.jpg \"Magic Gardens\") #无效格式1 -->\n\n![123](/images/dog.jpg) # 有效格式1\n\n++++++++++\n\n![222](dog.jpg) #无效格式\n\n+++++++++++\n\n![123](/images/dog.jpg) # 有效格式1\n++++++++++++\n![12](/images/dog.jpg) # 有效格式2\n","slug":"hahaha","published":1,"updated":"2023-05-06T11:04:27.202Z","_id":"clhasln9b0001mkwegm5jb6zz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>衣带渐宽终不悔,为伊消得人憔悴</p>\n<span id=\"more\"></span>\n<p>蓦然回首,那人竟在灯火阑珊处。</p>\n<!-- ![这是图片](blog\\source\\_posts\\2023-05-05-hahaha\\dog.jpg \"Magic Gardens\") #无效格式1 -->\n\n<p><img src=\"/images/dog.jpg\" alt=\"123\"> # 有效格式1</p>\n<p>++++++++++</p>\n<p><img src=\"/2023/05/05/hahaha/dog.jpg\" alt=\"222\"> #无效格式</p>\n<p>+++++++++++</p>\n<p><img src=\"/images/dog.jpg\" alt=\"123\"> # 有效格式1<br>++++++++++++<br><img src=\"/images/dog.jpg\" alt=\"12\"> # 有效格式2</p>\n","site":{"data":{}},"excerpt":"<p>衣带渐宽终不悔,为伊消得人憔悴</p>","more":"<p>蓦然回首,那人竟在灯火阑珊处。</p>\n<!-- ![这是图片](blog\\source\\_posts\\2023-05-05-hahaha\\dog.jpg \"Magic Gardens\") #无效格式1 -->\n\n<p><img src=\"/images/dog.jpg\" alt=\"123\"> # 有效格式1</p>\n<p>++++++++++</p>\n<p><img src=\"/2023/05/05/hahaha/dog.jpg\" alt=\"222\"> #无效格式</p>\n<p>+++++++++++</p>\n<p><img src=\"/images/dog.jpg\" alt=\"123\"> # 有效格式1<br>++++++++++++<br><img src=\"/images/dog.jpg\" alt=\"12\"> # 有效格式2</p>"},{"title":"hello","date":"2023-05-05T16:29:33.000Z","_content":"\nHello world!\n<!-- more -->\n\n1\n2\n3\n4\n5\ngxd*******************\n","source":"_posts/2023-05-06-hello.md","raw":"---\ntitle: hello\ndate: 2023-05-06 00:29:33\ntags: hello,world\ncategories: 入门\n \n---\n\nHello world!\n<!-- more -->\n\n1\n2\n3\n4\n5\ngxd*******************\n","slug":"hello","published":1,"updated":"2023-05-06T11:04:44.943Z","_id":"clhasln9h0003mkweeap8a1ci","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Hello world!</p>\n<span id=\"more\"></span>\n\n<p>1<br>2<br>3<br>4<br>5<br>gxd*******************</p>\n","site":{"data":{}},"excerpt":"<p>Hello world!</p>","more":"<p>1<br>2<br>3<br>4<br>5<br>gxd*******************</p>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: 入门\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-05-05T09:05:03.971Z","updated":"2023-05-06T11:05:24.274Z","_id":"clhasln9o0005mkwedbvy12jt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<span id=\"more\"></span>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"56","date":"2023-05-06T06:43:18.000Z","_content":"\n今日时间\n14点44分 2023年5月6日\n[Download PDF](/pdf/最新面试文档.pdf)\n","source":"_posts/2023-05-06-56.md","raw":"---\ntitle: 56\ndate: 2023-05-06 14:43:18\ntags: programing\ncategories: 诗词\n---\n\n今日时间\n14点44分 2023年5月6日\n[Download PDF](/pdf/最新面试文档.pdf)\n","slug":"56","published":1,"updated":"2023-05-06T14:39:26.274Z","_id":"clhbvc46p00015swebt8903lv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今日时间<br>14点44分 2023年5月6日<br><a href=\"/pdf/%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E6%96%87%E6%A1%A3.pdf\">Download PDF</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今日时间<br>14点44分 2023年5月6日<br><a href=\"/pdf/%E6%9C%80%E6%96%B0%E9%9D%A2%E8%AF%95%E6%96%87%E6%A1%A3.pdf\">Download PDF</a></p>\n"},{"title":"redis应用问题解决","date":"2023-05-06T10:03:21.000Z","_content":"\n在学习Redis的过程中，我结合尚硅谷的视频对配套笔记做了一些整理。\n<!-- more -->\n\n# Redis 应用问题解决\n\n- 缓存穿透\n- 缓存击穿\n- 缓存雪崩\n\n## 一、缓存穿透\n\nkey 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如\n\n用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n\n缓存穿透发生的条件：\n\n1. 应用服务器压力变大\n2. redis 命中率降低\n3. 一直查询数据库，使得数据库压力太大而压垮\n\n其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。\n\n缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的 url 访问，使得 redis 查询不到数据库。\n\n![缓存穿透](缓存穿透.png)\n\n### 解决方案\n\n1. 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。\n2. 设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。\n3. 采用布隆过滤器：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n4. 进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。\n\n## 二、缓存击穿\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。\n\n**缓存击穿的现象：**\n\n数据库访问压力瞬时增加，数据库崩溃\n\nredis 里面没有出现大量 key 过期\n\nredis 正常运行\n\n**缓存击穿发生的原因**：redis 某个 key 过期了，大量访问使用这个 key（热门 key）。\n\n![](缓存击穿.png)\n\n### 解决方案\n\nkey 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。\n\n1. 预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。\n2. 实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。\n3. 使用锁：\n                                                    1. 就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。\n                        2. 先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key。\n                        3. 当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；\n                        4. 当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。\n\n![](缓存击穿方案.png)\n\n## 三、缓存雪崩\n\n**问题描述**\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。\n\n\n\n缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key 正常访问。\n\n![](缓存雪崩.png)缓存失效瞬间：![](雪崩失效.png)\n\n\n\n**解决方案**\n\n1. 构建多级缓存架构：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。\n2. 使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。\n3. 设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。\n4. 将缓存失效时间分散开：比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n\n## 四、分布式锁\n\n**问题描述**\n\n随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！\n\n分布式锁主流的实现方案：\n\n2. 基于数据库实现分布式锁\n3. 基于缓存（Redis 等）\n4. 基于 Zookeeper\n\n措施： setnx 上锁 del解锁\n\n         设置过期时间\n\n        原子操作：设置锁的同时设置过期时间 \n\n         set key value nx ex 10\n\n\n\n**根据实现方式，分布式锁还可以分为类 CAS 自旋式分布式锁以及 event 事件类型分布式锁：**\n\n\n\n- 类 CAS 自旋式分布式锁：询问的方式，类似 java 并发编程中的线程获询问的方式尝试加锁，如 mysql、redis。\n- 另外一类是 event 事件通知进程后续锁的变化，轮询向外的过程，如 zookeeper、etcd。\n\n每一种分布式锁解决方案都有各自的优缺点：\n\n\n\n性能：redis 最高\n\n可靠性：zookeeper 最高\n\n\n\nsetnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。\n\n\n\nset key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。\n\n**问题**\n![](4cb065a31ddd414e8c45a4a08754c823.jpg)\n\nuuid：设置 uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。\n\n\n\n使用uuid防止误删\n\n![](a6179f036c6a428fa92a5a541482490c.jpg)\n\n\n\n**问题**\n\n![](75fad2d93da642fcb6006e7d538cba88.jpg)\n\n使用lua脚本保持原子性操作\n\n\n\n\n\n### \n\n### RedLock\n\nRedlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 redis 的分布式锁。RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。\n\n此种方式具有以下特性：\n\n互斥访问：即永远只有一个 client 能拿到锁。\n\n避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。\n\n容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务\n\n### RedLock 原理（了解）\n\n获取当前 Unix 时间，以毫秒为单位。\n\n依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。\n\n客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n\n如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。\n\n如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。\n\nNew:\n\nACL\n\nIO 多线程其实指客户端交互部分的网络 IO 交互处理模块 多线程，而非执行命令多线程。Redis6 执行命令依然是单线程。\n\nRedis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:\n![](1.png)\n","source":"_posts/2023-05-06-redis应用问题解决.md","raw":"---\ntitle: redis应用问题解决\ndate: 2023-05-06 18:03:21\ntags:\n- redis\n- 解决方案\ncategories: redis\n---\n\n在学习Redis的过程中，我结合尚硅谷的视频对配套笔记做了一些整理。\n<!-- more -->\n\n# Redis 应用问题解决\n\n- 缓存穿透\n- 缓存击穿\n- 缓存雪崩\n\n## 一、缓存穿透\n\nkey 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如\n\n用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n\n缓存穿透发生的条件：\n\n1. 应用服务器压力变大\n2. redis 命中率降低\n3. 一直查询数据库，使得数据库压力太大而压垮\n\n其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。\n\n缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的 url 访问，使得 redis 查询不到数据库。\n\n![缓存穿透](缓存穿透.png)\n\n### 解决方案\n\n1. 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。\n2. 设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。\n3. 采用布隆过滤器：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n4. 进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。\n\n## 二、缓存击穿\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。\n\n**缓存击穿的现象：**\n\n数据库访问压力瞬时增加，数据库崩溃\n\nredis 里面没有出现大量 key 过期\n\nredis 正常运行\n\n**缓存击穿发生的原因**：redis 某个 key 过期了，大量访问使用这个 key（热门 key）。\n\n![](缓存击穿.png)\n\n### 解决方案\n\nkey 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。\n\n1. 预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。\n2. 实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。\n3. 使用锁：\n                                                    1. 就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。\n                        2. 先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key。\n                        3. 当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；\n                        4. 当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。\n\n![](缓存击穿方案.png)\n\n## 三、缓存雪崩\n\n**问题描述**\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。\n\n\n\n缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key 正常访问。\n\n![](缓存雪崩.png)缓存失效瞬间：![](雪崩失效.png)\n\n\n\n**解决方案**\n\n1. 构建多级缓存架构：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。\n2. 使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。\n3. 设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。\n4. 将缓存失效时间分散开：比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n\n## 四、分布式锁\n\n**问题描述**\n\n随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！\n\n分布式锁主流的实现方案：\n\n2. 基于数据库实现分布式锁\n3. 基于缓存（Redis 等）\n4. 基于 Zookeeper\n\n措施： setnx 上锁 del解锁\n\n         设置过期时间\n\n        原子操作：设置锁的同时设置过期时间 \n\n         set key value nx ex 10\n\n\n\n**根据实现方式，分布式锁还可以分为类 CAS 自旋式分布式锁以及 event 事件类型分布式锁：**\n\n\n\n- 类 CAS 自旋式分布式锁：询问的方式，类似 java 并发编程中的线程获询问的方式尝试加锁，如 mysql、redis。\n- 另外一类是 event 事件通知进程后续锁的变化，轮询向外的过程，如 zookeeper、etcd。\n\n每一种分布式锁解决方案都有各自的优缺点：\n\n\n\n性能：redis 最高\n\n可靠性：zookeeper 最高\n\n\n\nsetnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。\n\n\n\nset key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。\n\n**问题**\n![](4cb065a31ddd414e8c45a4a08754c823.jpg)\n\nuuid：设置 uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。\n\n\n\n使用uuid防止误删\n\n![](a6179f036c6a428fa92a5a541482490c.jpg)\n\n\n\n**问题**\n\n![](75fad2d93da642fcb6006e7d538cba88.jpg)\n\n使用lua脚本保持原子性操作\n\n\n\n\n\n### \n\n### RedLock\n\nRedlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 redis 的分布式锁。RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。\n\n此种方式具有以下特性：\n\n互斥访问：即永远只有一个 client 能拿到锁。\n\n避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。\n\n容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务\n\n### RedLock 原理（了解）\n\n获取当前 Unix 时间，以毫秒为单位。\n\n依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。\n\n客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。\n\n如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。\n\n如果因为某些原因，获取锁失败（没有在至少 N/2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。\n\nNew:\n\nACL\n\nIO 多线程其实指客户端交互部分的网络 IO 交互处理模块 多线程，而非执行命令多线程。Redis6 执行命令依然是单线程。\n\nRedis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下:\n![](1.png)\n","slug":"redis应用问题解决","published":1,"updated":"2023-05-06T10:29:50.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhbvc46v00045swe64teb98l","content":"<p>在学习Redis的过程中，我结合尚硅谷的视频对配套笔记做了一些整理。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Redis-应用问题解决\"><a href=\"#Redis-应用问题解决\" class=\"headerlink\" title=\"Redis 应用问题解决\"></a>Redis 应用问题解决</h1><ul>\n<li>缓存穿透</li>\n<li>缓存击穿</li>\n<li>缓存雪崩</li>\n</ul>\n<h2 id=\"一、缓存穿透\"><a href=\"#一、缓存穿透\" class=\"headerlink\" title=\"一、缓存穿透\"></a>一、缓存穿透</h2><p>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p>\n<p>用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>\n<p>缓存穿透发生的条件：</p>\n<ol>\n<li>应用服务器压力变大</li>\n<li>redis 命中率降低</li>\n<li>一直查询数据库，使得数据库压力太大而压垮</li>\n</ol>\n<p>其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。</p>\n<p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的 url 访问，使得 redis 查询不到数据库。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png\" alt=\"缓存穿透\"></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</li>\n<li>设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</li>\n<li>采用布隆过滤器：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li>\n<li>进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</li>\n</ol>\n<h2 id=\"二、缓存击穿\"><a href=\"#二、缓存击穿\" class=\"headerlink\" title=\"二、缓存击穿\"></a>二、缓存击穿</h2><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>\n<p><strong>缓存击穿的现象：</strong></p>\n<p>数据库访问压力瞬时增加，数据库崩溃</p>\n<p>redis 里面没有出现大量 key 过期</p>\n<p>redis 正常运行</p>\n<p><strong>缓存击穿发生的原因</strong>：redis 某个 key 过期了，大量访问使用这个 key（热门 key）。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png\"></p>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>key 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。</p>\n<ol>\n<li>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。</li>\n<li>实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。</li>\n<li>使用锁：<br>                                             1. 就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。<br>                 2. 先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key。<br>                 3. 当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；<br>                 4. 当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。</li>\n</ol>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%96%B9%E6%A1%88.png\"></p>\n<h2 id=\"三、缓存雪崩\"><a href=\"#三、缓存雪崩\" class=\"headerlink\" title=\"三、缓存雪崩\"></a>三、缓存雪崩</h2><p><strong>问题描述</strong></p>\n<p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>\n<p>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key 正常访问。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png\">缓存失效瞬间：<img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E9%9B%AA%E5%B4%A9%E5%A4%B1%E6%95%88.png\"></p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>构建多级缓存架构：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。</li>\n<li>使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</li>\n<li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</li>\n<li>将缓存失效时间分散开：比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>\n</ol>\n<h2 id=\"四、分布式锁\"><a href=\"#四、分布式锁\" class=\"headerlink\" title=\"四、分布式锁\"></a>四、分布式锁</h2><p><strong>问题描述</strong></p>\n<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>\n<p>分布式锁主流的实现方案：</p>\n<ol start=\"2\">\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存（Redis 等）</li>\n<li>基于 Zookeeper</li>\n</ol>\n<p>措施： setnx 上锁 del解锁</p>\n<pre><code>     设置过期时间\n\n    原子操作：设置锁的同时设置过期时间 \n\n     set key value nx ex 10\n</code></pre>\n<p><strong>根据实现方式，分布式锁还可以分为类 CAS 自旋式分布式锁以及 event 事件类型分布式锁：</strong></p>\n<ul>\n<li>类 CAS 自旋式分布式锁：询问的方式，类似 java 并发编程中的线程获询问的方式尝试加锁，如 mysql、redis。</li>\n<li>另外一类是 event 事件通知进程后续锁的变化，轮询向外的过程，如 zookeeper、etcd。</li>\n</ul>\n<p>每一种分布式锁解决方案都有各自的优缺点：</p>\n<p>性能：redis 最高</p>\n<p>可靠性：zookeeper 最高</p>\n<p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p>\n<p>set key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p>\n<p><strong>问题</strong><br><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/4cb065a31ddd414e8c45a4a08754c823.jpg\"></p>\n<p>uuid：设置 uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p>\n<p>使用uuid防止误删</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/a6179f036c6a428fa92a5a541482490c.jpg\"></p>\n<p><strong>问题</strong></p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/75fad2d93da642fcb6006e7d538cba88.jpg\"></p>\n<p>使用lua脚本保持原子性操作</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"RedLock\"><a href=\"#RedLock\" class=\"headerlink\" title=\"RedLock\"></a>RedLock</h3><p>Redlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 redis 的分布式锁。RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。</p>\n<p>此种方式具有以下特性：</p>\n<p>互斥访问：即永远只有一个 client 能拿到锁。</p>\n<p>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</p>\n<p>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</p>\n<h3 id=\"RedLock-原理（了解）\"><a href=\"#RedLock-原理（了解）\" class=\"headerlink\" title=\"RedLock 原理（了解）\"></a>RedLock 原理（了解）</h3><p>获取当前 Unix 时间，以毫秒为单位。</p>\n<p>依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</p>\n<p>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p>\n<p>如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</p>\n<p>如果因为某些原因，获取锁失败（没有在至少 N&#x2F;2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。</p>\n<p>New:</p>\n<p>ACL</p>\n<p>IO 多线程其实指客户端交互部分的网络 IO 交互处理模块 多线程，而非执行命令多线程。Redis6 执行命令依然是单线程。</p>\n<p>Redis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:<br><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/1.png\"></p>\n","site":{"data":{}},"excerpt":"<p>在学习Redis的过程中，我结合尚硅谷的视频对配套笔记做了一些整理。</p>","more":"<h1 id=\"Redis-应用问题解决\"><a href=\"#Redis-应用问题解决\" class=\"headerlink\" title=\"Redis 应用问题解决\"></a>Redis 应用问题解决</h1><ul>\n<li>缓存穿透</li>\n<li>缓存击穿</li>\n<li>缓存雪崩</li>\n</ul>\n<h2 id=\"一、缓存穿透\"><a href=\"#一、缓存穿透\" class=\"headerlink\" title=\"一、缓存穿透\"></a>一、缓存穿透</h2><p>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源（数据库），从而可能压垮数据源。比如</p>\n<p>用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>\n<p>缓存穿透发生的条件：</p>\n<ol>\n<li>应用服务器压力变大</li>\n<li>redis 命中率降低</li>\n<li>一直查询数据库，使得数据库压力太大而压垮</li>\n</ol>\n<p>其实 redis 在这个过程中一直平稳运行，崩溃的是我们的数据库（如 MySQL）。</p>\n<p>缓存穿透发生的原因：黑客或者其他非正常用户频繁进行很多非正常的 url 访问，使得 redis 查询不到数据库。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png\" alt=\"缓存穿透\"></p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</li>\n<li>设置可访问的名单（白名单）：使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，不允许访问。</li>\n<li>采用布隆过滤器：布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量 (位图) 和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li>\n<li>进行实时监控：当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</li>\n</ol>\n<h2 id=\"二、缓存击穿\"><a href=\"#二、缓存击穿\" class=\"headerlink\" title=\"二、缓存击穿\"></a>二、缓存击穿</h2><p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>\n<p><strong>缓存击穿的现象：</strong></p>\n<p>数据库访问压力瞬时增加，数据库崩溃</p>\n<p>redis 里面没有出现大量 key 过期</p>\n<p>redis 正常运行</p>\n<p><strong>缓存击穿发生的原因</strong>：redis 某个 key 过期了，大量访问使用这个 key（热门 key）。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png\"></p>\n<h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>key 可能会在某些时间点被超高并发地访问，是一种非常 “热点” 的数据。</p>\n<ol>\n<li>预先设置热门数据：在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面，加大这些热门数据 key 的时长。</li>\n<li>实时调整：现场监控哪些数据热门，实时调整 key 的过期时长。</li>\n<li>使用锁：<br>                                             1. 就是在缓存失效的时候（判断拿出来的值为空），不是立即去 load db。<br>                 2. 先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX）去 set 一个 mutex key。<br>                 3. 当操作返回成功时，再进行 load db 的操作，并回设缓存，最后删除 mutex key；<br>                 4. 当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个 get 缓存的方法。</li>\n</ol>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%96%B9%E6%A1%88.png\"></p>\n<h2 id=\"三、缓存雪崩\"><a href=\"#三、缓存雪崩\" class=\"headerlink\" title=\"三、缓存雪崩\"></a>三、缓存雪崩</h2><p><strong>问题描述</strong></p>\n<p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。</p>\n<p>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key 正常访问。</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.png\">缓存失效瞬间：<img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/%E9%9B%AA%E5%B4%A9%E5%A4%B1%E6%95%88.png\"></p>\n<p><strong>解决方案</strong></p>\n<ol>\n<li>构建多级缓存架构：nginx 缓存 + redis 缓存 + 其他缓存（ehcache 等）。</li>\n<li>使用锁或队列：用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，该方法不适用高并发情况。</li>\n<li>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</li>\n<li>将缓存失效时间分散开：比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</li>\n</ol>\n<h2 id=\"四、分布式锁\"><a href=\"#四、分布式锁\" class=\"headerlink\" title=\"四、分布式锁\"></a>四、分布式锁</h2><p><strong>问题描述</strong></p>\n<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程的特点以及分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的 Java API 并不能提供分布式锁的能力。为了解决这个问题就需要一种跨 JVM 的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>\n<p>分布式锁主流的实现方案：</p>\n<ol start=\"2\">\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存（Redis 等）</li>\n<li>基于 Zookeeper</li>\n</ol>\n<p>措施： setnx 上锁 del解锁</p>\n<pre><code>     设置过期时间\n\n    原子操作：设置锁的同时设置过期时间 \n\n     set key value nx ex 10\n</code></pre>\n<p><strong>根据实现方式，分布式锁还可以分为类 CAS 自旋式分布式锁以及 event 事件类型分布式锁：</strong></p>\n<ul>\n<li>类 CAS 自旋式分布式锁：询问的方式，类似 java 并发编程中的线程获询问的方式尝试加锁，如 mysql、redis。</li>\n<li>另外一类是 event 事件通知进程后续锁的变化，轮询向外的过程，如 zookeeper、etcd。</li>\n</ul>\n<p>每一种分布式锁解决方案都有各自的优缺点：</p>\n<p>性能：redis 最高</p>\n<p>可靠性：zookeeper 最高</p>\n<p>setnx：通过该命令尝试获得锁，没有获得锁的线程会不断等待尝试。</p>\n<p>set key ex 3000nx：设置过期时间，自动释放锁，解决当某一个业务异常而导致锁无法释放的问题。但是当业务运行超过过期时间时，开辟监控线程增加该业务的运行时间，直到运行结束，释放锁。</p>\n<p><strong>问题</strong><br><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/4cb065a31ddd414e8c45a4a08754c823.jpg\"></p>\n<p>uuid：设置 uuid，释放前获取这个值，判断是否自己的锁，防止误删锁，造成没锁的情况。</p>\n<p>使用uuid防止误删</p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/a6179f036c6a428fa92a5a541482490c.jpg\"></p>\n<p><strong>问题</strong></p>\n<p><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/75fad2d93da642fcb6006e7d538cba88.jpg\"></p>\n<p>使用lua脚本保持原子性操作</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"RedLock\"><a href=\"#RedLock\" class=\"headerlink\" title=\"RedLock\"></a>RedLock</h3><p>Redlock 是一种算法，Redlock 也就是 Redis Distributed Lock，可用实现多节点 redis 的分布式锁。RedLock 官方推荐，Redisson 完成了对 Redlock 算法封装。</p>\n<p>此种方式具有以下特性：</p>\n<p>互斥访问：即永远只有一个 client 能拿到锁。</p>\n<p>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使锁定资源的服务崩溃或者分区，仍然能释放锁。</p>\n<p>容错性：只要大部分 Redis 节点存活（一半以上），就可以正常提供服务</p>\n<h3 id=\"RedLock-原理（了解）\"><a href=\"#RedLock-原理（了解）\" class=\"headerlink\" title=\"RedLock 原理（了解）\"></a>RedLock 原理（了解）</h3><p>获取当前 Unix 时间，以毫秒为单位。</p>\n<p>依次尝试从 N 个实例，使用相同的 key 和随机值获取锁。在步骤 2，当向 Redis 设置锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为 10 秒，则超时时间应该在 5-50 毫秒之间。这样可以避免服务器端 Redis 已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个 Redis 实例。</p>\n<p>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</p>\n<p>如果取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 计算的结果）。</p>\n<p>如果因为某些原因，获取锁失败（没有在至少 N&#x2F;2+1 个 Redis 实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的 Redis 实例上进行解锁（即便某些 Redis 实例根本就没有加锁成功）。</p>\n<p>New:</p>\n<p>ACL</p>\n<p>IO 多线程其实指客户端交互部分的网络 IO 交互处理模块 多线程，而非执行命令多线程。Redis6 执行命令依然是单线程。</p>\n<p>Redis 6 加入多线程，但跟 Memcached 这种从 IO 处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:<br><img src=\"/2023/05/06/redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/1.png\"></p>"},{"title":"Netty01-nio","date":"2023-05-06T13:15:53.000Z","_content":"\n该笔记是B站黑马的Netty视频的配套笔记1。\n<!-- more -->\n# 一. NIO 基础\n\nnon-blocking io 非阻塞 IO\n\n## 1. 三大组件\n\n### 1.1 Channel & Buffer\n\nchannel 有一点类似于 stream，它就是读写数据的**双向通道**，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\n\n```mermaid\ngraph LR\nchannel --> buffer\nbuffer --> channel\n```\n\n常见的 Channel 有\n\n* FileChannel\n* DatagramChannel\n* SocketChannel\n* ServerSocketChannel\n\n\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\n* ByteBuffer\n  * MappedByteBuffer\n  * DirectByteBuffer\n  * HeapByteBuffer\n* ShortBuffer\n* IntBuffer\n* LongBuffer\n* FloatBuffer\n* DoubleBuffer\n* CharBuffer\n\n\n\n### 1.2 Selector\n\nselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n\n#### 多线程版设计\n\n```mermaid\ngraph TD\nsubgraph 多线程版\nt1(thread) --> s1(socket1)\nt2(thread) --> s2(socket2)\nt3(thread) --> s3(socket3)\nend\n```\n#### ⚠️ 多线程版缺点\n\n* 内存占用高\n* 线程上下文切换成本高\n* 只适合连接数少的场景\n\n\n\n\n\n\n\n#### 线程池版设计\n\n```mermaid\ngraph TD\nsubgraph 线程池版\nt4(thread) --> s4(socket1)\nt5(thread) --> s5(socket2)\nt4(thread) -.-> s6(socket3)\nt5(thread) -.-> s7(socket4)\nend\n```\n#### ⚠️ 线程池版缺点\n\n* 阻塞模式下，线程仅能处理一个 socket 连接\n* 仅适合短连接场景\n\n\n\n\n\n\n\n\n\n#### selector 版设计\n\nselector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --> selector\nselector --> c1(channel)\nselector --> c2(channel)\nselector --> c3(channel)\nend\n```\n\n\n\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n\n\n\n\n\n\n\n## 2. ByteBuffer\n\n有一普通文本文件 data.txt，内容为\n\n```\n1234567890abcd\n```\n\n使用 FileChannel 来读取文件内容\n\n```java\n@Slf4j\npublic class ChannelDemo1 {\n    public static void main(String[] args) {\n        try (RandomAccessFile file = new RandomAccessFile(\"helloword/data.txt\", \"rw\")) {\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(10);\n            do {\n                // 向 buffer 写入\n                int len = channel.read(buffer);\n                log.debug(\"读到字节数：{}\", len);\n                if (len == -1) {\n                    break;\n                }\n                // 切换 buffer 读模式\n                buffer.flip();\n                while(buffer.hasRemaining()) {\n                    log.debug(\"{}\", (char)buffer.get());\n                }\n                // 切换 buffer 写模式\n                buffer.clear();\n            } while (true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n```\n\n\n\n### 2.1  ByteBuffer 正确使用姿势\n\n1. 向 buffer 写入数据，例如调用 channel.read(buffer)\n2. 调用 flip() 切换至**读模式**\n3. 从 buffer 读取数据，例如调用 buffer.get()\n4. 调用 clear() 或 compact() 切换至**写模式**\n5. 重复 1~4 步骤\n\n\n\n### 2.2 ByteBuffer 结构\n\nByteBuffer 有以下重要属性\n\n* capacity\n* position\n* limit\n\n一开始\n\n![](img/0021.png)\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![](img/0018.png)\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n![](img/0019.png)\n\n读取 4 个字节后，状态\n\n![](img/0020.png)\n\nclear 动作发生后，状态\n\n![](img/0021.png)\n\ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n![](img/0022.png)\n\n\n\n#### 💡 调试工具类\n\n```java\npublic class ByteBufferUtil {\n    private static final char[] BYTE2CHAR = new char[256];\n    private static final char[] HEXDUMP_TABLE = new char[256 * 4];\n    private static final String[] HEXPADDING = new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];\n    private static final String[] BYTE2HEX = new String[256];\n    private static final String[] BYTEPADDING = new String[16];\n\n    static {\n        final char[] DIGITS = \"0123456789abcdef\".toCharArray();\n        for (int i = 0; i < 256; i++) {\n            HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F];\n            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];\n        }\n\n        int i;\n\n        // Generate the lookup table for hex dump paddings\n        for (i = 0; i < HEXPADDING.length; i++) {\n            int padding = HEXPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding * 3);\n            for (int j = 0; j < padding; j++) {\n                buf.append(\"   \");\n            }\n            HEXPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) {\n            StringBuilder buf = new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, '|');\n            buf.append('|');\n            HEXDUMP_ROWPREFIXES[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-hex-dump conversion\n        for (i = 0; i < BYTE2HEX.length; i++) {\n            BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);\n        }\n\n        // Generate the lookup table for byte dump paddings\n        for (i = 0; i < BYTEPADDING.length; i++) {\n            int padding = BYTEPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding);\n            for (int j = 0; j < padding; j++) {\n                buf.append(' ');\n            }\n            BYTEPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-char conversion\n        for (i = 0; i < BYTE2CHAR.length; i++) {\n            if (i <= 0x1f || i >= 0x7f) {\n                BYTE2CHAR[i] = '.';\n            } else {\n                BYTE2CHAR[i] = (char) i;\n            }\n        }\n    }\n\n    /**\n     * 打印所有内容\n     * @param buffer\n     */\n    public static void debugAll(ByteBuffer buffer) {\n        int oldlimit = buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin = new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println(\"+--------+-------------------- all ------------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    }\n\n    /**\n     * 打印可读取内容\n     * @param buffer\n     */\n    public static void debugRead(ByteBuffer buffer) {\n        StringBuilder builder = new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println(\"+--------+-------------------- read -----------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), buffer.limit());\n        System.out.println(builder);\n    }\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) {\n        if (isOutOfBounds(offset, length, buf.capacity())) {\n            throw new IndexOutOfBoundsException(\n                    \"expected: \" + \"0 <= offset(\" + offset + \") <= offset + length(\" + length\n                            + \") <= \" + \"buf.capacity(\" + buf.capacity() + ')');\n        }\n        if (length == 0) {\n            return;\n        }\n        dump.append(\n                \"         +-------------------------------------------------+\" +\n                        NEWLINE + \"         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\" +\n                        NEWLINE + \"+--------+-------------------------------------------------+----------------+\");\n\n        final int startIndex = offset;\n        final int fullRows = length >>> 4;\n        final int remainder = length & 0xF;\n\n        // Dump the rows which have 16 bytes.\n        for (int row = 0; row < fullRows; row++) {\n            int rowStartIndex = (row << 4) + startIndex;\n\n            // Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + 16;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(\" |\");\n\n            // ASCII dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append('|');\n        }\n\n        // Dump the last row which has less than 16 bytes.\n        if (remainder != 0) {\n            int rowStartIndex = (fullRows << 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + remainder;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(HEXPADDING[remainder]);\n            dump.append(\" |\");\n\n            // Ascii dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(BYTEPADDING[remainder]);\n            dump.append('|');\n        }\n\n        dump.append(NEWLINE +\n                \"+--------+-------------------------------------------------+----------------+\");\n    }\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {\n        if (row < HEXDUMP_ROWPREFIXES.length) {\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        } else {\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, '|');\n            dump.append('|');\n        }\n    }\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) {\n        return (short) (buffer.get(index) & 0xFF);\n    }\n}\n```\n\n\n\n### 2.3 ByteBuffer 常见方法\n\n#### 分配空间\n\n可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\n\n```java\nBytebuffer buf = ByteBuffer.allocate(16);\n```\n\n\n\n#### 向 buffer 写入数据\n\n有两种办法\n\n* 调用 channel 的 read 方法\n* 调用 buffer 自己的 put 方法\n\n```java\nint readBytes = channel.read(buf);\n```\n\n和\n\n```java\nbuf.put((byte)127);\n```\n\n\n\n#### 从 buffer 读取数据\n\n同样有两种办法\n\n* 调用 channel 的 write 方法\n* 调用 buffer 自己的 get 方法\n\n```java\nint writeBytes = channel.write(buf);\n```\n\n和\n\n```java\nbyte b = buf.get();\n```\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n* 可以调用 rewind 方法将 position 重新置为 0\n* 或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\n\n\n#### mark 和 reset\n\nmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n> **注意**\n>\n> rewind 和 flip 都会清除 mark 位置\n\n\n\n#### 字符串与 ByteBuffer 互转\n\n```java\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\"你好\");\nByteBuffer buffer2 = Charset.forName(\"utf-8\").encode(\"你好\");\n\ndebug(buffer1);\ndebug(buffer2);\n\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());\nSystem.out.println(buffer3.toString());\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好\n```\n\n\n\n#### ⚠️ Buffer 的线程安全\n\n> Buffer 是**非线程安全的**\n\n\n\n### 2.4 Scattering Reads\n\n分散读取，有一个文本文件 3parts.txt\n\n```\nonetwothree\n```\n\n使用如下方式读取，可以将数据填充至多个 buffer\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer a = ByteBuffer.allocate(3);\n    ByteBuffer b = ByteBuffer.allocate(3);\n    ByteBuffer c = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]{a, b, c});\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n### 2.5 Gathering Writes\n\n使用如下方式写入，可以将多个 buffer 的数据填充至 channel\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer d = ByteBuffer.allocate(4);\n    ByteBuffer e = ByteBuffer.allocate(4);\n    channel.position(11);\n\n    d.put(new byte[]{'f', 'o', 'u', 'r'});\n    e.put(new byte[]{'f', 'i', 'v', 'e'});\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]{d, e});\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+\n```\n\n文件内容\n\n```\nonetwothreefourfive\n```\n\n\n\n### 2.6 练习\n\n网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\n* Hello,world\\n\n* I'm zhangsan\\n\n* How are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\n* Hello,world\\nI'm zhangsan\\nHo\n* w are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\n\n```java\npublic static void main(String[] args) {\n    ByteBuffer source = ByteBuffer.allocate(32);\n    //                     11            24\n    source.put(\"Hello,world\\nI'm zhangsan\\nHo\".getBytes());\n    split(source);\n\n    source.put(\"w are you?\\nhaha!\\n\".getBytes());\n    split(source);\n}\n\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    int oldLimit = source.limit();\n    for (int i = 0; i < oldLimit; i++) {\n        if (source.get(i) == '\\n') {\n            System.out.println(i);\n            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());\n            // 0 ~ limit\n            source.limit(i + 1);\n            target.put(source); // 从source 读，向 target 写\n            debugAll(target);\n            source.limit(oldLimit);\n        }\n    }\n    source.compact();\n}\n```\n\n\n\n## 3. 文件编程\n\n### 3.1 FileChannel\n\n#### ⚠️ FileChannel 工作模式\n\n> FileChannel 只能工作在阻塞模式下\n\n\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n* 通过 FileInputStream 获取的 channel 只能读\n* 通过 FileOutputStream 获取的 channel 只能写\n* 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n* 这时读取会返回 -1 \n* 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n\n\n#### 强制写入\n\n操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n\n\n\n### 3.2 两个 Channel 传输数据\n\n```java\nString FROM = \"helloword/data.txt\";\nString TO = \"helloword/to.txt\";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println(\"transferTo 用时：\" + (end - start) / 1000_000.0);\n```\n\n输出\n\n```\ntransferTo 用时：8.2011\n```\n\n\n\n超过 2g 大小的文件传输\n\n```java\npublic class TestFileChannelTransferTo {\n    public static void main(String[] args) {\n        try (\n                FileChannel from = new FileInputStream(\"data.txt\").getChannel();\n                FileChannel to = new FileOutputStream(\"to.txt\").getChannel();\n        ) {\n            // 效率高，底层会利用操作系统的零拷贝进行优化\n            long size = from.size();\n            // left 变量代表还剩余多少字节\n            for (long left = size; left > 0; ) {\n                System.out.println(\"position:\" + (size - left) + \" left:\" + left);\n                left -= from.transferTo((size - left), left, to);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n实际传输一个超大文件\n\n```\nposition:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219\n```\n\n\n\n### 3.3 Path\n\njdk7 引入了 Path 和 Paths 类\n\n* Path 用来表示文件路径\n* Paths 是工具类，用来获取 Path 实例\n\n```java\nPath source = Paths.get(\"1.txt\"); // 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source = Paths.get(\"d:\\\\1.txt\"); // 绝对路径 代表了  d:\\1.txt\n\nPath source = Paths.get(\"d:/1.txt\"); // 绝对路径 同样代表了  d:\\1.txt\n\nPath projects = Paths.get(\"d:\\\\data\", \"projects\"); // 代表了  d:\\data\\projects\n```\n\n* `.` 代表了当前路径\n* `..` 代表了上一级路径\n\n例如目录结构如下\n\n```\nd:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b\n```\n\n代码\n\n```java\nPath path = Paths.get(\"d:\\\\data\\\\projects\\\\a\\\\..\\\\b\");\nSystem.out.println(path);\nSystem.out.println(path.normalize()); // 正常化路径\n```\n\n会输出\n\n```\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n```\n\n\n\n### 3.4 Files\n\n检查文件是否存在\n\n```java\nPath path = Paths.get(\"helloword/data.txt\");\nSystem.out.println(Files.exists(path));\n```\n\n\n\n创建一级目录\n\n```java\nPath path = Paths.get(\"helloword/d1\");\nFiles.createDirectory(path);\n```\n\n* 如果目录已存在，会抛异常 FileAlreadyExistsException\n* 不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n\n\n创建多级目录用\n\n```java\nPath path = Paths.get(\"helloword/d1/d2\");\nFiles.createDirectories(path);\n```\n\n\n\n拷贝文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.copy(source, target);\n```\n\n* 如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\n\n```java\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n```\n\n\n\n移动文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/data.txt\");\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n```\n\n* StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n\n\n删除文件\n\n```java\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.delete(target);\n```\n\n* 如果文件不存在，会抛异常 NoSuchFileException\n\n\n\n删除目录\n\n```java\nPath target = Paths.get(\"helloword/d1\");\n\nFiles.delete(target);\n```\n\n* 如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\n\n\n遍历目录文件\n\n```java\npublic static void main(String[] args) throws IOException {\n    Path path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\n    AtomicInteger dirCount = new AtomicInteger();\n    AtomicInteger fileCount = new AtomicInteger();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(dir);\n            dirCount.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(file);\n            fileCount.incrementAndGet();\n            return super.visitFile(file, attrs);\n        }\n    });\n    System.out.println(dirCount); // 133\n    System.out.println(fileCount); // 1479\n}\n```\n\n\n\n统计 jar 的数目\n\n```java\nPath path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\nAtomicInteger fileCount = new AtomicInteger();\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        if (file.toFile().getName().endsWith(\".jar\")) {\n            fileCount.incrementAndGet();\n        }\n        return super.visitFile(file, attrs);\n    }\n});\nSystem.out.println(fileCount); // 724\n```\n\n\n\n删除多级目录\n\n```java\nPath path = Paths.get(\"d:\\\\a\");\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        Files.delete(file);\n        return super.visitFile(file, attrs);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) \n        throws IOException {\n        Files.delete(dir);\n        return super.postVisitDirectory(dir, exc);\n    }\n});\n```\n\n\n\n#### ⚠️ 删除很危险\n\n> 删除是危险操作，确保要递归删除的文件夹没有重要内容\n\n\n\n拷贝多级目录\n\n```java\nlong start = System.currentTimeMillis();\nString source = \"D:\\\\Snipaste-1.16.2-x64\";\nString target = \"D:\\\\Snipaste-1.16.2-x64aaa\";\n\nFiles.walk(Paths.get(source)).forEach(path -> {\n    try {\n        String targetName = path.toString().replace(source, target);\n        // 是目录\n        if (Files.isDirectory(path)) {\n            Files.createDirectory(Paths.get(targetName));\n        }\n        // 是普通文件\n        else if (Files.isRegularFile(path)) {\n            Files.copy(path, Paths.get(targetName));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlong end = System.currentTimeMillis();\nSystem.out.println(end - start);\n```\n\n\n\n\n\n## 4. 网络编程\n\n### 4.1 非阻塞 vs 阻塞\n\n#### 阻塞\n\n* 阻塞模式下，相关方法都会导致线程暂停\n  * ServerSocketChannel.accept 会在没有连接建立时让线程暂停\n  * SocketChannel.read 会在没有数据可读时让线程暂停\n  * 阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n* 单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n* 但多线程下，有新的问题，体现在以下方面\n  * 32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n  * 可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n\n\n服务器端\n\n```java\n// 使用 nio 来理解阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\n\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug(\"connecting...\");\n    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行\n    log.debug(\"connected... {}\", sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        log.debug(\"before read... {}\", channel);\n        channel.read(buffer); // 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug(\"after read...{}\", channel);\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSystem.out.println(\"waiting...\");\n```\n\n\n\n#### 非阻塞\n\n* 非阻塞模式下，相关方法都会不会让线程暂停\n  * 在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\n  * SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept \n  * 写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n* 但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\n* 数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\n\n\n\n服务器端，客户端代码不变\n\n```java\n// 使用 nio 来理解非阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false); // 非阻塞模式\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc != null) {\n        log.debug(\"connected... {}\", sc);\n        sc.configureBlocking(false); // 非阻塞模式\n        channels.add(sc);\n    }\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read > 0) {\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug(\"after read...{}\", channel);\n        }\n    }\n}\n```\n\n\n\n#### 多路复用\n\n单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\n\n* 多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\n* 如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n  * 有可连接事件时才去连接\n  * 有可读事件才去读取\n  * 有可写事件才去写入\n    * 限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n### 4.2 Selector\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --> selector\nselector --> c1(channel)\nselector --> c2(channel)\nselector --> c3(channel)\nend\n```\n\n\n\n好处\n\n* 一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n* 让这个线程能够被充分利用\n* 节约了线程的数量\n* 减少了线程上下文切换\n\n\n\n#### 创建\n\n```java\nSelector selector = Selector.open();\n```\n\n\n\n#### 绑定 Channel 事件\n\n也称之为注册事件，绑定的事件 selector 才会关心 \n\n```java\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, 绑定事件);\n```\n\n* channel 必须工作在非阻塞模式\n* FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n* 绑定的事件类型可以有\n  * connect - 客户端连接成功时触发\n  * accept - 服务器端成功接受连接时触发\n  * read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\n  * write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n\n\n#### 监听 Channel 事件\n\n可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n\n方法1，阻塞直到绑定事件发生\n\n```java\nint count = selector.select();\n```\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\n\n```java\nint count = selector.select(long timeout);\n```\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\n\n```java\nint count = selector.selectNow();\n```\n\n\n\n#### 💡 select 何时不阻塞\n\n> * 事件发生时\n>   * 客户端发起连接请求，会触发 accept 事件\n>   * 客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\n>   * channel 可写，会触发 write 事件\n>   * 在 linux 下 nio bug 发生时\n> * 调用 selector.wakeup()\n> * 调用 selector.close()\n> * selector 所在线程 interrupt\n\n\n\n### 4.3 处理 accept 事件\n\n客户端代码为\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket(\"localhost\", 8080)) {\n            System.out.println(socket);\n            socket.getOutputStream().write(\"world\".getBytes());\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n服务器端代码为\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        log.debug(\"{}\", sc);\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n#### 💡 事件发生后能否不处理\n\n> 事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n\n\n### 4.4 处理 read 事件\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug(\"连接已建立: {}\", sc);\n                    } else if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(128);\n                        int read = sc.read(buffer);\n                        if(read == -1) {\n                            key.cancel();\n                            sc.close();\n                        } else {\n                            buffer.flip();\n                            debug(buffer);\n                        }\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n开启两个客户端，修改一下发送文字，输出\n\n```\nsun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 为何要 iter.remove()\n\n> 因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n>\n> * 第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n> * 第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n\n\n#### 💡 cancel 的作用\n\n> cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\n\n\n\n#### ⚠️  不处理边界的问题\n\n以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss=new ServerSocket(9000);\n        while (true) {\n            Socket s = ss.accept();\n            InputStream in = s.getInputStream();\n            // 这里这么写，有没有问题\n            byte[] arr = new byte[4];\n            while(true) {\n                int read = in.read(arr);\n                // 这里这么写，有没有问题\n                if(read == -1) {\n                    break;\n                }\n                System.out.println(new String(arr, 0, read));\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket max = new Socket(\"localhost\", 9000);\n        OutputStream out = max.getOutputStream();\n        out.write(\"hello\".getBytes());\n        out.write(\"world\".getBytes());\n        out.write(\"你好\".getBytes());\n        max.close();\n    }\n}\n```\n\n输出\n\n```\nhell\nowor\nld�\n�好\n\n```\n\n为什么？\n\n\n\n#### 处理消息的边界\n\n![](img/0023.png)\n\n* 一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n* 另一种思路是按分隔符拆分，缺点是效率低\n* TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\n  * Http 1.1 是 TLV 格式\n  * Http 2.0 是 LTV 格式\n\n\n\n```mermaid\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 ->> s: 发送 01234567890abcdef3333\\r\ns ->> b1: 第一次 read 存入 01234567890abcdef\ns ->> b2: 扩容\nb1 ->> b2: 拷贝 01234567890abcdef\ns ->> b2: 第二次 read 存入 3333\\r\nb2 ->> b2: 01234567890abcdef3333\\r\n```\n\n服务器端\n\n```java\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    for (int i = 0; i < source.limit(); i++) {\n        // 找到一条完整消息\n        if (source.get(i) == '\\n') {\n            int length = i + 1 - source.position();\n            // 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            // 从 source 读，向 target 写\n            for (int j = 0; j < length; j++) {\n                target.put(source.get());\n            }\n            debugAll(target);\n        }\n    }\n    source.compact(); // 0123456789abcdef  position 16 limit 16\n}\n\npublic static void main(String[] args) throws IOException {\n    // 1. 创建 selector, 管理多个 channel\n    Selector selector = Selector.open();\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    // 2. 建立 selector 和 channel 的联系（注册）\n    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    // key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug(\"sscKey:{}\", sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) {\n        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug(\"key: {}\", key);\n            // 5. 区分事件类型\n            if (key.isAcceptable()) { // 如果是 accept\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment\n                // 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug(\"{}\", sc);\n                log.debug(\"scKey:{}\", scKey);\n            } else if (key.isReadable()) { // 如果是 read\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel\n                    // 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1\n                    if(read == -1) {\n                        key.cancel();\n                    } else {\n                        split(buffer);\n                        // 需要扩容\n                        if (buffer.position() == buffer.limit()) {\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); // 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        }\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSocketAddress address = sc.getLocalAddress();\n// sc.write(Charset.defaultCharset().encode(\"hello\\nworld\\n\"));\nsc.write(Charset.defaultCharset().encode(\"0123\\n456789abcdef\"));\nsc.write(Charset.defaultCharset().encode(\"0123456789abcdef3333\\n\"));\nSystem.in.read();\n```\n\n\n\n\n\n#### ByteBuffer 大小分配\n\n* 每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\n* ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n  * 一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 [http://tutorials.jenkov.com/java-performance/resizable-array.html](http://tutorials.jenkov.com/java-performance/resizable-array.html)\n  * 另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\n\n\n\n\n\n### 4.5 处理 write 事件\n\n\n\n#### 一次无法写完例子\n\n* 非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n* 用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n  * 当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\n  * selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n  * 如果不取消，会每次可写均会触发 write 事件\n\n\n\n```java\npublic class WriteServer {\n\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector = Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) {\n            selector.select();\n\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    SocketChannel sc = ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);\n                    // 1. 向客户端发送内容\n                    StringBuilder sb = new StringBuilder();\n                    for (int i = 0; i < 3000000; i++) {\n                        sb.append(\"a\");\n                    }\n                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());\n                    int write = sc.write(buffer);\n                    // 3. write 表示实际写了多少字节\n                    System.out.println(\"实际写入字节:\" + write);\n                    // 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) {\n                        // read 1  write 4\n                        // 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        // 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    }\n                } else if (key.isWritable()) {\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    int write = sc.write(buffer);\n                    System.out.println(\"实际写入字节:\" + write);\n                    if (!buffer.hasRemaining()) { // 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class WriteClient {\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        SocketChannel sc = SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress(\"localhost\", 8080));\n        int count = 0;\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isConnectable()) {\n                    System.out.println(sc.finishConnect());\n                } else if (key.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);\n                    count += sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 write 为何要取消\n\n只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\n\n\n\n\n\n\n\n\n\n\n\n### 4.6 更进一步\n\n\n\n#### 💡 利用多线程优化\n\n> 现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n\n\n\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n\n分两组选择器\n\n* 单线程配一个选择器，专门处理 accept 事件\n* 创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件\n\n\n\n```java\npublic class ChannelDemo7 {\n    public static void main(String[] args) throws IOException {\n        new BossEventLoop().register();\n    }\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable {\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start = false;\n        AtomicInteger index = new AtomicInteger();\n\n        public void register() throws IOException {\n            if (!start) {\n                ServerSocketChannel ssc = ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss = Selector.open();\n                SelectionKey ssckey = ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers = initEventLoops();\n                new Thread(this, \"boss\").start();\n                log.debug(\"boss start...\");\n                start = true;\n            }\n        }\n\n        public WorkerEventLoop[] initEventLoops() {\n//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];\n            for (int i = 0; i < workerEventLoops.length; i++) {\n                workerEventLoops[i] = new WorkerEventLoop(i);\n            }\n            return workerEventLoops;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    boss.select();\n                    Iterator<SelectionKey> iter = boss.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                            SocketChannel sc = c.accept();\n                            sc.configureBlocking(false);\n                            log.debug(\"{} connected\", sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable {\n        private Selector worker;\n        private volatile boolean start = false;\n        private int index;\n\n        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();\n\n        public WorkerEventLoop(int index) {\n            this.index = index;\n        }\n\n        public void register(SocketChannel sc) throws IOException {\n            if (!start) {\n                worker = Selector.open();\n                new Thread(this, \"worker-\" + index).start();\n                start = true;\n            }\n            tasks.add(() -> {\n                try {\n                    SelectionKey sckey = sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            worker.wakeup();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    worker.select();\n                    Runnable task = tasks.poll();\n                    if (task != null) {\n                        task.run();\n                    }\n                    Set<SelectionKey> keys = worker.selectedKeys();\n                    Iterator<SelectionKey> iter = keys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(128);\n                            try {\n                                int read = sc.read(buffer);\n                                if (read == -1) {\n                                    key.cancel();\n                                    sc.close();\n                                } else {\n                                    buffer.flip();\n                                    log.debug(\"{} message:\", sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            }\n                        }\n                        iter.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 如何拿到 cpu 个数\n\n> * Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\n> * 这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\n\n\n### 4.7 UDP\n\n* UDP 是无连接的，client 发送数据不会管 server 是否开启\n* server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\n\n首先启动服务器端\n\n```java\npublic class UdpServer {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            channel.socket().bind(new InetSocketAddress(9999));\n            System.out.println(\"waiting...\");\n            ByteBuffer buffer = ByteBuffer.allocate(32);\n            channel.receive(buffer);\n            buffer.flip();\n            debug(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\nwaiting...\n```\n\n\n\n运行客户端\n\n```java\npublic class UdpClient {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            ByteBuffer buffer = StandardCharsets.UTF_8.encode(\"hello\");\n            InetSocketAddress address = new InetSocketAddress(\"localhost\", 9999);\n            channel.send(buffer, address);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n接下来服务器端输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n\n\n## 5. NIO vs BIO\n\n### 5.1 stream vs channel\n\n* stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\n* stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n* 二者均为全双工，即读写可以同时进行\n\n\n\n### 5.2 IO 模型\n\n同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\n\n* 同步：线程自己去获取结果（一个线程）\n* 异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\n\n\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n* 等待数据阶段\n* 复制数据阶段\n\n![](img/0033.png)\n\n* 阻塞 IO\n\n  ![](img/0039.png)\n\n* 非阻塞  IO\n\n  ![](img/0035.png)\n\n* 多路复用\n\n  ![](img/0038.png)\n\n* 信号驱动\n\n* 异步 IO\n\n  ![](img/0037.png)\n\n* 阻塞 IO vs 多路复用\n\n  ![](img/0034.png)\n\n  ![](img/0036.png)\n\n#### 🔖 参考\n\nUNIX 网络编程 - 卷 I\n\n\n\n### 5.3 零拷贝\n\n#### 传统 IO 问题\n\n传统的 IO 将一个文件通过 socket 写出\n\n```java\nFile f = new File(\"helloword/data.txt\");\nRandomAccessFile file = new RandomAccessFile(file, \"r\");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);\n```\n\n内部工作流程是这样的：\n\n![](img/0024.png)\n\n1. java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的**用户态**切换至**内核态**，去调用操作系统（Kernel）的读能力，将数据读入**内核缓冲区**。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\n\n   > DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n2. 从**内核态**切换回**用户态**，将数据从**内核缓冲区**读入**用户缓冲区**（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n\n3. 调用 write 方法，这时将数据从**用户缓冲区**（byte[] buf）写入 **socket 缓冲区**，cpu 会参与拷贝\n\n4. 接下来要向网卡写数据，这项能力 java 又不具备，因此又得从**用户态**切换至**内核态**，调用操作系统的写能力，使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n* 用户态与内核态的切换发生了 3 次，这个操作比较重量级\n* 数据拷贝了共 4 次\n\n\n\n#### NIO 优化\n\n通过 DirectByteBuf \n\n* ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存\n* ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n![](img/0025.png)\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\n\n* 这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\n* java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\n  * DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\n  * 通过专门线程访问引用队列，根据虚引用释放堆外内存\n* 减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n\n\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\n\n![](img/0026.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 数据从**内核缓冲区**传输到 **socket 缓冲区**，cpu 会参与拷贝\n3. 最后使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n可以看到\n\n* 只发生了一次用户态与内核态的切换\n* 数据拷贝了 3 次\n\n\n\n进一步优化（linux 2.4）\n\n![](img/0027.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 只会将一些 offset 和 length 信息拷入 **socket 缓冲区**，几乎无消耗\n3. 使用 DMA 将 **内核缓冲区**的数据写入网卡，不会使用 cpu\n\n整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\n\n* 更少的用户态与内核态的切换\n* 不利用 cpu 计算，减少 cpu 缓存伪共享\n* 零拷贝适合小文件传输\n\n\n\n### 5.3 AIO\n\nAIO 用来解决数据复制阶段的阻塞问题\n\n* 同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n* 异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n> 异步模型需要底层操作系统（Kernel）提供支持\n>\n> * Windows 系统通过 IOCP 实现了真正的异步 IO\n> * Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n\n\n#### 文件 AIO\n\n先来看看 AsynchronousFileChannel\n\n```java\n@Slf4j\npublic class AioDemo1 {\n    public static void main(String[] args) throws IOException {\n        try{\n            AsynchronousFileChannel s = \n                AsynchronousFileChannel.open(\n                \tPaths.get(\"1.txt\"), StandardOpenOption.READ);\n            ByteBuffer buffer = ByteBuffer.allocate(2);\n            log.debug(\"begin...\");\n            s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    log.debug(\"read completed...{}\", result);\n                    buffer.flip();\n                    debug(buffer);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    log.debug(\"read failed...\");\n                }\n            });\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        log.debug(\"do other things...\");\n        System.in.read();\n    }\n}\n```\n\n输出\n\n```\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n```\n\n可以看到\n\n* 响应文件读取成功的是另一个线程 Thread-5\n* 主线程并没有 IO 操作阻塞\n\n\n\n#### 💡 守护线程\n\n默认文件 AIO 使用的线程都是守护线程，所以最后要执行 `System.in.read()` 以避免守护线程意外结束\n\n\n\n#### 网络 AIO\n\n```java\npublic class AioServer {\n    public static void main(String[] args) throws IOException {\n        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    }\n\n    private static void closeChannel(AsynchronousSocketChannel sc) {\n        try {\n            System.out.printf(\"[%s] %s close\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            try {\n                if (result == -1) {\n                    closeChannel(sc);\n                    return;\n                }\n                System.out.printf(\"[%s] %s read\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            closeChannel(sc);\n            exc.printStackTrace();\n        }\n    }\n\n    private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) {\n                sc.write(attachment);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n            closeChannel(sc);\n        }\n    }\n\n    private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> {\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) {\n            this.ssc = ssc;\n        }\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) {\n            try {\n                System.out.printf(\"[%s] %s connected\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            // 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            // 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode(\"server hello!\"), ByteBuffer.allocate(16), new WriteHandler(sc));\n            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            exc.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n\n","source":"_posts/2023-05-06-Netty01-nio.md","raw":"---\ntitle: Netty01-nio\ndate: 2023-05-06 21:15:53\ntags: \n- Netty\n- programing\n- Java\ncategories: Netty\n---\n\n该笔记是B站黑马的Netty视频的配套笔记1。\n<!-- more -->\n# 一. NIO 基础\n\nnon-blocking io 非阻塞 IO\n\n## 1. 三大组件\n\n### 1.1 Channel & Buffer\n\nchannel 有一点类似于 stream，它就是读写数据的**双向通道**，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层\n\n```mermaid\ngraph LR\nchannel --> buffer\nbuffer --> channel\n```\n\n常见的 Channel 有\n\n* FileChannel\n* DatagramChannel\n* SocketChannel\n* ServerSocketChannel\n\n\n\nbuffer 则用来缓冲读写数据，常见的 buffer 有\n\n* ByteBuffer\n  * MappedByteBuffer\n  * DirectByteBuffer\n  * HeapByteBuffer\n* ShortBuffer\n* IntBuffer\n* LongBuffer\n* FloatBuffer\n* DoubleBuffer\n* CharBuffer\n\n\n\n### 1.2 Selector\n\nselector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途\n\n#### 多线程版设计\n\n```mermaid\ngraph TD\nsubgraph 多线程版\nt1(thread) --> s1(socket1)\nt2(thread) --> s2(socket2)\nt3(thread) --> s3(socket3)\nend\n```\n#### ⚠️ 多线程版缺点\n\n* 内存占用高\n* 线程上下文切换成本高\n* 只适合连接数少的场景\n\n\n\n\n\n\n\n#### 线程池版设计\n\n```mermaid\ngraph TD\nsubgraph 线程池版\nt4(thread) --> s4(socket1)\nt5(thread) --> s5(socket2)\nt4(thread) -.-> s6(socket3)\nt5(thread) -.-> s7(socket4)\nend\n```\n#### ⚠️ 线程池版缺点\n\n* 阻塞模式下，线程仅能处理一个 socket 连接\n* 仅适合短连接场景\n\n\n\n\n\n\n\n\n\n#### selector 版设计\n\nselector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --> selector\nselector --> c1(channel)\nselector --> c2(channel)\nselector --> c3(channel)\nend\n```\n\n\n\n调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理\n\n\n\n\n\n\n\n## 2. ByteBuffer\n\n有一普通文本文件 data.txt，内容为\n\n```\n1234567890abcd\n```\n\n使用 FileChannel 来读取文件内容\n\n```java\n@Slf4j\npublic class ChannelDemo1 {\n    public static void main(String[] args) {\n        try (RandomAccessFile file = new RandomAccessFile(\"helloword/data.txt\", \"rw\")) {\n            FileChannel channel = file.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(10);\n            do {\n                // 向 buffer 写入\n                int len = channel.read(buffer);\n                log.debug(\"读到字节数：{}\", len);\n                if (len == -1) {\n                    break;\n                }\n                // 切换 buffer 读模式\n                buffer.flip();\n                while(buffer.hasRemaining()) {\n                    log.debug(\"{}\", (char)buffer.get());\n                }\n                // 切换 buffer 写模式\n                buffer.clear();\n            } while (true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d\n10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1\n```\n\n\n\n### 2.1  ByteBuffer 正确使用姿势\n\n1. 向 buffer 写入数据，例如调用 channel.read(buffer)\n2. 调用 flip() 切换至**读模式**\n3. 从 buffer 读取数据，例如调用 buffer.get()\n4. 调用 clear() 或 compact() 切换至**写模式**\n5. 重复 1~4 步骤\n\n\n\n### 2.2 ByteBuffer 结构\n\nByteBuffer 有以下重要属性\n\n* capacity\n* position\n* limit\n\n一开始\n\n![](img/0021.png)\n\n写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态\n\n![](img/0018.png)\n\nflip 动作发生后，position 切换为读取位置，limit 切换为读取限制\n\n![](img/0019.png)\n\n读取 4 个字节后，状态\n\n![](img/0020.png)\n\nclear 动作发生后，状态\n\n![](img/0021.png)\n\ncompact 方法，是把未读完的部分向前压缩，然后切换至写模式\n\n![](img/0022.png)\n\n\n\n#### 💡 调试工具类\n\n```java\npublic class ByteBufferUtil {\n    private static final char[] BYTE2CHAR = new char[256];\n    private static final char[] HEXDUMP_TABLE = new char[256 * 4];\n    private static final String[] HEXPADDING = new String[16];\n    private static final String[] HEXDUMP_ROWPREFIXES = new String[65536 >>> 4];\n    private static final String[] BYTE2HEX = new String[256];\n    private static final String[] BYTEPADDING = new String[16];\n\n    static {\n        final char[] DIGITS = \"0123456789abcdef\".toCharArray();\n        for (int i = 0; i < 256; i++) {\n            HEXDUMP_TABLE[i << 1] = DIGITS[i >>> 4 & 0x0F];\n            HEXDUMP_TABLE[(i << 1) + 1] = DIGITS[i & 0x0F];\n        }\n\n        int i;\n\n        // Generate the lookup table for hex dump paddings\n        for (i = 0; i < HEXPADDING.length; i++) {\n            int padding = HEXPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding * 3);\n            for (int j = 0; j < padding; j++) {\n                buf.append(\"   \");\n            }\n            HEXPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for the start-offset header in each row (up to 64KiB).\n        for (i = 0; i < HEXDUMP_ROWPREFIXES.length; i++) {\n            StringBuilder buf = new StringBuilder(12);\n            buf.append(NEWLINE);\n            buf.append(Long.toHexString(i << 4 & 0xFFFFFFFFL | 0x100000000L));\n            buf.setCharAt(buf.length() - 9, '|');\n            buf.append('|');\n            HEXDUMP_ROWPREFIXES[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-hex-dump conversion\n        for (i = 0; i < BYTE2HEX.length; i++) {\n            BYTE2HEX[i] = ' ' + StringUtil.byteToHexStringPadded(i);\n        }\n\n        // Generate the lookup table for byte dump paddings\n        for (i = 0; i < BYTEPADDING.length; i++) {\n            int padding = BYTEPADDING.length - i;\n            StringBuilder buf = new StringBuilder(padding);\n            for (int j = 0; j < padding; j++) {\n                buf.append(' ');\n            }\n            BYTEPADDING[i] = buf.toString();\n        }\n\n        // Generate the lookup table for byte-to-char conversion\n        for (i = 0; i < BYTE2CHAR.length; i++) {\n            if (i <= 0x1f || i >= 0x7f) {\n                BYTE2CHAR[i] = '.';\n            } else {\n                BYTE2CHAR[i] = (char) i;\n            }\n        }\n    }\n\n    /**\n     * 打印所有内容\n     * @param buffer\n     */\n    public static void debugAll(ByteBuffer buffer) {\n        int oldlimit = buffer.limit();\n        buffer.limit(buffer.capacity());\n        StringBuilder origin = new StringBuilder(256);\n        appendPrettyHexDump(origin, buffer, 0, buffer.capacity());\n        System.out.println(\"+--------+-------------------- all ------------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), oldlimit);\n        System.out.println(origin);\n        buffer.limit(oldlimit);\n    }\n\n    /**\n     * 打印可读取内容\n     * @param buffer\n     */\n    public static void debugRead(ByteBuffer buffer) {\n        StringBuilder builder = new StringBuilder(256);\n        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());\n        System.out.println(\"+--------+-------------------- read -----------------------+----------------+\");\n        System.out.printf(\"position: [%d], limit: [%d]\\n\", buffer.position(), buffer.limit());\n        System.out.println(builder);\n    }\n\n    private static void appendPrettyHexDump(StringBuilder dump, ByteBuffer buf, int offset, int length) {\n        if (isOutOfBounds(offset, length, buf.capacity())) {\n            throw new IndexOutOfBoundsException(\n                    \"expected: \" + \"0 <= offset(\" + offset + \") <= offset + length(\" + length\n                            + \") <= \" + \"buf.capacity(\" + buf.capacity() + ')');\n        }\n        if (length == 0) {\n            return;\n        }\n        dump.append(\n                \"         +-------------------------------------------------+\" +\n                        NEWLINE + \"         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\" +\n                        NEWLINE + \"+--------+-------------------------------------------------+----------------+\");\n\n        final int startIndex = offset;\n        final int fullRows = length >>> 4;\n        final int remainder = length & 0xF;\n\n        // Dump the rows which have 16 bytes.\n        for (int row = 0; row < fullRows; row++) {\n            int rowStartIndex = (row << 4) + startIndex;\n\n            // Per-row prefix.\n            appendHexDumpRowPrefix(dump, row, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + 16;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(\" |\");\n\n            // ASCII dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append('|');\n        }\n\n        // Dump the last row which has less than 16 bytes.\n        if (remainder != 0) {\n            int rowStartIndex = (fullRows << 4) + startIndex;\n            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);\n\n            // Hex dump\n            int rowEndIndex = rowStartIndex + remainder;\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);\n            }\n            dump.append(HEXPADDING[remainder]);\n            dump.append(\" |\");\n\n            // Ascii dump\n            for (int j = rowStartIndex; j < rowEndIndex; j++) {\n                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);\n            }\n            dump.append(BYTEPADDING[remainder]);\n            dump.append('|');\n        }\n\n        dump.append(NEWLINE +\n                \"+--------+-------------------------------------------------+----------------+\");\n    }\n\n    private static void appendHexDumpRowPrefix(StringBuilder dump, int row, int rowStartIndex) {\n        if (row < HEXDUMP_ROWPREFIXES.length) {\n            dump.append(HEXDUMP_ROWPREFIXES[row]);\n        } else {\n            dump.append(NEWLINE);\n            dump.append(Long.toHexString(rowStartIndex & 0xFFFFFFFFL | 0x100000000L));\n            dump.setCharAt(dump.length() - 9, '|');\n            dump.append('|');\n        }\n    }\n\n    public static short getUnsignedByte(ByteBuffer buffer, int index) {\n        return (short) (buffer.get(index) & 0xFF);\n    }\n}\n```\n\n\n\n### 2.3 ByteBuffer 常见方法\n\n#### 分配空间\n\n可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法\n\n```java\nBytebuffer buf = ByteBuffer.allocate(16);\n```\n\n\n\n#### 向 buffer 写入数据\n\n有两种办法\n\n* 调用 channel 的 read 方法\n* 调用 buffer 自己的 put 方法\n\n```java\nint readBytes = channel.read(buf);\n```\n\n和\n\n```java\nbuf.put((byte)127);\n```\n\n\n\n#### 从 buffer 读取数据\n\n同样有两种办法\n\n* 调用 channel 的 write 方法\n* 调用 buffer 自己的 get 方法\n\n```java\nint writeBytes = channel.write(buf);\n```\n\n和\n\n```java\nbyte b = buf.get();\n```\n\nget 方法会让 position 读指针向后走，如果想重复读取数据\n\n* 可以调用 rewind 方法将 position 重新置为 0\n* 或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针\n\n\n\n#### mark 和 reset\n\nmark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置\n\n> **注意**\n>\n> rewind 和 flip 都会清除 mark 位置\n\n\n\n#### 字符串与 ByteBuffer 互转\n\n```java\nByteBuffer buffer1 = StandardCharsets.UTF_8.encode(\"你好\");\nByteBuffer buffer2 = Charset.forName(\"utf-8\").encode(\"你好\");\n\ndebug(buffer1);\ndebug(buffer2);\n\nCharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);\nSystem.out.println(buffer3.getClass());\nSystem.out.println(buffer3.toString());\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| e4 bd a0 e5 a5 bd                               |......          |\n+--------+-------------------------------------------------+----------------+\nclass java.nio.HeapCharBuffer\n你好\n```\n\n\n\n#### ⚠️ Buffer 的线程安全\n\n> Buffer 是**非线程安全的**\n\n\n\n### 2.4 Scattering Reads\n\n分散读取，有一个文本文件 3parts.txt\n\n```\nonetwothree\n```\n\n使用如下方式读取，可以将数据填充至多个 buffer\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer a = ByteBuffer.allocate(3);\n    ByteBuffer b = ByteBuffer.allocate(3);\n    ByteBuffer c = ByteBuffer.allocate(5);\n    channel.read(new ByteBuffer[]{a, b, c});\n    a.flip();\n    b.flip();\n    c.flip();\n    debug(a);\n    debug(b);\n    debug(c);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6f 6e 65                                        |one             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 77 6f                                        |two             |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 74 68 72 65 65                                  |three           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n### 2.5 Gathering Writes\n\n使用如下方式写入，可以将多个 buffer 的数据填充至 channel\n\n```java\ntry (RandomAccessFile file = new RandomAccessFile(\"helloword/3parts.txt\", \"rw\")) {\n    FileChannel channel = file.getChannel();\n    ByteBuffer d = ByteBuffer.allocate(4);\n    ByteBuffer e = ByteBuffer.allocate(4);\n    channel.position(11);\n\n    d.put(new byte[]{'f', 'o', 'u', 'r'});\n    e.put(new byte[]{'f', 'i', 'v', 'e'});\n    d.flip();\n    e.flip();\n    debug(d);\n    debug(e);\n    channel.write(new ByteBuffer[]{d, e});\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 6f 75 72                                     |four            |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 69 76 65                                     |five            |\n+--------+-------------------------------------------------+----------------+\n```\n\n文件内容\n\n```\nonetwothreefourfive\n```\n\n\n\n### 2.6 练习\n\n网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\n* Hello,world\\n\n* I'm zhangsan\\n\n* How are you?\\n\n\n变成了下面的两个 byteBuffer (黏包，半包)\n\n* Hello,world\\nI'm zhangsan\\nHo\n* w are you?\\n\n\n现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据\n\n```java\npublic static void main(String[] args) {\n    ByteBuffer source = ByteBuffer.allocate(32);\n    //                     11            24\n    source.put(\"Hello,world\\nI'm zhangsan\\nHo\".getBytes());\n    split(source);\n\n    source.put(\"w are you?\\nhaha!\\n\".getBytes());\n    split(source);\n}\n\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    int oldLimit = source.limit();\n    for (int i = 0; i < oldLimit; i++) {\n        if (source.get(i) == '\\n') {\n            System.out.println(i);\n            ByteBuffer target = ByteBuffer.allocate(i + 1 - source.position());\n            // 0 ~ limit\n            source.limit(i + 1);\n            target.put(source); // 从source 读，向 target 写\n            debugAll(target);\n            source.limit(oldLimit);\n        }\n    }\n    source.compact();\n}\n```\n\n\n\n## 3. 文件编程\n\n### 3.1 FileChannel\n\n#### ⚠️ FileChannel 工作模式\n\n> FileChannel 只能工作在阻塞模式下\n\n\n\n#### 获取\n\n不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n* 通过 FileInputStream 获取的 channel 只能读\n* 通过 FileOutputStream 获取的 channel 只能写\n* 通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\n\n\n#### 读取\n\n会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾\n\n```java\nint readBytes = channel.read(buffer);\n```\n\n\n\n#### 写入\n\n写入的正确姿势如下， SocketChannel\n\n```java\nByteBuffer buffer = ...;\nbuffer.put(...); // 存入数据\nbuffer.flip();   // 切换读模式\n\nwhile(buffer.hasRemaining()) {\n    channel.write(buffer);\n}\n```\n\n在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel\n\n\n\n#### 关闭\n\nchannel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法\n\n\n\n#### 位置\n\n获取当前位置\n\n```java\nlong pos = channel.position();\n```\n\n设置当前位置\n\n```java\nlong newPos = ...;\nchannel.position(newPos);\n```\n\n设置当前位置时，如果设置为文件的末尾\n\n* 这时读取会返回 -1 \n* 这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\n\n\n#### 大小\n\n使用 size 方法获取文件的大小\n\n\n\n#### 强制写入\n\n操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n\n\n\n### 3.2 两个 Channel 传输数据\n\n```java\nString FROM = \"helloword/data.txt\";\nString TO = \"helloword/to.txt\";\nlong start = System.nanoTime();\ntry (FileChannel from = new FileInputStream(FROM).getChannel();\n     FileChannel to = new FileOutputStream(TO).getChannel();\n    ) {\n    from.transferTo(0, from.size(), to);\n} catch (IOException e) {\n    e.printStackTrace();\n}\nlong end = System.nanoTime();\nSystem.out.println(\"transferTo 用时：\" + (end - start) / 1000_000.0);\n```\n\n输出\n\n```\ntransferTo 用时：8.2011\n```\n\n\n\n超过 2g 大小的文件传输\n\n```java\npublic class TestFileChannelTransferTo {\n    public static void main(String[] args) {\n        try (\n                FileChannel from = new FileInputStream(\"data.txt\").getChannel();\n                FileChannel to = new FileOutputStream(\"to.txt\").getChannel();\n        ) {\n            // 效率高，底层会利用操作系统的零拷贝进行优化\n            long size = from.size();\n            // left 变量代表还剩余多少字节\n            for (long left = size; left > 0; ) {\n                System.out.println(\"position:\" + (size - left) + \" left:\" + left);\n                left -= from.transferTo((size - left), left, to);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n实际传输一个超大文件\n\n```\nposition:0 left:7769948160\nposition:2147483647 left:5622464513\nposition:4294967294 left:3474980866\nposition:6442450941 left:1327497219\n```\n\n\n\n### 3.3 Path\n\njdk7 引入了 Path 和 Paths 类\n\n* Path 用来表示文件路径\n* Paths 是工具类，用来获取 Path 实例\n\n```java\nPath source = Paths.get(\"1.txt\"); // 相对路径 使用 user.dir 环境变量来定位 1.txt\n\nPath source = Paths.get(\"d:\\\\1.txt\"); // 绝对路径 代表了  d:\\1.txt\n\nPath source = Paths.get(\"d:/1.txt\"); // 绝对路径 同样代表了  d:\\1.txt\n\nPath projects = Paths.get(\"d:\\\\data\", \"projects\"); // 代表了  d:\\data\\projects\n```\n\n* `.` 代表了当前路径\n* `..` 代表了上一级路径\n\n例如目录结构如下\n\n```\nd:\n\t|- data\n\t\t|- projects\n\t\t\t|- a\n\t\t\t|- b\n```\n\n代码\n\n```java\nPath path = Paths.get(\"d:\\\\data\\\\projects\\\\a\\\\..\\\\b\");\nSystem.out.println(path);\nSystem.out.println(path.normalize()); // 正常化路径\n```\n\n会输出\n\n```\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n```\n\n\n\n### 3.4 Files\n\n检查文件是否存在\n\n```java\nPath path = Paths.get(\"helloword/data.txt\");\nSystem.out.println(Files.exists(path));\n```\n\n\n\n创建一级目录\n\n```java\nPath path = Paths.get(\"helloword/d1\");\nFiles.createDirectory(path);\n```\n\n* 如果目录已存在，会抛异常 FileAlreadyExistsException\n* 不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n\n\n创建多级目录用\n\n```java\nPath path = Paths.get(\"helloword/d1/d2\");\nFiles.createDirectories(path);\n```\n\n\n\n拷贝文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.copy(source, target);\n```\n\n* 如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\n\n```java\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n```\n\n\n\n移动文件\n\n```java\nPath source = Paths.get(\"helloword/data.txt\");\nPath target = Paths.get(\"helloword/data.txt\");\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n```\n\n* StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\n\n\n删除文件\n\n```java\nPath target = Paths.get(\"helloword/target.txt\");\n\nFiles.delete(target);\n```\n\n* 如果文件不存在，会抛异常 NoSuchFileException\n\n\n\n删除目录\n\n```java\nPath target = Paths.get(\"helloword/d1\");\n\nFiles.delete(target);\n```\n\n* 如果目录还有内容，会抛异常 DirectoryNotEmptyException\n\n\n\n遍历目录文件\n\n```java\npublic static void main(String[] args) throws IOException {\n    Path path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\n    AtomicInteger dirCount = new AtomicInteger();\n    AtomicInteger fileCount = new AtomicInteger();\n    Files.walkFileTree(path, new SimpleFileVisitor<Path>(){\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(dir);\n            dirCount.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        }\n\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n            throws IOException {\n            System.out.println(file);\n            fileCount.incrementAndGet();\n            return super.visitFile(file, attrs);\n        }\n    });\n    System.out.println(dirCount); // 133\n    System.out.println(fileCount); // 1479\n}\n```\n\n\n\n统计 jar 的数目\n\n```java\nPath path = Paths.get(\"C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91\");\nAtomicInteger fileCount = new AtomicInteger();\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        if (file.toFile().getName().endsWith(\".jar\")) {\n            fileCount.incrementAndGet();\n        }\n        return super.visitFile(file, attrs);\n    }\n});\nSystem.out.println(fileCount); // 724\n```\n\n\n\n删除多级目录\n\n```java\nPath path = Paths.get(\"d:\\\\a\");\nFiles.walkFileTree(path, new SimpleFileVisitor<Path>(){\n    @Override\n    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) \n        throws IOException {\n        Files.delete(file);\n        return super.visitFile(file, attrs);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(Path dir, IOException exc) \n        throws IOException {\n        Files.delete(dir);\n        return super.postVisitDirectory(dir, exc);\n    }\n});\n```\n\n\n\n#### ⚠️ 删除很危险\n\n> 删除是危险操作，确保要递归删除的文件夹没有重要内容\n\n\n\n拷贝多级目录\n\n```java\nlong start = System.currentTimeMillis();\nString source = \"D:\\\\Snipaste-1.16.2-x64\";\nString target = \"D:\\\\Snipaste-1.16.2-x64aaa\";\n\nFiles.walk(Paths.get(source)).forEach(path -> {\n    try {\n        String targetName = path.toString().replace(source, target);\n        // 是目录\n        if (Files.isDirectory(path)) {\n            Files.createDirectory(Paths.get(targetName));\n        }\n        // 是普通文件\n        else if (Files.isRegularFile(path)) {\n            Files.copy(path, Paths.get(targetName));\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n});\nlong end = System.currentTimeMillis();\nSystem.out.println(end - start);\n```\n\n\n\n\n\n## 4. 网络编程\n\n### 4.1 非阻塞 vs 阻塞\n\n#### 阻塞\n\n* 阻塞模式下，相关方法都会导致线程暂停\n  * ServerSocketChannel.accept 会在没有连接建立时让线程暂停\n  * SocketChannel.read 会在没有数据可读时让线程暂停\n  * 阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n* 单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n* 但多线程下，有新的问题，体现在以下方面\n  * 32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n  * 可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n\n\n服务器端\n\n```java\n// 使用 nio 来理解阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\n\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    log.debug(\"connecting...\");\n    SocketChannel sc = ssc.accept(); // 阻塞方法，线程停止运行\n    log.debug(\"connected... {}\", sc);\n    channels.add(sc);\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        log.debug(\"before read... {}\", channel);\n        channel.read(buffer); // 阻塞方法，线程停止运行\n        buffer.flip();\n        debugRead(buffer);\n        buffer.clear();\n        log.debug(\"after read...{}\", channel);\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSystem.out.println(\"waiting...\");\n```\n\n\n\n#### 非阻塞\n\n* 非阻塞模式下，相关方法都会不会让线程暂停\n  * 在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行\n  * SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept \n  * 写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去\n* 但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu\n* 数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）\n\n\n\n服务器端，客户端代码不变\n\n```java\n// 使用 nio 来理解非阻塞模式, 单线程\n// 0. ByteBuffer\nByteBuffer buffer = ByteBuffer.allocate(16);\n// 1. 创建了服务器\nServerSocketChannel ssc = ServerSocketChannel.open();\nssc.configureBlocking(false); // 非阻塞模式\n// 2. 绑定监听端口\nssc.bind(new InetSocketAddress(8080));\n// 3. 连接集合\nList<SocketChannel> channels = new ArrayList<>();\nwhile (true) {\n    // 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信\n    SocketChannel sc = ssc.accept(); // 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null\n    if (sc != null) {\n        log.debug(\"connected... {}\", sc);\n        sc.configureBlocking(false); // 非阻塞模式\n        channels.add(sc);\n    }\n    for (SocketChannel channel : channels) {\n        // 5. 接收客户端发送的数据\n        int read = channel.read(buffer);// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0\n        if (read > 0) {\n            buffer.flip();\n            debugRead(buffer);\n            buffer.clear();\n            log.debug(\"after read...{}\", channel);\n        }\n    }\n}\n```\n\n\n\n#### 多路复用\n\n单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\n\n* 多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用\n* 如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n  * 有可连接事件时才去连接\n  * 有可读事件才去读取\n  * 有可写事件才去写入\n    * 限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n### 4.2 Selector\n\n```mermaid\ngraph TD\nsubgraph selector 版\nthread --> selector\nselector --> c1(channel)\nselector --> c2(channel)\nselector --> c3(channel)\nend\n```\n\n\n\n好处\n\n* 一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功\n* 让这个线程能够被充分利用\n* 节约了线程的数量\n* 减少了线程上下文切换\n\n\n\n#### 创建\n\n```java\nSelector selector = Selector.open();\n```\n\n\n\n#### 绑定 Channel 事件\n\n也称之为注册事件，绑定的事件 selector 才会关心 \n\n```java\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, 绑定事件);\n```\n\n* channel 必须工作在非阻塞模式\n* FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n* 绑定的事件类型可以有\n  * connect - 客户端连接成功时触发\n  * accept - 服务器端成功接受连接时触发\n  * read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\n  * write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n\n\n#### 监听 Channel 事件\n\n可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件\n\n方法1，阻塞直到绑定事件发生\n\n```java\nint count = selector.select();\n```\n\n\n\n方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）\n\n```java\nint count = selector.select(long timeout);\n```\n\n\n\n方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\n\n```java\nint count = selector.selectNow();\n```\n\n\n\n#### 💡 select 何时不阻塞\n\n> * 事件发生时\n>   * 客户端发起连接请求，会触发 accept 事件\n>   * 客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件\n>   * channel 可写，会触发 write 事件\n>   * 在 linux 下 nio bug 发生时\n> * 调用 selector.wakeup()\n> * 调用 selector.close()\n> * selector 所在线程 interrupt\n\n\n\n### 4.3 处理 accept 事件\n\n客户端代码为\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        try (Socket socket = new Socket(\"localhost\", 8080)) {\n            System.out.println(socket);\n            socket.getOutputStream().write(\"world\".getBytes());\n            System.in.read();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n服务器端代码为\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        log.debug(\"{}\", sc);\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n#### 💡 事件发生后能否不处理\n\n> 事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n\n\n### 4.4 处理 read 事件\n\n```java\n@Slf4j\npublic class ChannelDemo6 {\n    public static void main(String[] args) {\n        try (ServerSocketChannel channel = ServerSocketChannel.open()) {\n            channel.bind(new InetSocketAddress(8080));\n            System.out.println(channel);\n            Selector selector = Selector.open();\n            channel.configureBlocking(false);\n            channel.register(selector, SelectionKey.OP_ACCEPT);\n\n            while (true) {\n                int count = selector.select();\n//                int count = selector.selectNow();\n                log.debug(\"select count: {}\", count);\n//                if(count <= 0) {\n//                    continue;\n//                }\n\n                // 获取所有事件\n                Set<SelectionKey> keys = selector.selectedKeys();\n\n                // 遍历所有事件，逐一处理\n                Iterator<SelectionKey> iter = keys.iterator();\n                while (iter.hasNext()) {\n                    SelectionKey key = iter.next();\n                    // 判断事件类型\n                    if (key.isAcceptable()) {\n                        ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                        // 必须处理\n                        SocketChannel sc = c.accept();\n                        sc.configureBlocking(false);\n                        sc.register(selector, SelectionKey.OP_READ);\n                        log.debug(\"连接已建立: {}\", sc);\n                    } else if (key.isReadable()) {\n                        SocketChannel sc = (SocketChannel) key.channel();\n                        ByteBuffer buffer = ByteBuffer.allocate(128);\n                        int read = sc.read(buffer);\n                        if(read == -1) {\n                            key.cancel();\n                            sc.close();\n                        } else {\n                            buffer.flip();\n                            debug(buffer);\n                        }\n                    }\n                    // 处理完毕，必须将事件移除\n                    iter.remove();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n开启两个客户端，修改一下发送文字，输出\n\n```\nsun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]\n21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]\n21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 6f 72 6c 64                                  |world           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 为何要 iter.remove()\n\n> 因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如\n>\n> * 第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey \n> * 第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常\n\n\n\n#### 💡 cancel 的作用\n\n> cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件\n\n\n\n#### ⚠️  不处理边界的问题\n\n以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss=new ServerSocket(9000);\n        while (true) {\n            Socket s = ss.accept();\n            InputStream in = s.getInputStream();\n            // 这里这么写，有没有问题\n            byte[] arr = new byte[4];\n            while(true) {\n                int read = in.read(arr);\n                // 这里这么写，有没有问题\n                if(read == -1) {\n                    break;\n                }\n                System.out.println(new String(arr, 0, read));\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket max = new Socket(\"localhost\", 9000);\n        OutputStream out = max.getOutputStream();\n        out.write(\"hello\".getBytes());\n        out.write(\"world\".getBytes());\n        out.write(\"你好\".getBytes());\n        max.close();\n    }\n}\n```\n\n输出\n\n```\nhell\nowor\nld�\n�好\n\n```\n\n为什么？\n\n\n\n#### 处理消息的边界\n\n![](img/0023.png)\n\n* 一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽\n* 另一种思路是按分隔符拆分，缺点是效率低\n* TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\n  * Http 1.1 是 TLV 格式\n  * Http 2.0 是 LTV 格式\n\n\n\n```mermaid\nsequenceDiagram \nparticipant c1 as 客户端1\nparticipant s as 服务器\nparticipant b1 as ByteBuffer1\nparticipant b2 as ByteBuffer2\nc1 ->> s: 发送 01234567890abcdef3333\\r\ns ->> b1: 第一次 read 存入 01234567890abcdef\ns ->> b2: 扩容\nb1 ->> b2: 拷贝 01234567890abcdef\ns ->> b2: 第二次 read 存入 3333\\r\nb2 ->> b2: 01234567890abcdef3333\\r\n```\n\n服务器端\n\n```java\nprivate static void split(ByteBuffer source) {\n    source.flip();\n    for (int i = 0; i < source.limit(); i++) {\n        // 找到一条完整消息\n        if (source.get(i) == '\\n') {\n            int length = i + 1 - source.position();\n            // 把这条完整消息存入新的 ByteBuffer\n            ByteBuffer target = ByteBuffer.allocate(length);\n            // 从 source 读，向 target 写\n            for (int j = 0; j < length; j++) {\n                target.put(source.get());\n            }\n            debugAll(target);\n        }\n    }\n    source.compact(); // 0123456789abcdef  position 16 limit 16\n}\n\npublic static void main(String[] args) throws IOException {\n    // 1. 创建 selector, 管理多个 channel\n    Selector selector = Selector.open();\n    ServerSocketChannel ssc = ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    // 2. 建立 selector 和 channel 的联系（注册）\n    // SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件\n    SelectionKey sscKey = ssc.register(selector, 0, null);\n    // key 只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    log.debug(\"sscKey:{}\", sscKey);\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) {\n        // 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行\n        // select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理\n        selector.select();\n        // 4. 处理事件, selectedKeys 内部包含了所有发生的事件\n        Iterator<SelectionKey> iter = selector.selectedKeys().iterator(); // accept, read\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n            // 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题\n            iter.remove();\n            log.debug(\"key: {}\", key);\n            // 5. 区分事件类型\n            if (key.isAcceptable()) { // 如果是 accept\n                ServerSocketChannel channel = (ServerSocketChannel) key.channel();\n                SocketChannel sc = channel.accept();\n                sc.configureBlocking(false);\n                ByteBuffer buffer = ByteBuffer.allocate(16); // attachment\n                // 将一个 byteBuffer 作为附件关联到 selectionKey 上\n                SelectionKey scKey = sc.register(selector, 0, buffer);\n                scKey.interestOps(SelectionKey.OP_READ);\n                log.debug(\"{}\", sc);\n                log.debug(\"scKey:{}\", scKey);\n            } else if (key.isReadable()) { // 如果是 read\n                try {\n                    SocketChannel channel = (SocketChannel) key.channel(); // 拿到触发事件的channel\n                    // 获取 selectionKey 上关联的附件\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    int read = channel.read(buffer); // 如果是正常断开，read 的方法的返回值是 -1\n                    if(read == -1) {\n                        key.cancel();\n                    } else {\n                        split(buffer);\n                        // 需要扩容\n                        if (buffer.position() == buffer.limit()) {\n                            ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * 2);\n                            buffer.flip();\n                            newBuffer.put(buffer); // 0123456789abcdef3333\\n\n                            key.attach(newBuffer);\n                        }\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    key.cancel();  // 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\nSocketChannel sc = SocketChannel.open();\nsc.connect(new InetSocketAddress(\"localhost\", 8080));\nSocketAddress address = sc.getLocalAddress();\n// sc.write(Charset.defaultCharset().encode(\"hello\\nworld\\n\"));\nsc.write(Charset.defaultCharset().encode(\"0123\\n456789abcdef\"));\nsc.write(Charset.defaultCharset().encode(\"0123456789abcdef3333\\n\"));\nSystem.in.read();\n```\n\n\n\n\n\n#### ByteBuffer 大小分配\n\n* 每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\n* ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n  * 一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 [http://tutorials.jenkov.com/java-performance/resizable-array.html](http://tutorials.jenkov.com/java-performance/resizable-array.html)\n  * 另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\n\n\n\n\n\n### 4.5 处理 write 事件\n\n\n\n#### 一次无法写完例子\n\n* 非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）\n* 用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略\n  * 当消息处理器第一次写入消息时，才将 channel 注册到 selector 上\n  * selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册\n  * 如果不取消，会每次可写均会触发 write 事件\n\n\n\n```java\npublic class WriteServer {\n\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel ssc = ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        ssc.bind(new InetSocketAddress(8080));\n\n        Selector selector = Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n\n        while(true) {\n            selector.select();\n\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isAcceptable()) {\n                    SocketChannel sc = ssc.accept();\n                    sc.configureBlocking(false);\n                    SelectionKey sckey = sc.register(selector, SelectionKey.OP_READ);\n                    // 1. 向客户端发送内容\n                    StringBuilder sb = new StringBuilder();\n                    for (int i = 0; i < 3000000; i++) {\n                        sb.append(\"a\");\n                    }\n                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());\n                    int write = sc.write(buffer);\n                    // 3. write 表示实际写了多少字节\n                    System.out.println(\"实际写入字节:\" + write);\n                    // 4. 如果有剩余未读字节，才需要关注写事件\n                    if (buffer.hasRemaining()) {\n                        // read 1  write 4\n                        // 在原有关注事件的基础上，多关注 写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        // 把 buffer 作为附件加入 sckey\n                        sckey.attach(buffer);\n                    }\n                } else if (key.isWritable()) {\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    SocketChannel sc = (SocketChannel) key.channel();\n                    int write = sc.write(buffer);\n                    System.out.println(\"实际写入字节:\" + write);\n                    if (!buffer.hasRemaining()) { // 写完了\n                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);\n                        key.attach(null);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n客户端\n\n```java\npublic class WriteClient {\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        SocketChannel sc = SocketChannel.open();\n        sc.configureBlocking(false);\n        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n        sc.connect(new InetSocketAddress(\"localhost\", 8080));\n        int count = 0;\n        while (true) {\n            selector.select();\n            Iterator<SelectionKey> iter = selector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n                iter.remove();\n                if (key.isConnectable()) {\n                    System.out.println(sc.finishConnect());\n                } else if (key.isReadable()) {\n                    ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);\n                    count += sc.read(buffer);\n                    buffer.clear();\n                    System.out.println(count);\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 write 为何要取消\n\n只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注\n\n\n\n\n\n\n\n\n\n\n\n### 4.6 更进一步\n\n\n\n#### 💡 利用多线程优化\n\n> 现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费\n\n\n\n前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？\n\n分两组选择器\n\n* 单线程配一个选择器，专门处理 accept 事件\n* 创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件\n\n\n\n```java\npublic class ChannelDemo7 {\n    public static void main(String[] args) throws IOException {\n        new BossEventLoop().register();\n    }\n\n\n    @Slf4j\n    static class BossEventLoop implements Runnable {\n        private Selector boss;\n        private WorkerEventLoop[] workers;\n        private volatile boolean start = false;\n        AtomicInteger index = new AtomicInteger();\n\n        public void register() throws IOException {\n            if (!start) {\n                ServerSocketChannel ssc = ServerSocketChannel.open();\n                ssc.bind(new InetSocketAddress(8080));\n                ssc.configureBlocking(false);\n                boss = Selector.open();\n                SelectionKey ssckey = ssc.register(boss, 0, null);\n                ssckey.interestOps(SelectionKey.OP_ACCEPT);\n                workers = initEventLoops();\n                new Thread(this, \"boss\").start();\n                log.debug(\"boss start...\");\n                start = true;\n            }\n        }\n\n        public WorkerEventLoop[] initEventLoops() {\n//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];\n            WorkerEventLoop[] workerEventLoops = new WorkerEventLoop[2];\n            for (int i = 0; i < workerEventLoops.length; i++) {\n                workerEventLoops[i] = new WorkerEventLoop(i);\n            }\n            return workerEventLoops;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    boss.select();\n                    Iterator<SelectionKey> iter = boss.selectedKeys().iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        iter.remove();\n                        if (key.isAcceptable()) {\n                            ServerSocketChannel c = (ServerSocketChannel) key.channel();\n                            SocketChannel sc = c.accept();\n                            sc.configureBlocking(false);\n                            log.debug(\"{} connected\", sc.getRemoteAddress());\n                            workers[index.getAndIncrement() % workers.length].register(sc);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    @Slf4j\n    static class WorkerEventLoop implements Runnable {\n        private Selector worker;\n        private volatile boolean start = false;\n        private int index;\n\n        private final ConcurrentLinkedQueue<Runnable> tasks = new ConcurrentLinkedQueue<>();\n\n        public WorkerEventLoop(int index) {\n            this.index = index;\n        }\n\n        public void register(SocketChannel sc) throws IOException {\n            if (!start) {\n                worker = Selector.open();\n                new Thread(this, \"worker-\" + index).start();\n                start = true;\n            }\n            tasks.add(() -> {\n                try {\n                    SelectionKey sckey = sc.register(worker, 0, null);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    worker.selectNow();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            worker.wakeup();\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    worker.select();\n                    Runnable task = tasks.poll();\n                    if (task != null) {\n                        task.run();\n                    }\n                    Set<SelectionKey> keys = worker.selectedKeys();\n                    Iterator<SelectionKey> iter = keys.iterator();\n                    while (iter.hasNext()) {\n                        SelectionKey key = iter.next();\n                        if (key.isReadable()) {\n                            SocketChannel sc = (SocketChannel) key.channel();\n                            ByteBuffer buffer = ByteBuffer.allocate(128);\n                            try {\n                                int read = sc.read(buffer);\n                                if (read == -1) {\n                                    key.cancel();\n                                    sc.close();\n                                } else {\n                                    buffer.flip();\n                                    log.debug(\"{} message:\", sc.getRemoteAddress());\n                                    debugAll(buffer);\n                                }\n                            } catch (IOException e) {\n                                e.printStackTrace();\n                                key.cancel();\n                                sc.close();\n                            }\n                        }\n                        iter.remove();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n#### 💡 如何拿到 cpu 个数\n\n> * Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数\n> * 这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启\n\n\n\n### 4.7 UDP\n\n* UDP 是无连接的，client 发送数据不会管 server 是否开启\n* server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃\n\n首先启动服务器端\n\n```java\npublic class UdpServer {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            channel.socket().bind(new InetSocketAddress(9999));\n            System.out.println(\"waiting...\");\n            ByteBuffer buffer = ByteBuffer.allocate(32);\n            channel.receive(buffer);\n            buffer.flip();\n            debug(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n输出\n\n```\nwaiting...\n```\n\n\n\n运行客户端\n\n```java\npublic class UdpClient {\n    public static void main(String[] args) {\n        try (DatagramChannel channel = DatagramChannel.open()) {\n            ByteBuffer buffer = StandardCharsets.UTF_8.encode(\"hello\");\n            InetSocketAddress address = new InetSocketAddress(\"localhost\", 9999);\n            channel.send(buffer, address);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n接下来服务器端输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 65 6c 6c 6f                                  |hello           |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n\n\n## 5. NIO vs BIO\n\n### 5.1 stream vs channel\n\n* stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\n* stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n* 二者均为全双工，即读写可以同时进行\n\n\n\n### 5.2 IO 模型\n\n同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞\n\n* 同步：线程自己去获取结果（一个线程）\n* 异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）\n\n\n\n当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n* 等待数据阶段\n* 复制数据阶段\n\n![](img/0033.png)\n\n* 阻塞 IO\n\n  ![](img/0039.png)\n\n* 非阻塞  IO\n\n  ![](img/0035.png)\n\n* 多路复用\n\n  ![](img/0038.png)\n\n* 信号驱动\n\n* 异步 IO\n\n  ![](img/0037.png)\n\n* 阻塞 IO vs 多路复用\n\n  ![](img/0034.png)\n\n  ![](img/0036.png)\n\n#### 🔖 参考\n\nUNIX 网络编程 - 卷 I\n\n\n\n### 5.3 零拷贝\n\n#### 传统 IO 问题\n\n传统的 IO 将一个文件通过 socket 写出\n\n```java\nFile f = new File(\"helloword/data.txt\");\nRandomAccessFile file = new RandomAccessFile(file, \"r\");\n\nbyte[] buf = new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket = ...;\nsocket.getOutputStream().write(buf);\n```\n\n内部工作流程是这样的：\n\n![](img/0024.png)\n\n1. java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的**用户态**切换至**内核态**，去调用操作系统（Kernel）的读能力，将数据读入**内核缓冲区**。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu\n\n   > DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n2. 从**内核态**切换回**用户态**，将数据从**内核缓冲区**读入**用户缓冲区**（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA\n\n3. 调用 write 方法，这时将数据从**用户缓冲区**（byte[] buf）写入 **socket 缓冲区**，cpu 会参与拷贝\n\n4. 接下来要向网卡写数据，这项能力 java 又不具备，因此又得从**用户态**切换至**内核态**，调用操作系统的写能力，使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n* 用户态与内核态的切换发生了 3 次，这个操作比较重量级\n* 数据拷贝了共 4 次\n\n\n\n#### NIO 优化\n\n通过 DirectByteBuf \n\n* ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存\n* ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存\n\n![](img/0025.png)\n\n大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用\n\n* 这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\n* java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\n  * DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列\n  * 通过专门线程访问引用队列，根据虚引用释放堆外内存\n* 减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n\n\n进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据\n\n![](img/0026.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 数据从**内核缓冲区**传输到 **socket 缓冲区**，cpu 会参与拷贝\n3. 最后使用 DMA 将 **socket 缓冲区**的数据写入网卡，不会使用 cpu\n\n可以看到\n\n* 只发生了一次用户态与内核态的切换\n* 数据拷贝了 3 次\n\n\n\n进一步优化（linux 2.4）\n\n![](img/0027.png)\n\n1. java 调用 transferTo 方法后，要从 java 程序的**用户态**切换至**内核态**，使用 DMA将数据读入**内核缓冲区**，不会使用 cpu\n2. 只会将一些 offset 和 length 信息拷入 **socket 缓冲区**，几乎无消耗\n3. 使用 DMA 将 **内核缓冲区**的数据写入网卡，不会使用 cpu\n\n整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有\n\n* 更少的用户态与内核态的切换\n* 不利用 cpu 计算，减少 cpu 缓存伪共享\n* 零拷贝适合小文件传输\n\n\n\n### 5.3 AIO\n\nAIO 用来解决数据复制阶段的阻塞问题\n\n* 同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n* 异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n> 异步模型需要底层操作系统（Kernel）提供支持\n>\n> * Windows 系统通过 IOCP 实现了真正的异步 IO\n> * Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n\n\n#### 文件 AIO\n\n先来看看 AsynchronousFileChannel\n\n```java\n@Slf4j\npublic class AioDemo1 {\n    public static void main(String[] args) throws IOException {\n        try{\n            AsynchronousFileChannel s = \n                AsynchronousFileChannel.open(\n                \tPaths.get(\"1.txt\"), StandardOpenOption.READ);\n            ByteBuffer buffer = ByteBuffer.allocate(2);\n            log.debug(\"begin...\");\n            s.read(buffer, 0, null, new CompletionHandler<Integer, ByteBuffer>() {\n                @Override\n                public void completed(Integer result, ByteBuffer attachment) {\n                    log.debug(\"read completed...{}\", result);\n                    buffer.flip();\n                    debug(buffer);\n                }\n\n                @Override\n                public void failed(Throwable exc, ByteBuffer attachment) {\n                    log.debug(\"read failed...\");\n                }\n            });\n\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        log.debug(\"do other things...\");\n        System.in.read();\n    }\n}\n```\n\n输出\n\n```\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...\n13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...\n13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0d                                           |a.              |\n+--------+-------------------------------------------------+----------------+\n```\n\n可以看到\n\n* 响应文件读取成功的是另一个线程 Thread-5\n* 主线程并没有 IO 操作阻塞\n\n\n\n#### 💡 守护线程\n\n默认文件 AIO 使用的线程都是守护线程，所以最后要执行 `System.in.read()` 以避免守护线程意外结束\n\n\n\n#### 网络 AIO\n\n```java\npublic class AioServer {\n    public static void main(String[] args) throws IOException {\n        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();\n        ssc.bind(new InetSocketAddress(8080));\n        ssc.accept(null, new AcceptHandler(ssc));\n        System.in.read();\n    }\n\n    private static void closeChannel(AsynchronousSocketChannel sc) {\n        try {\n            System.out.printf(\"[%s] %s close\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            sc.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static class ReadHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        public ReadHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            try {\n                if (result == -1) {\n                    closeChannel(sc);\n                    return;\n                }\n                System.out.printf(\"[%s] %s read\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n                attachment.flip();\n                System.out.println(Charset.defaultCharset().decode(attachment));\n                attachment.clear();\n                // 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件\n                sc.read(attachment, attachment, this);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            closeChannel(sc);\n            exc.printStackTrace();\n        }\n    }\n\n    private static class WriteHandler implements CompletionHandler<Integer, ByteBuffer> {\n        private final AsynchronousSocketChannel sc;\n\n        private WriteHandler(AsynchronousSocketChannel sc) {\n            this.sc = sc;\n        }\n\n        @Override\n        public void completed(Integer result, ByteBuffer attachment) {\n            // 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容\n            if (attachment.hasRemaining()) {\n                sc.write(attachment);\n            }\n        }\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) {\n            exc.printStackTrace();\n            closeChannel(sc);\n        }\n    }\n\n    private static class AcceptHandler implements CompletionHandler<AsynchronousSocketChannel, Object> {\n        private final AsynchronousServerSocketChannel ssc;\n\n        public AcceptHandler(AsynchronousServerSocketChannel ssc) {\n            this.ssc = ssc;\n        }\n\n        @Override\n        public void completed(AsynchronousSocketChannel sc, Object attachment) {\n            try {\n                System.out.printf(\"[%s] %s connected\\n\", Thread.currentThread().getName(), sc.getRemoteAddress());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            ByteBuffer buffer = ByteBuffer.allocate(16);\n            // 读事件由 ReadHandler 处理\n            sc.read(buffer, buffer, new ReadHandler(sc));\n            // 写事件由 WriteHandler 处理\n            sc.write(Charset.defaultCharset().encode(\"server hello!\"), ByteBuffer.allocate(16), new WriteHandler(sc));\n            // 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件\n            ssc.accept(null, this);\n        }\n\n        @Override\n        public void failed(Throwable exc, Object attachment) {\n            exc.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n\n\n\n","slug":"Netty01-nio","published":1,"updated":"2023-05-06T13:27:49.808Z","_id":"clhc0j23w0000r8wegitx18sn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>该笔记是B站黑马的Netty视频的配套笔记1。</p>\n<span id=\"more\"></span>\n<h1 id=\"一-NIO-基础\"><a href=\"#一-NIO-基础\" class=\"headerlink\" title=\"一. NIO 基础\"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p>\n<h2 id=\"1-三大组件\"><a href=\"#1-三大组件\" class=\"headerlink\" title=\"1. 三大组件\"></a>1. 三大组件</h2><h3 id=\"1-1-Channel-amp-Buffer\"><a href=\"#1-1-Channel-amp-Buffer\" class=\"headerlink\" title=\"1.1 Channel &amp; Buffer\"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">channel --&gt; buffer</span><br><span class=\"line\">buffer --&gt; channel</span><br></pre></td></tr></table></figure>\n\n<p>常见的 Channel 有</p>\n<ul>\n<li>FileChannel</li>\n<li>DatagramChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n</ul>\n<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>\n<ul>\n<li>ByteBuffer<ul>\n<li>MappedByteBuffer</li>\n<li>DirectByteBuffer</li>\n<li>HeapByteBuffer</li>\n</ul>\n</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>CharBuffer</li>\n</ul>\n<h3 id=\"1-2-Selector\"><a href=\"#1-2-Selector\" class=\"headerlink\" title=\"1.2 Selector\"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>\n<h4 id=\"多线程版设计\"><a href=\"#多线程版设计\" class=\"headerlink\" title=\"多线程版设计\"></a>多线程版设计</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 多线程版</span><br><span class=\"line\">t1(thread) --&gt; s1(socket1)</span><br><span class=\"line\">t2(thread) --&gt; s2(socket2)</span><br><span class=\"line\">t3(thread) --&gt; s3(socket3)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"⚠️-多线程版缺点\"><a href=\"#⚠️-多线程版缺点\" class=\"headerlink\" title=\"⚠️ 多线程版缺点\"></a>⚠️ 多线程版缺点</h4><ul>\n<li>内存占用高</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景</li>\n</ul>\n<h4 id=\"线程池版设计\"><a href=\"#线程池版设计\" class=\"headerlink\" title=\"线程池版设计\"></a>线程池版设计</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 线程池版</span><br><span class=\"line\">t4(thread) --&gt; s4(socket1)</span><br><span class=\"line\">t5(thread) --&gt; s5(socket2)</span><br><span class=\"line\">t4(thread) -.-&gt; s6(socket3)</span><br><span class=\"line\">t5(thread) -.-&gt; s7(socket4)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"⚠️-线程池版缺点\"><a href=\"#⚠️-线程池版缺点\" class=\"headerlink\" title=\"⚠️ 线程池版缺点\"></a>⚠️ 线程池版缺点</h4><ul>\n<li>阻塞模式下，线程仅能处理一个 socket 连接</li>\n<li>仅适合短连接场景</li>\n</ul>\n<h4 id=\"selector-版设计\"><a href=\"#selector-版设计\" class=\"headerlink\" title=\"selector 版设计\"></a>selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph selector 版</span><br><span class=\"line\">thread --&gt; selector</span><br><span class=\"line\">selector --&gt; c1(channel)</span><br><span class=\"line\">selector --&gt; c2(channel)</span><br><span class=\"line\">selector --&gt; c3(channel)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p>\n<h2 id=\"2-ByteBuffer\"><a href=\"#2-ByteBuffer\" class=\"headerlink\" title=\"2. ByteBuffer\"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1234567890abcd</span><br></pre></td></tr></table></figure>\n\n<p>使用 FileChannel 来读取文件内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/data.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 向 buffer 写入</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 切换 buffer 读模式</span></span><br><span class=\"line\">                buffer.flip();</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(buffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, (<span class=\"type\">char</span>)buffer.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 切换 buffer 写模式</span></span><br><span class=\"line\">                buffer.clear();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-1-ByteBuffer-正确使用姿势\"><a href=\"#2-1-ByteBuffer-正确使用姿势\" class=\"headerlink\" title=\"2.1  ByteBuffer 正确使用姿势\"></a>2.1  ByteBuffer 正确使用姿势</h3><ol>\n<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>\n<li>调用 flip() 切换至<strong>读模式</strong></li>\n<li>从 buffer 读取数据，例如调用 buffer.get()</li>\n<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>\n<li>重复 1~4 步骤</li>\n</ol>\n<h3 id=\"2-2-ByteBuffer-结构\"><a href=\"#2-2-ByteBuffer-结构\" class=\"headerlink\" title=\"2.2 ByteBuffer 结构\"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>\n<ul>\n<li>capacity</li>\n<li>position</li>\n<li>limit</li>\n</ul>\n<p>一开始</p>\n<p><img src=\"/img/0021.png\"></p>\n<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>\n<p><img src=\"/img/0018.png\"></p>\n<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>\n<p><img src=\"/img/0019.png\"></p>\n<p>读取 4 个字节后，状态</p>\n<p><img src=\"/img/0020.png\"></p>\n<p>clear 动作发生后，状态</p>\n<p><img src=\"/img/0021.png\"></p>\n<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>\n<p><img src=\"/img/0022.png\"></p>\n<h4 id=\"💡-调试工具类\"><a href=\"#💡-调试工具类\" class=\"headerlink\" title=\"💡 调试工具类\"></a>💡 调试工具类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBufferUtil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] BYTE2CHAR = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] HEXDUMP_TABLE = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">256</span> * <span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] HEXPADDING = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] HEXDUMP_ROWPREFIXES = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">65536</span> &gt;&gt;&gt; <span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] BYTE2HEX = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] BYTEPADDING = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] DIGITS = <span class=\"string\">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++) &#123;</span><br><span class=\"line\">            HEXDUMP_TABLE[i &lt;&lt; <span class=\"number\">1</span>] = DIGITS[i &gt;&gt;&gt; <span class=\"number\">4</span> &amp; <span class=\"number\">0x0F</span>];</span><br><span class=\"line\">            HEXDUMP_TABLE[(i &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>] = DIGITS[i &amp; <span class=\"number\">0x0F</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for hex dump paddings</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">padding</span> <span class=\"operator\">=</span> HEXPADDING.length - i;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(padding * <span class=\"number\">3</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; padding; j++) &#123;</span><br><span class=\"line\">                buf.append(<span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            HEXPADDING[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">            buf.append(NEWLINE);</span><br><span class=\"line\">            buf.append(Long.toHexString(i &lt;&lt; <span class=\"number\">4</span> &amp; <span class=\"number\">0xFFFFFFFFL</span> | <span class=\"number\">0x100000000L</span>));</span><br><span class=\"line\">            buf.setCharAt(buf.length() - <span class=\"number\">9</span>, <span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            buf.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class=\"line\">            BYTE2HEX[i] = <span class=\"string\">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte dump paddings</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">padding</span> <span class=\"operator\">=</span> BYTEPADDING.length - i;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(padding);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; padding; j++) &#123;</span><br><span class=\"line\">                buf.append(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            BYTEPADDING[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte-to-char conversion</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0x1f</span> || i &gt;= <span class=\"number\">0x7f</span>) &#123;</span><br><span class=\"line\">                BYTE2CHAR[i] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                BYTE2CHAR[i] = (<span class=\"type\">char</span>) i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 打印所有内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">debugAll</span><span class=\"params\">(ByteBuffer buffer)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldlimit</span> <span class=\"operator\">=</span> buffer.limit();</span><br><span class=\"line\">        buffer.limit(buffer.capacity());</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">origin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">256</span>);</span><br><span class=\"line\">        appendPrettyHexDump(origin, buffer, <span class=\"number\">0</span>, buffer.capacity());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;position: [%d], limit: [%d]\\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class=\"line\">        System.out.println(origin);</span><br><span class=\"line\">        buffer.limit(oldlimit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 打印可读取内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">debugRead</span><span class=\"params\">(ByteBuffer buffer)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">256</span>);</span><br><span class=\"line\">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;position: [%d], limit: [%d]\\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class=\"line\">        System.out.println(builder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">appendPrettyHexDump</span><span class=\"params\">(StringBuilder dump, ByteBuffer buf, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;expected: &quot;</span> + <span class=\"string\">&quot;0 &lt;= offset(&quot;</span> + offset + <span class=\"string\">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class=\"line\">                            + <span class=\"string\">&quot;) &lt;= &quot;</span> + <span class=\"string\">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dump.append(</span><br><span class=\"line\">                <span class=\"string\">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class=\"line\">                        NEWLINE + <span class=\"string\">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class=\"line\">                        NEWLINE + <span class=\"string\">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">startIndex</span> <span class=\"operator\">=</span> offset;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">fullRows</span> <span class=\"operator\">=</span> length &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">remainder</span> <span class=\"operator\">=</span> length &amp; <span class=\"number\">0xF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Dump the rows which have 16 bytes.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">row</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowStartIndex</span> <span class=\"operator\">=</span> (row &lt;&lt; <span class=\"number\">4</span>) + startIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Per-row prefix.</span></span><br><span class=\"line\">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Hex dump</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowEndIndex</span> <span class=\"operator\">=</span> rowStartIndex + <span class=\"number\">16</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(<span class=\"string\">&quot; |&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ASCII dump</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Dump the last row which has less than 16 bytes.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainder != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowStartIndex</span> <span class=\"operator\">=</span> (fullRows &lt;&lt; <span class=\"number\">4</span>) + startIndex;</span><br><span class=\"line\">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Hex dump</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowEndIndex</span> <span class=\"operator\">=</span> rowStartIndex + remainder;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(HEXPADDING[remainder]);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&quot; |&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Ascii dump</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(BYTEPADDING[remainder]);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dump.append(NEWLINE +</span><br><span class=\"line\">                <span class=\"string\">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">appendHexDumpRowPrefix</span><span class=\"params\">(StringBuilder dump, <span class=\"type\">int</span> row, <span class=\"type\">int</span> rowStartIndex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class=\"line\">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dump.append(NEWLINE);</span><br><span class=\"line\">            dump.append(Long.toHexString(rowStartIndex &amp; <span class=\"number\">0xFFFFFFFFL</span> | <span class=\"number\">0x100000000L</span>));</span><br><span class=\"line\">            dump.setCharAt(dump.length() - <span class=\"number\">9</span>, <span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">short</span> <span class=\"title function_\">getUnsignedByte</span><span class=\"params\">(ByteBuffer buffer, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">short</span>) (buffer.get(index) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-ByteBuffer-常见方法\"><a href=\"#2-3-ByteBuffer-常见方法\" class=\"headerlink\" title=\"2.3 ByteBuffer 常见方法\"></a>2.3 ByteBuffer 常见方法</h3><h4 id=\"分配空间\"><a href=\"#分配空间\" class=\"headerlink\" title=\"分配空间\"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Bytebuffer</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"向-buffer-写入数据\"><a href=\"#向-buffer-写入数据\" class=\"headerlink\" title=\"向 buffer 写入数据\"></a>向 buffer 写入数据</h4><p>有两种办法</p>\n<ul>\n<li>调用 channel 的 read 方法</li>\n<li>调用 buffer 自己的 put 方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">readBytes</span> <span class=\"operator\">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure>\n\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf.put((<span class=\"type\">byte</span>)<span class=\"number\">127</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"从-buffer-读取数据\"><a href=\"#从-buffer-读取数据\" class=\"headerlink\" title=\"从 buffer 读取数据\"></a>从 buffer 读取数据</h4><p>同样有两种办法</p>\n<ul>\n<li>调用 channel 的 write 方法</li>\n<li>调用 buffer 自己的 get 方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">writeBytes</span> <span class=\"operator\">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure>\n\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> buf.get();</span><br></pre></td></tr></table></figure>\n\n<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>\n<ul>\n<li>可以调用 rewind 方法将 position 重新置为 0</li>\n<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>\n</ul>\n<h4 id=\"mark-和-reset\"><a href=\"#mark-和-reset\" class=\"headerlink\" title=\"mark 和 reset\"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>\n<blockquote>\n<p><strong>注意</strong></p>\n<p>rewind 和 flip 都会清除 mark 位置</p>\n</blockquote>\n<h4 id=\"字符串与-ByteBuffer-互转\"><a href=\"#字符串与-ByteBuffer-互转\" class=\"headerlink\" title=\"字符串与 ByteBuffer 互转\"></a>字符串与 ByteBuffer 互转</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer1</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;你好&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer2</span> <span class=\"operator\">=</span> Charset.forName(<span class=\"string\">&quot;utf-8&quot;</span>).encode(<span class=\"string\">&quot;你好&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">debug(buffer1);</span><br><span class=\"line\">debug(buffer2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">CharBuffer</span> <span class=\"variable\">buffer3</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class=\"line\">System.out.println(buffer3.getClass());</span><br><span class=\"line\">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">class java.nio.HeapCharBuffer</span><br><span class=\"line\">你好</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-Buffer-的线程安全\"><a href=\"#⚠️-Buffer-的线程安全\" class=\"headerlink\" title=\"⚠️ Buffer 的线程安全\"></a>⚠️ Buffer 的线程安全</h4><blockquote>\n<p>Buffer 是<strong>非线程安全的</strong></p>\n</blockquote>\n<h3 id=\"2-4-Scattering-Reads\"><a href=\"#2-4-Scattering-Reads\" class=\"headerlink\" title=\"2.4 Scattering Reads\"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onetwothree</span><br></pre></td></tr></table></figure>\n\n<p>使用如下方式读取，可以将数据填充至多个 buffer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/3parts.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>);</span><br><span class=\"line\">    channel.read(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;a, b, c&#125;);</span><br><span class=\"line\">    a.flip();</span><br><span class=\"line\">    b.flip();</span><br><span class=\"line\">    c.flip();</span><br><span class=\"line\">    debug(a);</span><br><span class=\"line\">    debug(b);</span><br><span class=\"line\">    debug(c);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6f 6e 65                                        |one             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 74 77 6f                                        |two             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-5-Gathering-Writes\"><a href=\"#2-5-Gathering-Writes\" class=\"headerlink\" title=\"2.5 Gathering Writes\"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/3parts.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    channel.position(<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    d.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>&#125;);</span><br><span class=\"line\">    e.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>&#125;);</span><br><span class=\"line\">    d.flip();</span><br><span class=\"line\">    e.flip();</span><br><span class=\"line\">    debug(d);</span><br><span class=\"line\">    debug(e);</span><br><span class=\"line\">    channel.write(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 6f 75 72                                     |four            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 69 76 65                                     |five            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>文件内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onetwothreefourfive</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-6-练习\"><a href=\"#2-6-练习\" class=\"headerlink\" title=\"2.6 练习\"></a>2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>\n<ul>\n<li>Hello,world\\n</li>\n<li>I’m zhangsan\\n</li>\n<li>How are you?\\n</li>\n</ul>\n<p>变成了下面的两个 byteBuffer (黏包，半包)</p>\n<ul>\n<li>Hello,world\\nI’m zhangsan\\nHo</li>\n<li>w are you?\\n</li>\n</ul>\n<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"comment\">//                     11            24</span></span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;Hello,world\\nI&#x27;m zhangsan\\nHo&quot;</span>.getBytes());</span><br><span class=\"line\">    split(source);</span><br><span class=\"line\"></span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;w are you?\\nhaha!\\n&quot;</span>.getBytes());</span><br><span class=\"line\">    split(source);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">split</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">    source.flip();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldLimit</span> <span class=\"operator\">=</span> source.limit();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(i + <span class=\"number\">1</span> - source.position());</span><br><span class=\"line\">            <span class=\"comment\">// 0 ~ limit</span></span><br><span class=\"line\">            source.limit(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            target.put(source); <span class=\"comment\">// 从source 读，向 target 写</span></span><br><span class=\"line\">            debugAll(target);</span><br><span class=\"line\">            source.limit(oldLimit);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    source.compact();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-文件编程\"><a href=\"#3-文件编程\" class=\"headerlink\" title=\"3. 文件编程\"></a>3. 文件编程</h2><h3 id=\"3-1-FileChannel\"><a href=\"#3-1-FileChannel\" class=\"headerlink\" title=\"3.1 FileChannel\"></a>3.1 FileChannel</h3><h4 id=\"⚠️-FileChannel-工作模式\"><a href=\"#⚠️-FileChannel-工作模式\" class=\"headerlink\" title=\"⚠️ FileChannel 工作模式\"></a>⚠️ FileChannel 工作模式</h4><blockquote>\n<p>FileChannel 只能工作在阻塞模式下</p>\n</blockquote>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel 只能读</li>\n<li>通过 FileOutputStream 获取的 channel 只能写</li>\n<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>\n</ul>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">readBytes</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">buffer.put(...); <span class=\"comment\">// 存入数据</span></span><br><span class=\"line\">buffer.flip();   <span class=\"comment\">// 切换读模式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(buffer.hasRemaining()) &#123;</span><br><span class=\"line\">    channel.write(buffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>获取当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> channel.position();</span><br></pre></td></tr></table></figure>\n\n<p>设置当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">newPos</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">channel.position(newPos);</span><br></pre></td></tr></table></figure>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1 </li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用 size 方法获取文件的大小</p>\n<h4 id=\"强制写入\"><a href=\"#强制写入\" class=\"headerlink\" title=\"强制写入\"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>\n<h3 id=\"3-2-两个-Channel-传输数据\"><a href=\"#3-2-两个-Channel-传输数据\" class=\"headerlink\" title=\"3.2 两个 Channel 传输数据\"></a>3.2 两个 Channel 传输数据</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">FROM</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloword/data.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">TO</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloword/to.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">FileChannel</span> <span class=\"variable\">from</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(FROM).getChannel();</span><br><span class=\"line\">     <span class=\"type\">FileChannel</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(TO).getChannel();</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">    from.transferTo(<span class=\"number\">0</span>, from.size(), to);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class=\"number\">1000_000.0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transferTo 用时：8.2011</span><br></pre></td></tr></table></figure>\n\n\n\n<p>超过 2g 大小的文件传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestFileChannelTransferTo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (</span><br><span class=\"line\">                <span class=\"type\">FileChannel</span> <span class=\"variable\">from</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;data.txt&quot;</span>).getChannel();</span><br><span class=\"line\">                <span class=\"type\">FileChannel</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;to.txt&quot;</span>).getChannel();</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> from.size();</span><br><span class=\"line\">            <span class=\"comment\">// left 变量代表还剩余多少字节</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> size; left &gt; <span class=\"number\">0</span>; ) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;position:&quot;</span> + (size - left) + <span class=\"string\">&quot; left:&quot;</span> + left);</span><br><span class=\"line\">                left -= from.transferTo((size - left), left, to);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际传输一个超大文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position:0 left:7769948160</span><br><span class=\"line\">position:2147483647 left:5622464513</span><br><span class=\"line\">position:4294967294 left:3474980866</span><br><span class=\"line\">position:6442450941 left:1327497219</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-Path\"><a href=\"#3-3-Path\" class=\"headerlink\" title=\"3.3 Path\"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>\n<ul>\n<li>Path 用来表示文件路径</li>\n<li>Paths 是工具类，用来获取 Path 实例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;1.txt&quot;</span>); <span class=\"comment\">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:/1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 同样代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">projects</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data&quot;</span>, <span class=\"string\">&quot;projects&quot;</span>); <span class=\"comment\">// 代表了  d:\\data\\projects</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:</span><br><span class=\"line\">\t|- data</span><br><span class=\"line\">\t\t|- projects</span><br><span class=\"line\">\t\t\t|- a</span><br><span class=\"line\">\t\t\t|- b</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;</span>);</span><br><span class=\"line\">System.out.println(path);</span><br><span class=\"line\">System.out.println(path.normalize()); <span class=\"comment\">// 正常化路径</span></span><br></pre></td></tr></table></figure>\n\n<p>会输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:\\data\\projects\\a\\..\\b</span><br><span class=\"line\">d:\\data\\projects\\b</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-Files\"><a href=\"#3-4-Files\" class=\"headerlink\" title=\"3.4 Files\"></a>3.4 Files</h3><p>检查文件是否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>\n\n\n\n<p>创建一级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1&quot;</span>);</span><br><span class=\"line\">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>\n<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>\n</ul>\n<p>创建多级目录用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1/d2&quot;</span>);</span><br><span class=\"line\">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>拷贝文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/target.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.copy(source, target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>\n</ul>\n<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>移动文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>\n</ul>\n<p>删除文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/target.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.delete(target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果文件不存在，会抛异常 NoSuchFileException</li>\n</ul>\n<p>删除目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.delete(target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>\n</ul>\n<p>遍历目录文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">AtomicInteger</span> <span class=\"variable\">dirCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">    <span class=\"type\">AtomicInteger</span> <span class=\"variable\">fileCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">    Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">preVisitDirectory</span><span class=\"params\">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            System.out.println(dir);</span><br><span class=\"line\">            dirCount.incrementAndGet();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.preVisitDirectory(dir, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            System.out.println(file);</span><br><span class=\"line\">            fileCount.incrementAndGet();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(dirCount); <span class=\"comment\">// 133</span></span><br><span class=\"line\">    System.out.println(fileCount); <span class=\"comment\">// 1479</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>统计 jar 的数目</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">AtomicInteger</span> <span class=\"variable\">fileCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.toFile().getName().endsWith(<span class=\"string\">&quot;.jar&quot;</span>)) &#123;</span><br><span class=\"line\">            fileCount.incrementAndGet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">System.out.println(fileCount); <span class=\"comment\">// 724</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>删除多级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\a&quot;</span>);</span><br><span class=\"line\">Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        Files.delete(file);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">postVisitDirectory</span><span class=\"params\">(Path dir, IOException exc)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        Files.delete(dir);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.postVisitDirectory(dir, exc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-删除很危险\"><a href=\"#⚠️-删除很危险\" class=\"headerlink\" title=\"⚠️ 删除很危险\"></a>⚠️ 删除很危险</h4><blockquote>\n<p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p>\n</blockquote>\n<p>拷贝多级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;D:\\\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;D:\\\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">targetName</span> <span class=\"operator\">=</span> path.toString().replace(source, target);</span><br><span class=\"line\">        <span class=\"comment\">// 是目录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Files.isDirectory(path)) &#123;</span><br><span class=\"line\">            Files.createDirectory(Paths.get(targetName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是普通文件</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class=\"line\">            Files.copy(path, Paths.get(targetName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(end - start);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"4-网络编程\"><a href=\"#4-网络编程\" class=\"headerlink\" title=\"4. 网络编程\"></a>4. 网络编程</h2><h3 id=\"4-1-非阻塞-vs-阻塞\"><a href=\"#4-1-非阻塞-vs-阻塞\" class=\"headerlink\" title=\"4.1 非阻塞 vs 阻塞\"></a>4.1 非阻塞 vs 阻塞</h3><h4 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h4><ul>\n<li>阻塞模式下，相关方法都会导致线程暂停<ul>\n<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>\n<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>\n<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>\n</ul>\n</li>\n<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>\n<li>但多线程下，有新的问题，体现在以下方面<ul>\n<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>\n<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>\n</ul>\n</li>\n</ul>\n<p>服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class=\"line\"><span class=\"comment\">// 0. ByteBuffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建了服务器</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定监听端口</span></span><br><span class=\"line\">ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 连接集合</span></span><br><span class=\"line\">List&lt;SocketChannel&gt; channels = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;connecting...&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept(); <span class=\"comment\">// 阻塞方法，线程停止运行</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">    channels.add(sc);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SocketChannel channel : channels) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5. 接收客户端发送的数据</span></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        channel.read(buffer); <span class=\"comment\">// 阻塞方法，线程停止运行</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        debugRead(buffer);</span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h4><ul>\n<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>\n<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>\n<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>\n<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>\n</ul>\n</li>\n<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>\n<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>\n</ul>\n<p>服务器端，客户端代码不变</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class=\"line\"><span class=\"comment\">// 0. ByteBuffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建了服务器</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">ssc.configureBlocking(<span class=\"literal\">false</span>); <span class=\"comment\">// 非阻塞模式</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定监听端口</span></span><br><span class=\"line\">ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3. 连接集合</span></span><br><span class=\"line\">List&lt;SocketChannel&gt; channels = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept(); <span class=\"comment\">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sc != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">        sc.configureBlocking(<span class=\"literal\">false</span>); <span class=\"comment\">// 非阻塞模式</span></span><br><span class=\"line\">        channels.add(sc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SocketChannel channel : channels) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5. 接收客户端发送的数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer);<span class=\"comment\">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            buffer.flip();</span><br><span class=\"line\">            debugRead(buffer);</span><br><span class=\"line\">            buffer.clear();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多路复用\"><a href=\"#多路复用\" class=\"headerlink\" title=\"多路复用\"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>\n<ul>\n<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>\n<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>\n<li>有可连接事件时才去连接</li>\n<li>有可读事件才去读取</li>\n<li>有可写事件才去写入<ul>\n<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-Selector\"><a href=\"#4-2-Selector\" class=\"headerlink\" title=\"4.2 Selector\"></a>4.2 Selector</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph selector 版</span><br><span class=\"line\">thread --&gt; selector</span><br><span class=\"line\">selector --&gt; c1(channel)</span><br><span class=\"line\">selector --&gt; c2(channel)</span><br><span class=\"line\">selector --&gt; c3(channel)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>好处</p>\n<ul>\n<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>\n<li>让这个线程能够被充分利用</li>\n<li>节约了线程的数量</li>\n<li>减少了线程上下文切换</li>\n</ul>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"绑定-Channel-事件\"><a href=\"#绑定-Channel-事件\" class=\"headerlink\" title=\"绑定 Channel 事件\"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>channel 必须工作在非阻塞模式</li>\n<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>\n<li>绑定的事件类型可以有<ul>\n<li>connect - 客户端连接成功时触发</li>\n<li>accept - 服务器端成功接受连接时触发</li>\n<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>\n<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"监听-Channel-事件\"><a href=\"#监听-Channel-事件\" class=\"headerlink\" title=\"监听 Channel 事件\"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>\n<p>方法1，阻塞直到绑定事件发生</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select(<span class=\"type\">long</span> timeout);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-select-何时不阻塞\"><a href=\"#💡-select-何时不阻塞\" class=\"headerlink\" title=\"💡 select 何时不阻塞\"></a>💡 select 何时不阻塞</h4><blockquote>\n<ul>\n<li>事件发生时<ul>\n<li>客户端发起连接请求，会触发 accept 事件</li>\n<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>\n<li>channel 可写，会触发 write 事件</li>\n<li>在 linux 下 nio bug 发生时</li>\n</ul>\n</li>\n<li>调用 selector.wakeup()</li>\n<li>调用 selector.close()</li>\n<li>selector 所在线程 interrupt</li>\n</ul>\n</blockquote>\n<h3 id=\"4-3-处理-accept-事件\"><a href=\"#4-3-处理-accept-事件\" class=\"headerlink\" title=\"4.3 处理 accept 事件\"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>)) &#123;</span><br><span class=\"line\">            System.out.println(socket);</span><br><span class=\"line\">            socket.getOutputStream().write(<span class=\"string\">&quot;world&quot;</span>.getBytes());</span><br><span class=\"line\">            System.in.read();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务器端代码为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo6</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> ServerSocketChannel.open()) &#123;</span><br><span class=\"line\">            channel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">            System.out.println(channel);</span><br><span class=\"line\">            <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">            channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"><span class=\"comment\">//                int count = selector.selectNow();</span></span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\"><span class=\"comment\">//                if(count &lt;= 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    continue;</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 获取所有事件</span></span><br><span class=\"line\">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 遍历所有事件，逐一处理</span></span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                    <span class=\"comment\">// 判断事件类型</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"comment\">// 必须处理</span></span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">                    iter.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-事件发生后能否不处理\"><a href=\"#💡-事件发生后能否不处理\" class=\"headerlink\" title=\"💡 事件发生后能否不处理\"></a>💡 事件发生后能否不处理</h4><blockquote>\n<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>\n</blockquote>\n<h3 id=\"4-4-处理-read-事件\"><a href=\"#4-4-处理-read-事件\" class=\"headerlink\" title=\"4.4 处理 read 事件\"></a>4.4 处理 read 事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo6</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> ServerSocketChannel.open()) &#123;</span><br><span class=\"line\">            channel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">            System.out.println(channel);</span><br><span class=\"line\">            <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">            channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"><span class=\"comment\">//                int count = selector.selectNow();</span></span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\"><span class=\"comment\">//                if(count &lt;= 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    continue;</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 获取所有事件</span></span><br><span class=\"line\">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 遍历所有事件，逐一处理</span></span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                    <span class=\"comment\">// 判断事件类型</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"comment\">// 必须处理</span></span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                        sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                        log.debug(<span class=\"string\">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> sc.read(buffer);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            sc.close();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            debug(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">                    iter.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开启两个客户端，修改一下发送文字，输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-为何要-iter-remove\"><a href=\"#💡-为何要-iter-remove\" class=\"headerlink\" title=\"💡 为何要 iter.remove()\"></a>💡 为何要 iter.remove()</h4><blockquote>\n<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>\n<ul>\n<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>\n<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>\n</ul>\n</blockquote>\n<h4 id=\"💡-cancel-的作用\"><a href=\"#💡-cancel-的作用\" class=\"headerlink\" title=\"💡 cancel 的作用\"></a>💡 cancel 的作用</h4><blockquote>\n<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>\n</blockquote>\n<h4 id=\"⚠️-不处理边界的问题\"><a href=\"#⚠️-不处理边界的问题\" class=\"headerlink\" title=\"⚠️  不处理边界的问题\"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        ServerSocket ss=<span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">9000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> s.getInputStream();</span><br><span class=\"line\">            <span class=\"comment\">// 这里这么写，有没有问题</span></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> in.read(arr);</span><br><span class=\"line\">                <span class=\"comment\">// 这里这么写，有没有问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr, <span class=\"number\">0</span>, read));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9000</span>);</span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> max.getOutputStream();</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;hello&quot;</span>.getBytes());</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;world&quot;</span>.getBytes());</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;你好&quot;</span>.getBytes());</span><br><span class=\"line\">        max.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hell</span><br><span class=\"line\">owor</span><br><span class=\"line\">ld�</span><br><span class=\"line\">�好</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>为什么？</p>\n<h4 id=\"处理消息的边界\"><a href=\"#处理消息的边界\" class=\"headerlink\" title=\"处理消息的边界\"></a>处理消息的边界</h4><p><img src=\"/img/0023.png\"></p>\n<ul>\n<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>\n<li>另一种思路是按分隔符拆分，缺点是效率低</li>\n<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>\n<li>Http 1.1 是 TLV 格式</li>\n<li>Http 2.0 是 LTV 格式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram </span><br><span class=\"line\">participant c1 as 客户端1</span><br><span class=\"line\">participant s as 服务器</span><br><span class=\"line\">participant b1 as ByteBuffer1</span><br><span class=\"line\">participant b2 as ByteBuffer2</span><br><span class=\"line\">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\\r</span><br><span class=\"line\">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class=\"line\">s -&gt;&gt; b2: 扩容</span><br><span class=\"line\">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class=\"line\">s -&gt;&gt; b2: 第二次 read 存入 3333\\r</span><br><span class=\"line\">b2 -&gt;&gt; b2: 01234567890abcdef3333\\r</span><br></pre></td></tr></table></figure>\n\n<p>服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">split</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">    source.flip();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到一条完整消息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span> - source.position();</span><br><span class=\"line\">            <span class=\"comment\">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(length);</span><br><span class=\"line\">            <span class=\"comment\">// 从 source 读，向 target 写</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">                target.put(source.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            debugAll(target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    source.compact(); <span class=\"comment\">// 0123456789abcdef  position 16 limit 16</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建 selector, 管理多个 channel</span></span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">    <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">    ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class=\"line\">    <span class=\"comment\">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sscKey</span> <span class=\"operator\">=</span> ssc.register(selector, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// key 只关注 accept 事件</span></span><br><span class=\"line\">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class=\"line\">    ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class=\"line\">        <span class=\"comment\">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\">        <span class=\"comment\">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class=\"comment\">// accept, read</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">            <span class=\"comment\">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class=\"line\">            iter.remove();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class=\"line\">            <span class=\"comment\">// 5. 区分事件类型</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123; <span class=\"comment\">// 如果是 accept</span></span><br><span class=\"line\">                <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> channel.accept();</span><br><span class=\"line\">                sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>); <span class=\"comment\">// attachment</span></span><br><span class=\"line\">                <span class=\"comment\">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">scKey</span> <span class=\"operator\">=</span> sc.register(selector, <span class=\"number\">0</span>, buffer);</span><br><span class=\"line\">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123; <span class=\"comment\">// 如果是 read</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel(); <span class=\"comment\">// 拿到触发事件的channel</span></span><br><span class=\"line\">                    <span class=\"comment\">// 获取 selectionKey 上关联的附件</span></span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer); <span class=\"comment\">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        split(buffer);</span><br><span class=\"line\">                        <span class=\"comment\">// 需要扩容</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">newBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(buffer.capacity() * <span class=\"number\">2</span>);</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            newBuffer.put(buffer); <span class=\"comment\">// 0123456789abcdef3333\\n</span></span><br><span class=\"line\">                            key.attach(newBuffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    key.cancel();  <span class=\"comment\">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"type\">SocketAddress</span> <span class=\"variable\">address</span> <span class=\"operator\">=</span> sc.getLocalAddress();</span><br><span class=\"line\"><span class=\"comment\">// sc.write(Charset.defaultCharset().encode(&quot;hello\\nworld\\n&quot;));</span></span><br><span class=\"line\">sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;0123\\n456789abcdef&quot;</span>));</span><br><span class=\"line\">sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;0123456789abcdef3333\\n&quot;</span>));</span><br><span class=\"line\">System.in.read();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"ByteBuffer-大小分配\"><a href=\"#ByteBuffer-大小分配\" class=\"headerlink\" title=\"ByteBuffer 大小分配\"></a>ByteBuffer 大小分配</h4><ul>\n<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>\n<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>\n<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href=\"http://tutorials.jenkov.com/java-performance/resizable-array.html\">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>\n<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-处理-write-事件\"><a href=\"#4-5-处理-write-事件\" class=\"headerlink\" title=\"4.5 处理 write 事件\"></a>4.5 处理 write 事件</h3><h4 id=\"一次无法写完例子\"><a href=\"#一次无法写完例子\" class=\"headerlink\" title=\"一次无法写完例子\"></a>一次无法写完例子</h4><ul>\n<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>\n<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>\n<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>\n<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>\n<li>如果不取消，会每次可写均会触发 write 事件</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                iter.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sckey</span> <span class=\"operator\">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    <span class=\"comment\">// 1. 向客户端发送内容</span></span><br><span class=\"line\">                    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3000000</span>; i++) &#123;</span><br><span class=\"line\">                        sb.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> sc.write(buffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 3. write 表示实际写了多少字节</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;实际写入字节:&quot;</span> + write);</span><br><span class=\"line\">                    <span class=\"comment\">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read 1  write 4</span></span><br><span class=\"line\">                        <span class=\"comment\">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class=\"line\">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class=\"line\">                        <span class=\"comment\">// 把 buffer 作为附件加入 sckey</span></span><br><span class=\"line\">                        sckey.attach(buffer);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> sc.write(buffer);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;实际写入字节:&quot;</span> + write);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!buffer.hasRemaining()) &#123; <span class=\"comment\">// 写完了</span></span><br><span class=\"line\">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class=\"line\">                        key.attach(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">        sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class=\"line\">        sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            selector.select();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                iter.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                    System.out.println(sc.finishConnect());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    count += sc.read(buffer);</span><br><span class=\"line\">                    buffer.clear();</span><br><span class=\"line\">                    System.out.println(count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-write-为何要取消\"><a href=\"#💡-write-为何要取消\" class=\"headerlink\" title=\"💡 write 为何要取消\"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>\n<h3 id=\"4-6-更进一步\"><a href=\"#4-6-更进一步\" class=\"headerlink\" title=\"4.6 更进一步\"></a>4.6 更进一步</h3><h4 id=\"💡-利用多线程优化\"><a href=\"#💡-利用多线程优化\" class=\"headerlink\" title=\"💡 利用多线程优化\"></a>💡 利用多线程优化</h4><blockquote>\n<p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>\n</blockquote>\n<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>\n<p>分两组选择器</p>\n<ul>\n<li>单线程配一个选择器，专门处理 accept 事件</li>\n<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo7</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">BossEventLoop</span>().register();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Slf4j</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BossEventLoop</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector boss;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WorkerEventLoop[] workers;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!start) &#123;</span><br><span class=\"line\">                <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">                ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">                ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                boss = Selector.open();</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">ssckey</span> <span class=\"operator\">=</span> ssc.register(boss, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">                workers = initEventLoops();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;boss&quot;</span>).start();</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;boss start...&quot;</span>);</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class=\"line\"><span class=\"comment\">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class=\"line\">            WorkerEventLoop[] workerEventLoops = <span class=\"keyword\">new</span> <span class=\"title class_\">WorkerEventLoop</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class=\"line\">                workerEventLoops[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">WorkerEventLoop</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> workerEventLoops;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    boss.select();</span><br><span class=\"line\">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                        iter.remove();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                            sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class=\"line\">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Slf4j</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkerEventLoop</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector worker;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">WorkerEventLoop</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.index = index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!start) &#123;</span><br><span class=\"line\">                worker = Selector.open();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;worker-&quot;</span> + index).start();</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tasks.add(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sckey</span> <span class=\"operator\">=</span> sc.register(worker, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                    worker.selectNow();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            worker.wakeup();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    worker.select();</span><br><span class=\"line\">                    <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> tasks.poll();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (task != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class=\"line\">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> sc.read(buffer);</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                    key.cancel();</span><br><span class=\"line\">                                    sc.close();</span><br><span class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                    buffer.flip();</span><br><span class=\"line\">                                    log.debug(<span class=\"string\">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class=\"line\">                                    debugAll(buffer);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                                e.printStackTrace();</span><br><span class=\"line\">                                key.cancel();</span><br><span class=\"line\">                                sc.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        iter.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-如何拿到-cpu-个数\"><a href=\"#💡-如何拿到-cpu-个数\" class=\"headerlink\" title=\"💡 如何拿到 cpu 个数\"></a>💡 如何拿到 cpu 个数</h4><blockquote>\n<ul>\n<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>\n<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>\n</ul>\n</blockquote>\n<h3 id=\"4-7-UDP\"><a href=\"#4-7-UDP\" class=\"headerlink\" title=\"4.7 UDP\"></a>4.7 UDP</h3><ul>\n<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>\n<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>\n</ul>\n<p>首先启动服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UdpServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">DatagramChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> DatagramChannel.open()) &#123;</span><br><span class=\"line\">            channel.socket().bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">9999</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">32</span>);</span><br><span class=\"line\">            channel.receive(buffer);</span><br><span class=\"line\">            buffer.flip();</span><br><span class=\"line\">            debug(buffer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">waiting...</span><br></pre></td></tr></table></figure>\n\n\n\n<p>运行客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UdpClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">DatagramChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> DatagramChannel.open()) &#123;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">InetSocketAddress</span> <span class=\"variable\">address</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9999</span>);</span><br><span class=\"line\">            channel.send(buffer, address);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来服务器端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"5-NIO-vs-BIO\"><a href=\"#5-NIO-vs-BIO\" class=\"headerlink\" title=\"5. NIO vs BIO\"></a>5. NIO vs BIO</h2><h3 id=\"5-1-stream-vs-channel\"><a href=\"#5-1-stream-vs-channel\" class=\"headerlink\" title=\"5.1 stream vs channel\"></a>5.1 stream vs channel</h3><ul>\n<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>\n<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>\n<li>二者均为全双工，即读写可以同时进行</li>\n</ul>\n<h3 id=\"5-2-IO-模型\"><a href=\"#5-2-IO-模型\" class=\"headerlink\" title=\"5.2 IO 模型\"></a>5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>\n<ul>\n<li>同步：线程自己去获取结果（一个线程）</li>\n<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>\n</ul>\n<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>\n<ul>\n<li>等待数据阶段</li>\n<li>复制数据阶段</li>\n</ul>\n<p><img src=\"/img/0033.png\"></p>\n<ul>\n<li><p>阻塞 IO</p>\n<p><img src=\"/img/0039.png\"></p>\n</li>\n<li><p>非阻塞  IO</p>\n<p><img src=\"/img/0035.png\"></p>\n</li>\n<li><p>多路复用</p>\n<p><img src=\"/img/0038.png\"></p>\n</li>\n<li><p>信号驱动</p>\n</li>\n<li><p>异步 IO</p>\n<p><img src=\"/img/0037.png\"></p>\n</li>\n<li><p>阻塞 IO vs 多路复用</p>\n<p><img src=\"/img/0034.png\"></p>\n<p><img src=\"/img/0036.png\"></p>\n</li>\n</ul>\n<h4 id=\"🔖-参考\"><a href=\"#🔖-参考\" class=\"headerlink\" title=\"🔖 参考\"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>\n<h3 id=\"5-3-零拷贝\"><a href=\"#5-3-零拷贝\" class=\"headerlink\" title=\"5.3 零拷贝\"></a>5.3 零拷贝</h3><h4 id=\"传统-IO-问题\"><a href=\"#传统-IO-问题\" class=\"headerlink\" title=\"传统 IO 问题\"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[(<span class=\"type\">int</span>)f.length()];</span><br><span class=\"line\">file.read(buf);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>\n\n<p>内部工作流程是这样的：</p>\n<p><img src=\"/img/0024.png\"></p>\n<ol>\n<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>\n<blockquote>\n<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>\n</blockquote>\n</li>\n<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>\n</li>\n<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>\n</li>\n<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>\n</li>\n</ol>\n<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>\n<ul>\n<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>\n<li>数据拷贝了共 4 次</li>\n</ul>\n<h4 id=\"NIO-优化\"><a href=\"#NIO-优化\" class=\"headerlink\" title=\"NIO 优化\"></a>NIO 优化</h4><p>通过 DirectByteBuf </p>\n<ul>\n<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>\n<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>\n</ul>\n<p><img src=\"/img/0025.png\"></p>\n<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>\n<ul>\n<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>\n<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>\n<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>\n<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>\n</ul>\n</li>\n<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>\n</ul>\n<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo&#x2F;transferFrom 方法拷贝数据</p>\n<p><img src=\"/img/0026.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>\n<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>可以看到</p>\n<ul>\n<li>只发生了一次用户态与内核态的切换</li>\n<li>数据拷贝了 3 次</li>\n</ul>\n<p>进一步优化（linux 2.4）</p>\n<p><img src=\"/img/0027.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>\n<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>\n<ul>\n<li>更少的用户态与内核态的切换</li>\n<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>\n<li>零拷贝适合小文件传输</li>\n</ul>\n<h3 id=\"5-3-AIO\"><a href=\"#5-3-AIO\" class=\"headerlink\" title=\"5.3 AIO\"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>\n<ul>\n<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>\n<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>\n</ul>\n<blockquote>\n<p>异步模型需要底层操作系统（Kernel）提供支持</p>\n<ul>\n<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>\n<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>\n</ul>\n</blockquote>\n<h4 id=\"文件-AIO\"><a href=\"#文件-AIO\" class=\"headerlink\" title=\"文件 AIO\"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioDemo1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"type\">AsynchronousFileChannel</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">                AsynchronousFileChannel.open(</span><br><span class=\"line\">                \tPaths.get(<span class=\"string\">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">2</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">            s.read(buffer, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class=\"line\">                    buffer.flip();</span><br><span class=\"line\">                    debug(buffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read failed...&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;do other things...&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class=\"line\">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class=\"line\">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 0d                                           |a.              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>可以看到</p>\n<ul>\n<li>响应文件读取成功的是另一个线程 Thread-5</li>\n<li>主线程并没有 IO 操作阻塞</li>\n</ul>\n<h4 id=\"💡-守护线程\"><a href=\"#💡-守护线程\" class=\"headerlink\" title=\"💡 守护线程\"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>\n<h4 id=\"网络-AIO\"><a href=\"#网络-AIO\" class=\"headerlink\" title=\"网络 AIO\"></a>网络 AIO</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">AsynchronousServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> AsynchronousServerSocketChannel.open();</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        ssc.accept(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">AcceptHandler</span>(ssc));</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">closeChannel</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;[%s] %s close\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            sc.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReadHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ReadHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    closeChannel(sc);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s read\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">                attachment.flip();</span><br><span class=\"line\">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class=\"line\">                attachment.clear();</span><br><span class=\"line\">                <span class=\"comment\">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class=\"line\">                sc.read(attachment, attachment, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"title function_\">WriteHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attachment.hasRemaining()) &#123;</span><br><span class=\"line\">                sc.write(attachment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AcceptHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">AcceptHandler</span><span class=\"params\">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.ssc = ssc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s connected\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 读事件由 ReadHandler 处理</span></span><br><span class=\"line\">            sc.read(buffer, buffer, <span class=\"keyword\">new</span> <span class=\"title class_\">ReadHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 写事件由 WriteHandler 处理</span></span><br><span class=\"line\">            sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class=\"number\">16</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">WriteHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class=\"line\">            ssc.accept(<span class=\"literal\">null</span>, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, Object attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>该笔记是B站黑马的Netty视频的配套笔记1。</p>","more":"<h1 id=\"一-NIO-基础\"><a href=\"#一-NIO-基础\" class=\"headerlink\" title=\"一. NIO 基础\"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p>\n<h2 id=\"1-三大组件\"><a href=\"#1-三大组件\" class=\"headerlink\" title=\"1. 三大组件\"></a>1. 三大组件</h2><h3 id=\"1-1-Channel-amp-Buffer\"><a href=\"#1-1-Channel-amp-Buffer\" class=\"headerlink\" title=\"1.1 Channel &amp; Buffer\"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">channel --&gt; buffer</span><br><span class=\"line\">buffer --&gt; channel</span><br></pre></td></tr></table></figure>\n\n<p>常见的 Channel 有</p>\n<ul>\n<li>FileChannel</li>\n<li>DatagramChannel</li>\n<li>SocketChannel</li>\n<li>ServerSocketChannel</li>\n</ul>\n<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>\n<ul>\n<li>ByteBuffer<ul>\n<li>MappedByteBuffer</li>\n<li>DirectByteBuffer</li>\n<li>HeapByteBuffer</li>\n</ul>\n</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>CharBuffer</li>\n</ul>\n<h3 id=\"1-2-Selector\"><a href=\"#1-2-Selector\" class=\"headerlink\" title=\"1.2 Selector\"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>\n<h4 id=\"多线程版设计\"><a href=\"#多线程版设计\" class=\"headerlink\" title=\"多线程版设计\"></a>多线程版设计</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 多线程版</span><br><span class=\"line\">t1(thread) --&gt; s1(socket1)</span><br><span class=\"line\">t2(thread) --&gt; s2(socket2)</span><br><span class=\"line\">t3(thread) --&gt; s3(socket3)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"⚠️-多线程版缺点\"><a href=\"#⚠️-多线程版缺点\" class=\"headerlink\" title=\"⚠️ 多线程版缺点\"></a>⚠️ 多线程版缺点</h4><ul>\n<li>内存占用高</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景</li>\n</ul>\n<h4 id=\"线程池版设计\"><a href=\"#线程池版设计\" class=\"headerlink\" title=\"线程池版设计\"></a>线程池版设计</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph 线程池版</span><br><span class=\"line\">t4(thread) --&gt; s4(socket1)</span><br><span class=\"line\">t5(thread) --&gt; s5(socket2)</span><br><span class=\"line\">t4(thread) -.-&gt; s6(socket3)</span><br><span class=\"line\">t5(thread) -.-&gt; s7(socket4)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h4 id=\"⚠️-线程池版缺点\"><a href=\"#⚠️-线程池版缺点\" class=\"headerlink\" title=\"⚠️ 线程池版缺点\"></a>⚠️ 线程池版缺点</h4><ul>\n<li>阻塞模式下，线程仅能处理一个 socket 连接</li>\n<li>仅适合短连接场景</li>\n</ul>\n<h4 id=\"selector-版设计\"><a href=\"#selector-版设计\" class=\"headerlink\" title=\"selector 版设计\"></a>selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph selector 版</span><br><span class=\"line\">thread --&gt; selector</span><br><span class=\"line\">selector --&gt; c1(channel)</span><br><span class=\"line\">selector --&gt; c2(channel)</span><br><span class=\"line\">selector --&gt; c3(channel)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p>\n<h2 id=\"2-ByteBuffer\"><a href=\"#2-ByteBuffer\" class=\"headerlink\" title=\"2. ByteBuffer\"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1234567890abcd</span><br></pre></td></tr></table></figure>\n\n<p>使用 FileChannel 来读取文件内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/data.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 向 buffer 写入</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 切换 buffer 读模式</span></span><br><span class=\"line\">                buffer.flip();</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(buffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, (<span class=\"type\">char</span>)buffer.get());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 切换 buffer 写模式</span></span><br><span class=\"line\">                buffer.clear();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class=\"line\">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-1-ByteBuffer-正确使用姿势\"><a href=\"#2-1-ByteBuffer-正确使用姿势\" class=\"headerlink\" title=\"2.1  ByteBuffer 正确使用姿势\"></a>2.1  ByteBuffer 正确使用姿势</h3><ol>\n<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>\n<li>调用 flip() 切换至<strong>读模式</strong></li>\n<li>从 buffer 读取数据，例如调用 buffer.get()</li>\n<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>\n<li>重复 1~4 步骤</li>\n</ol>\n<h3 id=\"2-2-ByteBuffer-结构\"><a href=\"#2-2-ByteBuffer-结构\" class=\"headerlink\" title=\"2.2 ByteBuffer 结构\"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>\n<ul>\n<li>capacity</li>\n<li>position</li>\n<li>limit</li>\n</ul>\n<p>一开始</p>\n<p><img src=\"/img/0021.png\"></p>\n<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>\n<p><img src=\"/img/0018.png\"></p>\n<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>\n<p><img src=\"/img/0019.png\"></p>\n<p>读取 4 个字节后，状态</p>\n<p><img src=\"/img/0020.png\"></p>\n<p>clear 动作发生后，状态</p>\n<p><img src=\"/img/0021.png\"></p>\n<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>\n<p><img src=\"/img/0022.png\"></p>\n<h4 id=\"💡-调试工具类\"><a href=\"#💡-调试工具类\" class=\"headerlink\" title=\"💡 调试工具类\"></a>💡 调试工具类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ByteBufferUtil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] BYTE2CHAR = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] HEXDUMP_TABLE = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">256</span> * <span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] HEXPADDING = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] HEXDUMP_ROWPREFIXES = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">65536</span> &gt;&gt;&gt; <span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] BYTE2HEX = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String[] BYTEPADDING = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] DIGITS = <span class=\"string\">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++) &#123;</span><br><span class=\"line\">            HEXDUMP_TABLE[i &lt;&lt; <span class=\"number\">1</span>] = DIGITS[i &gt;&gt;&gt; <span class=\"number\">4</span> &amp; <span class=\"number\">0x0F</span>];</span><br><span class=\"line\">            HEXDUMP_TABLE[(i &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>] = DIGITS[i &amp; <span class=\"number\">0x0F</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for hex dump paddings</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">padding</span> <span class=\"operator\">=</span> HEXPADDING.length - i;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(padding * <span class=\"number\">3</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; padding; j++) &#123;</span><br><span class=\"line\">                buf.append(<span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            HEXPADDING[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">12</span>);</span><br><span class=\"line\">            buf.append(NEWLINE);</span><br><span class=\"line\">            buf.append(Long.toHexString(i &lt;&lt; <span class=\"number\">4</span> &amp; <span class=\"number\">0xFFFFFFFFL</span> | <span class=\"number\">0x100000000L</span>));</span><br><span class=\"line\">            buf.setCharAt(buf.length() - <span class=\"number\">9</span>, <span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            buf.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class=\"line\">            BYTE2HEX[i] = <span class=\"string\">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte dump paddings</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">padding</span> <span class=\"operator\">=</span> BYTEPADDING.length - i;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(padding);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; padding; j++) &#123;</span><br><span class=\"line\">                buf.append(<span class=\"string\">&#x27; &#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            BYTEPADDING[i] = buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Generate the lookup table for byte-to-char conversion</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &lt;= <span class=\"number\">0x1f</span> || i &gt;= <span class=\"number\">0x7f</span>) &#123;</span><br><span class=\"line\">                BYTE2CHAR[i] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                BYTE2CHAR[i] = (<span class=\"type\">char</span>) i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 打印所有内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">debugAll</span><span class=\"params\">(ByteBuffer buffer)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">oldlimit</span> <span class=\"operator\">=</span> buffer.limit();</span><br><span class=\"line\">        buffer.limit(buffer.capacity());</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">origin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">256</span>);</span><br><span class=\"line\">        appendPrettyHexDump(origin, buffer, <span class=\"number\">0</span>, buffer.capacity());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;position: [%d], limit: [%d]\\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class=\"line\">        System.out.println(origin);</span><br><span class=\"line\">        buffer.limit(oldlimit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 打印可读取内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> buffer</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">debugRead</span><span class=\"params\">(ByteBuffer buffer)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">builder</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"number\">256</span>);</span><br><span class=\"line\">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;position: [%d], limit: [%d]\\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class=\"line\">        System.out.println(builder);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">appendPrettyHexDump</span><span class=\"params\">(StringBuilder dump, ByteBuffer buf, <span class=\"type\">int</span> offset, <span class=\"type\">int</span> length)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IndexOutOfBoundsException</span>(</span><br><span class=\"line\">                    <span class=\"string\">&quot;expected: &quot;</span> + <span class=\"string\">&quot;0 &lt;= offset(&quot;</span> + offset + <span class=\"string\">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class=\"line\">                            + <span class=\"string\">&quot;) &lt;= &quot;</span> + <span class=\"string\">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dump.append(</span><br><span class=\"line\">                <span class=\"string\">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class=\"line\">                        NEWLINE + <span class=\"string\">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class=\"line\">                        NEWLINE + <span class=\"string\">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">startIndex</span> <span class=\"operator\">=</span> offset;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">fullRows</span> <span class=\"operator\">=</span> length &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">remainder</span> <span class=\"operator\">=</span> length &amp; <span class=\"number\">0xF</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Dump the rows which have 16 bytes.</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">row</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowStartIndex</span> <span class=\"operator\">=</span> (row &lt;&lt; <span class=\"number\">4</span>) + startIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Per-row prefix.</span></span><br><span class=\"line\">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Hex dump</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowEndIndex</span> <span class=\"operator\">=</span> rowStartIndex + <span class=\"number\">16</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(<span class=\"string\">&quot; |&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// ASCII dump</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Dump the last row which has less than 16 bytes.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainder != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowStartIndex</span> <span class=\"operator\">=</span> (fullRows &lt;&lt; <span class=\"number\">4</span>) + startIndex;</span><br><span class=\"line\">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Hex dump</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rowEndIndex</span> <span class=\"operator\">=</span> rowStartIndex + remainder;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(HEXPADDING[remainder]);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&quot; |&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Ascii dump</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class=\"line\">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dump.append(BYTEPADDING[remainder]);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        dump.append(NEWLINE +</span><br><span class=\"line\">                <span class=\"string\">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">appendHexDumpRowPrefix</span><span class=\"params\">(StringBuilder dump, <span class=\"type\">int</span> row, <span class=\"type\">int</span> rowStartIndex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class=\"line\">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            dump.append(NEWLINE);</span><br><span class=\"line\">            dump.append(Long.toHexString(rowStartIndex &amp; <span class=\"number\">0xFFFFFFFFL</span> | <span class=\"number\">0x100000000L</span>));</span><br><span class=\"line\">            dump.setCharAt(dump.length() - <span class=\"number\">9</span>, <span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">            dump.append(<span class=\"string\">&#x27;|&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">short</span> <span class=\"title function_\">getUnsignedByte</span><span class=\"params\">(ByteBuffer buffer, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">short</span>) (buffer.get(index) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-ByteBuffer-常见方法\"><a href=\"#2-3-ByteBuffer-常见方法\" class=\"headerlink\" title=\"2.3 ByteBuffer 常见方法\"></a>2.3 ByteBuffer 常见方法</h3><h4 id=\"分配空间\"><a href=\"#分配空间\" class=\"headerlink\" title=\"分配空间\"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Bytebuffer</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"向-buffer-写入数据\"><a href=\"#向-buffer-写入数据\" class=\"headerlink\" title=\"向 buffer 写入数据\"></a>向 buffer 写入数据</h4><p>有两种办法</p>\n<ul>\n<li>调用 channel 的 read 方法</li>\n<li>调用 buffer 自己的 put 方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">readBytes</span> <span class=\"operator\">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure>\n\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf.put((<span class=\"type\">byte</span>)<span class=\"number\">127</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"从-buffer-读取数据\"><a href=\"#从-buffer-读取数据\" class=\"headerlink\" title=\"从 buffer 读取数据\"></a>从 buffer 读取数据</h4><p>同样有两种办法</p>\n<ul>\n<li>调用 channel 的 write 方法</li>\n<li>调用 buffer 自己的 get 方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">writeBytes</span> <span class=\"operator\">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure>\n\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">byte</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> buf.get();</span><br></pre></td></tr></table></figure>\n\n<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>\n<ul>\n<li>可以调用 rewind 方法将 position 重新置为 0</li>\n<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>\n</ul>\n<h4 id=\"mark-和-reset\"><a href=\"#mark-和-reset\" class=\"headerlink\" title=\"mark 和 reset\"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>\n<blockquote>\n<p><strong>注意</strong></p>\n<p>rewind 和 flip 都会清除 mark 位置</p>\n</blockquote>\n<h4 id=\"字符串与-ByteBuffer-互转\"><a href=\"#字符串与-ByteBuffer-互转\" class=\"headerlink\" title=\"字符串与 ByteBuffer 互转\"></a>字符串与 ByteBuffer 互转</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer1</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;你好&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer2</span> <span class=\"operator\">=</span> Charset.forName(<span class=\"string\">&quot;utf-8&quot;</span>).encode(<span class=\"string\">&quot;你好&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">debug(buffer1);</span><br><span class=\"line\">debug(buffer2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">CharBuffer</span> <span class=\"variable\">buffer3</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class=\"line\">System.out.println(buffer3.getClass());</span><br><span class=\"line\">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">class java.nio.HeapCharBuffer</span><br><span class=\"line\">你好</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-Buffer-的线程安全\"><a href=\"#⚠️-Buffer-的线程安全\" class=\"headerlink\" title=\"⚠️ Buffer 的线程安全\"></a>⚠️ Buffer 的线程安全</h4><blockquote>\n<p>Buffer 是<strong>非线程安全的</strong></p>\n</blockquote>\n<h3 id=\"2-4-Scattering-Reads\"><a href=\"#2-4-Scattering-Reads\" class=\"headerlink\" title=\"2.4 Scattering Reads\"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onetwothree</span><br></pre></td></tr></table></figure>\n\n<p>使用如下方式读取，可以将数据填充至多个 buffer</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/3parts.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">5</span>);</span><br><span class=\"line\">    channel.read(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;a, b, c&#125;);</span><br><span class=\"line\">    a.flip();</span><br><span class=\"line\">    b.flip();</span><br><span class=\"line\">    c.flip();</span><br><span class=\"line\">    debug(a);</span><br><span class=\"line\">    debug(b);</span><br><span class=\"line\">    debug(c);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6f 6e 65                                        |one             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 74 77 6f                                        |two             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-5-Gathering-Writes\"><a href=\"#2-5-Gathering-Writes\" class=\"headerlink\" title=\"2.5 Gathering Writes\"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(<span class=\"string\">&quot;helloword/3parts.txt&quot;</span>, <span class=\"string\">&quot;rw&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> file.getChannel();</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">4</span>);</span><br><span class=\"line\">    channel.position(<span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    d.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>&#125;);</span><br><span class=\"line\">    e.put(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"string\">&#x27;v&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>&#125;);</span><br><span class=\"line\">    d.flip();</span><br><span class=\"line\">    e.flip();</span><br><span class=\"line\">    debug(d);</span><br><span class=\"line\">    debug(e);</span><br><span class=\"line\">    channel.write(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 6f 75 72                                     |four            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 69 76 65                                     |five            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>文件内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onetwothreefourfive</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-6-练习\"><a href=\"#2-6-练习\" class=\"headerlink\" title=\"2.6 练习\"></a>2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>\n<ul>\n<li>Hello,world\\n</li>\n<li>I’m zhangsan\\n</li>\n<li>How are you?\\n</li>\n</ul>\n<p>变成了下面的两个 byteBuffer (黏包，半包)</p>\n<ul>\n<li>Hello,world\\nI’m zhangsan\\nHo</li>\n<li>w are you?\\n</li>\n</ul>\n<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \\n 分隔的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">32</span>);</span><br><span class=\"line\">    <span class=\"comment\">//                     11            24</span></span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;Hello,world\\nI&#x27;m zhangsan\\nHo&quot;</span>.getBytes());</span><br><span class=\"line\">    split(source);</span><br><span class=\"line\"></span><br><span class=\"line\">    source.put(<span class=\"string\">&quot;w are you?\\nhaha!\\n&quot;</span>.getBytes());</span><br><span class=\"line\">    split(source);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">split</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">    source.flip();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldLimit</span> <span class=\"operator\">=</span> source.limit();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(i + <span class=\"number\">1</span> - source.position());</span><br><span class=\"line\">            <span class=\"comment\">// 0 ~ limit</span></span><br><span class=\"line\">            source.limit(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            target.put(source); <span class=\"comment\">// 从source 读，向 target 写</span></span><br><span class=\"line\">            debugAll(target);</span><br><span class=\"line\">            source.limit(oldLimit);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    source.compact();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-文件编程\"><a href=\"#3-文件编程\" class=\"headerlink\" title=\"3. 文件编程\"></a>3. 文件编程</h2><h3 id=\"3-1-FileChannel\"><a href=\"#3-1-FileChannel\" class=\"headerlink\" title=\"3.1 FileChannel\"></a>3.1 FileChannel</h3><h4 id=\"⚠️-FileChannel-工作模式\"><a href=\"#⚠️-FileChannel-工作模式\" class=\"headerlink\" title=\"⚠️ FileChannel 工作模式\"></a>⚠️ FileChannel 工作模式</h4><blockquote>\n<p>FileChannel 只能工作在阻塞模式下</p>\n</blockquote>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel 只能读</li>\n<li>通过 FileOutputStream 获取的 channel 只能写</li>\n<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>\n</ul>\n<h4 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">readBytes</span> <span class=\"operator\">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">buffer.put(...); <span class=\"comment\">// 存入数据</span></span><br><span class=\"line\">buffer.flip();   <span class=\"comment\">// 切换读模式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(buffer.hasRemaining()) &#123;</span><br><span class=\"line\">    channel.write(buffer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>\n<h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>\n<h4 id=\"位置\"><a href=\"#位置\" class=\"headerlink\" title=\"位置\"></a>位置</h4><p>获取当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> channel.position();</span><br></pre></td></tr></table></figure>\n\n<p>设置当前位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">newPos</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">channel.position(newPos);</span><br></pre></td></tr></table></figure>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1 </li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h4 id=\"大小\"><a href=\"#大小\" class=\"headerlink\" title=\"大小\"></a>大小</h4><p>使用 size 方法获取文件的大小</p>\n<h4 id=\"强制写入\"><a href=\"#强制写入\" class=\"headerlink\" title=\"强制写入\"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>\n<h3 id=\"3-2-两个-Channel-传输数据\"><a href=\"#3-2-两个-Channel-传输数据\" class=\"headerlink\" title=\"3.2 两个 Channel 传输数据\"></a>3.2 两个 Channel 传输数据</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">FROM</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloword/data.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">TO</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;helloword/to.txt&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\"><span class=\"keyword\">try</span> (<span class=\"type\">FileChannel</span> <span class=\"variable\">from</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(FROM).getChannel();</span><br><span class=\"line\">     <span class=\"type\">FileChannel</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(TO).getChannel();</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">    from.transferTo(<span class=\"number\">0</span>, from.size(), to);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class=\"number\">1000_000.0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transferTo 用时：8.2011</span><br></pre></td></tr></table></figure>\n\n\n\n<p>超过 2g 大小的文件传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestFileChannelTransferTo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (</span><br><span class=\"line\">                <span class=\"type\">FileChannel</span> <span class=\"variable\">from</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;data.txt&quot;</span>).getChannel();</span><br><span class=\"line\">                <span class=\"type\">FileChannel</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;to.txt&quot;</span>).getChannel();</span><br><span class=\"line\">        ) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> from.size();</span><br><span class=\"line\">            <span class=\"comment\">// left 变量代表还剩余多少字节</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> size; left &gt; <span class=\"number\">0</span>; ) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;position:&quot;</span> + (size - left) + <span class=\"string\">&quot; left:&quot;</span> + left);</span><br><span class=\"line\">                left -= from.transferTo((size - left), left, to);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际传输一个超大文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position:0 left:7769948160</span><br><span class=\"line\">position:2147483647 left:5622464513</span><br><span class=\"line\">position:4294967294 left:3474980866</span><br><span class=\"line\">position:6442450941 left:1327497219</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-Path\"><a href=\"#3-3-Path\" class=\"headerlink\" title=\"3.3 Path\"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>\n<ul>\n<li>Path 用来表示文件路径</li>\n<li>Paths 是工具类，用来获取 Path 实例</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;1.txt&quot;</span>); <span class=\"comment\">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:/1.txt&quot;</span>); <span class=\"comment\">// 绝对路径 同样代表了  d:\\1.txt</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">projects</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data&quot;</span>, <span class=\"string\">&quot;projects&quot;</span>); <span class=\"comment\">// 代表了  d:\\data\\projects</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:</span><br><span class=\"line\">\t|- data</span><br><span class=\"line\">\t\t|- projects</span><br><span class=\"line\">\t\t\t|- a</span><br><span class=\"line\">\t\t\t|- b</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;</span>);</span><br><span class=\"line\">System.out.println(path);</span><br><span class=\"line\">System.out.println(path.normalize()); <span class=\"comment\">// 正常化路径</span></span><br></pre></td></tr></table></figure>\n\n<p>会输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d:\\data\\projects\\a\\..\\b</span><br><span class=\"line\">d:\\data\\projects\\b</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-Files\"><a href=\"#3-4-Files\" class=\"headerlink\" title=\"3.4 Files\"></a>3.4 Files</h3><p>检查文件是否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>\n\n\n\n<p>创建一级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1&quot;</span>);</span><br><span class=\"line\">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>\n<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>\n</ul>\n<p>创建多级目录用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1/d2&quot;</span>);</span><br><span class=\"line\">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>拷贝文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/target.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.copy(source, target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>\n</ul>\n<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>移动文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>\n</ul>\n<p>删除文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/target.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.delete(target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果文件不存在，会抛异常 NoSuchFileException</li>\n</ul>\n<p>删除目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;helloword/d1&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Files.delete(target);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>\n</ul>\n<p>遍历目录文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">AtomicInteger</span> <span class=\"variable\">dirCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">    <span class=\"type\">AtomicInteger</span> <span class=\"variable\">fileCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">    Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">preVisitDirectory</span><span class=\"params\">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            System.out.println(dir);</span><br><span class=\"line\">            dirCount.incrementAndGet();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.preVisitDirectory(dir, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">            <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            System.out.println(file);</span><br><span class=\"line\">            fileCount.incrementAndGet();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    System.out.println(dirCount); <span class=\"comment\">// 133</span></span><br><span class=\"line\">    System.out.println(fileCount); <span class=\"comment\">// 1479</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>统计 jar 的数目</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_91&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">AtomicInteger</span> <span class=\"variable\">fileCount</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\">Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.toFile().getName().endsWith(<span class=\"string\">&quot;.jar&quot;</span>)) &#123;</span><br><span class=\"line\">            fileCount.incrementAndGet();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">System.out.println(fileCount); <span class=\"comment\">// 724</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>删除多级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Path</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> Paths.get(<span class=\"string\">&quot;d:\\\\a&quot;</span>);</span><br><span class=\"line\">Files.walkFileTree(path, <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">visitFile</span><span class=\"params\">(Path file, BasicFileAttributes attrs)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        Files.delete(file);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.visitFile(file, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> FileVisitResult <span class=\"title function_\">postVisitDirectory</span><span class=\"params\">(Path dir, IOException exc)</span> </span><br><span class=\"line\">        <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        Files.delete(dir);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.postVisitDirectory(dir, exc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-删除很危险\"><a href=\"#⚠️-删除很危险\" class=\"headerlink\" title=\"⚠️ 删除很危险\"></a>⚠️ 删除很危险</h4><blockquote>\n<p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p>\n</blockquote>\n<p>拷贝多级目录</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">source</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;D:\\\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;D:\\\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">targetName</span> <span class=\"operator\">=</span> path.toString().replace(source, target);</span><br><span class=\"line\">        <span class=\"comment\">// 是目录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Files.isDirectory(path)) &#123;</span><br><span class=\"line\">            Files.createDirectory(Paths.get(targetName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 是普通文件</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class=\"line\">            Files.copy(path, Paths.get(targetName));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> System.currentTimeMillis();</span><br><span class=\"line\">System.out.println(end - start);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"4-网络编程\"><a href=\"#4-网络编程\" class=\"headerlink\" title=\"4. 网络编程\"></a>4. 网络编程</h2><h3 id=\"4-1-非阻塞-vs-阻塞\"><a href=\"#4-1-非阻塞-vs-阻塞\" class=\"headerlink\" title=\"4.1 非阻塞 vs 阻塞\"></a>4.1 非阻塞 vs 阻塞</h3><h4 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h4><ul>\n<li>阻塞模式下，相关方法都会导致线程暂停<ul>\n<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>\n<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>\n<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>\n</ul>\n</li>\n<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>\n<li>但多线程下，有新的问题，体现在以下方面<ul>\n<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>\n<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>\n</ul>\n</li>\n</ul>\n<p>服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class=\"line\"><span class=\"comment\">// 0. ByteBuffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建了服务器</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定监听端口</span></span><br><span class=\"line\">ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 连接集合</span></span><br><span class=\"line\">List&lt;SocketChannel&gt; channels = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;connecting...&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept(); <span class=\"comment\">// 阻塞方法，线程停止运行</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">    channels.add(sc);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SocketChannel channel : channels) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5. 接收客户端发送的数据</span></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        channel.read(buffer); <span class=\"comment\">// 阻塞方法，线程停止运行</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        debugRead(buffer);</span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h4><ul>\n<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>\n<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>\n<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>\n<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>\n</ul>\n</li>\n<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>\n<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>\n</ul>\n<p>服务器端，客户端代码不变</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class=\"line\"><span class=\"comment\">// 0. ByteBuffer</span></span><br><span class=\"line\"><span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建了服务器</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">ssc.configureBlocking(<span class=\"literal\">false</span>); <span class=\"comment\">// 非阻塞模式</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 绑定监听端口</span></span><br><span class=\"line\">ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"comment\">// 3. 连接集合</span></span><br><span class=\"line\">List&lt;SocketChannel&gt; channels = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class=\"line\">    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept(); <span class=\"comment\">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sc != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">        sc.configureBlocking(<span class=\"literal\">false</span>); <span class=\"comment\">// 非阻塞模式</span></span><br><span class=\"line\">        channels.add(sc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (SocketChannel channel : channels) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5. 接收客户端发送的数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer);<span class=\"comment\">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            buffer.flip();</span><br><span class=\"line\">            debugRead(buffer);</span><br><span class=\"line\">            buffer.clear();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多路复用\"><a href=\"#多路复用\" class=\"headerlink\" title=\"多路复用\"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>\n<ul>\n<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>\n<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>\n<li>有可连接事件时才去连接</li>\n<li>有可读事件才去读取</li>\n<li>有可写事件才去写入<ul>\n<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-2-Selector\"><a href=\"#4-2-Selector\" class=\"headerlink\" title=\"4.2 Selector\"></a>4.2 Selector</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">subgraph selector 版</span><br><span class=\"line\">thread --&gt; selector</span><br><span class=\"line\">selector --&gt; c1(channel)</span><br><span class=\"line\">selector --&gt; c2(channel)</span><br><span class=\"line\">selector --&gt; c3(channel)</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n\n\n<p>好处</p>\n<ul>\n<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>\n<li>让这个线程能够被充分利用</li>\n<li>节约了线程的数量</li>\n<li>减少了线程上下文切换</li>\n</ul>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"绑定-Channel-事件\"><a href=\"#绑定-Channel-事件\" class=\"headerlink\" title=\"绑定 Channel 事件\"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>channel 必须工作在非阻塞模式</li>\n<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>\n<li>绑定的事件类型可以有<ul>\n<li>connect - 客户端连接成功时触发</li>\n<li>accept - 服务器端成功接受连接时触发</li>\n<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>\n<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"监听-Channel-事件\"><a href=\"#监听-Channel-事件\" class=\"headerlink\" title=\"监听 Channel 事件\"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>\n<p>方法1，阻塞直到绑定事件发生</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br></pre></td></tr></table></figure>\n\n\n\n<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select(<span class=\"type\">long</span> timeout);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-select-何时不阻塞\"><a href=\"#💡-select-何时不阻塞\" class=\"headerlink\" title=\"💡 select 何时不阻塞\"></a>💡 select 何时不阻塞</h4><blockquote>\n<ul>\n<li>事件发生时<ul>\n<li>客户端发起连接请求，会触发 accept 事件</li>\n<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>\n<li>channel 可写，会触发 write 事件</li>\n<li>在 linux 下 nio bug 发生时</li>\n</ul>\n</li>\n<li>调用 selector.wakeup()</li>\n<li>调用 selector.close()</li>\n<li>selector 所在线程 interrupt</li>\n</ul>\n</blockquote>\n<h3 id=\"4-3-处理-accept-事件\"><a href=\"#4-3-处理-accept-事件\" class=\"headerlink\" title=\"4.3 处理 accept 事件\"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>)) &#123;</span><br><span class=\"line\">            System.out.println(socket);</span><br><span class=\"line\">            socket.getOutputStream().write(<span class=\"string\">&quot;world&quot;</span>.getBytes());</span><br><span class=\"line\">            System.in.read();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务器端代码为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo6</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> ServerSocketChannel.open()) &#123;</span><br><span class=\"line\">            channel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">            System.out.println(channel);</span><br><span class=\"line\">            <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">            channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"><span class=\"comment\">//                int count = selector.selectNow();</span></span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\"><span class=\"comment\">//                if(count &lt;= 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    continue;</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 获取所有事件</span></span><br><span class=\"line\">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 遍历所有事件，逐一处理</span></span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                    <span class=\"comment\">// 判断事件类型</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"comment\">// 必须处理</span></span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">                    iter.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-事件发生后能否不处理\"><a href=\"#💡-事件发生后能否不处理\" class=\"headerlink\" title=\"💡 事件发生后能否不处理\"></a>💡 事件发生后能否不处理</h4><blockquote>\n<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>\n</blockquote>\n<h3 id=\"4-4-处理-read-事件\"><a href=\"#4-4-处理-read-事件\" class=\"headerlink\" title=\"4.4 处理 read 事件\"></a>4.4 处理 read 事件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo6</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> ServerSocketChannel.open()) &#123;</span><br><span class=\"line\">            channel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">            System.out.println(channel);</span><br><span class=\"line\">            <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">            channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"><span class=\"comment\">//                int count = selector.selectNow();</span></span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class=\"line\"><span class=\"comment\">//                if(count &lt;= 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    continue;</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 获取所有事件</span></span><br><span class=\"line\">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 遍历所有事件，逐一处理</span></span><br><span class=\"line\">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                    <span class=\"comment\">// 判断事件类型</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"comment\">// 必须处理</span></span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                        sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                        log.debug(<span class=\"string\">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                        <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> sc.read(buffer);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            key.cancel();</span><br><span class=\"line\">                            sc.close();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            debug(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理完毕，必须将事件移除</span></span><br><span class=\"line\">                    iter.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开启两个客户端，修改一下发送文字，输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class=\"line\">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class=\"line\">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-为何要-iter-remove\"><a href=\"#💡-为何要-iter-remove\" class=\"headerlink\" title=\"💡 为何要 iter.remove()\"></a>💡 为何要 iter.remove()</h4><blockquote>\n<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>\n<ul>\n<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>\n<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>\n</ul>\n</blockquote>\n<h4 id=\"💡-cancel-的作用\"><a href=\"#💡-cancel-的作用\" class=\"headerlink\" title=\"💡 cancel 的作用\"></a>💡 cancel 的作用</h4><blockquote>\n<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>\n</blockquote>\n<h4 id=\"⚠️-不处理边界的问题\"><a href=\"#⚠️-不处理边界的问题\" class=\"headerlink\" title=\"⚠️  不处理边界的问题\"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        ServerSocket ss=<span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">9000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\">            <span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> s.getInputStream();</span><br><span class=\"line\">            <span class=\"comment\">// 这里这么写，有没有问题</span></span><br><span class=\"line\">            <span class=\"type\">byte</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> in.read(arr);</span><br><span class=\"line\">                <span class=\"comment\">// 这里这么写，有没有问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr, <span class=\"number\">0</span>, read));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9000</span>);</span><br><span class=\"line\">        <span class=\"type\">OutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> max.getOutputStream();</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;hello&quot;</span>.getBytes());</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;world&quot;</span>.getBytes());</span><br><span class=\"line\">        out.write(<span class=\"string\">&quot;你好&quot;</span>.getBytes());</span><br><span class=\"line\">        max.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hell</span><br><span class=\"line\">owor</span><br><span class=\"line\">ld�</span><br><span class=\"line\">�好</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>为什么？</p>\n<h4 id=\"处理消息的边界\"><a href=\"#处理消息的边界\" class=\"headerlink\" title=\"处理消息的边界\"></a>处理消息的边界</h4><p><img src=\"/img/0023.png\"></p>\n<ul>\n<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>\n<li>另一种思路是按分隔符拆分，缺点是效率低</li>\n<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>\n<li>Http 1.1 是 TLV 格式</li>\n<li>Http 2.0 是 LTV 格式</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram </span><br><span class=\"line\">participant c1 as 客户端1</span><br><span class=\"line\">participant s as 服务器</span><br><span class=\"line\">participant b1 as ByteBuffer1</span><br><span class=\"line\">participant b2 as ByteBuffer2</span><br><span class=\"line\">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\\r</span><br><span class=\"line\">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class=\"line\">s -&gt;&gt; b2: 扩容</span><br><span class=\"line\">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class=\"line\">s -&gt;&gt; b2: 第二次 read 存入 3333\\r</span><br><span class=\"line\">b2 -&gt;&gt; b2: 01234567890abcdef3333\\r</span><br></pre></td></tr></table></figure>\n\n<p>服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">split</span><span class=\"params\">(ByteBuffer source)</span> &#123;</span><br><span class=\"line\">    source.flip();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 找到一条完整消息</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source.get(i) == <span class=\"string\">&#x27;\\n&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span> - source.position();</span><br><span class=\"line\">            <span class=\"comment\">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> ByteBuffer.allocate(length);</span><br><span class=\"line\">            <span class=\"comment\">// 从 source 读，向 target 写</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; length; j++) &#123;</span><br><span class=\"line\">                target.put(source.get());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            debugAll(target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    source.compact(); <span class=\"comment\">// 0123456789abcdef  position 16 limit 16</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 创建 selector, 管理多个 channel</span></span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">    <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">    ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class=\"line\">    <span class=\"comment\">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sscKey</span> <span class=\"operator\">=</span> ssc.register(selector, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"comment\">// key 只关注 accept 事件</span></span><br><span class=\"line\">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class=\"line\">    ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class=\"line\">        <span class=\"comment\">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\">        <span class=\"comment\">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class=\"comment\">// accept, read</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">            <span class=\"comment\">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class=\"line\">            iter.remove();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class=\"line\">            <span class=\"comment\">// 5. 区分事件类型</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.isAcceptable()) &#123; <span class=\"comment\">// 如果是 accept</span></span><br><span class=\"line\">                <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> channel.accept();</span><br><span class=\"line\">                sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>); <span class=\"comment\">// attachment</span></span><br><span class=\"line\">                <span class=\"comment\">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">scKey</span> <span class=\"operator\">=</span> sc.register(selector, <span class=\"number\">0</span>, buffer);</span><br><span class=\"line\">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123; <span class=\"comment\">// 如果是 read</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> (SocketChannel) key.channel(); <span class=\"comment\">// 拿到触发事件的channel</span></span><br><span class=\"line\">                    <span class=\"comment\">// 获取 selectionKey 上关联的附件</span></span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> channel.read(buffer); <span class=\"comment\">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        key.cancel();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        split(buffer);</span><br><span class=\"line\">                        <span class=\"comment\">// 需要扩容</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">newBuffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(buffer.capacity() * <span class=\"number\">2</span>);</span><br><span class=\"line\">                            buffer.flip();</span><br><span class=\"line\">                            newBuffer.put(buffer); <span class=\"comment\">// 0123456789abcdef3333\\n</span></span><br><span class=\"line\">                            key.attach(newBuffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    key.cancel();  <span class=\"comment\">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\"><span class=\"type\">SocketAddress</span> <span class=\"variable\">address</span> <span class=\"operator\">=</span> sc.getLocalAddress();</span><br><span class=\"line\"><span class=\"comment\">// sc.write(Charset.defaultCharset().encode(&quot;hello\\nworld\\n&quot;));</span></span><br><span class=\"line\">sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;0123\\n456789abcdef&quot;</span>));</span><br><span class=\"line\">sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;0123456789abcdef3333\\n&quot;</span>));</span><br><span class=\"line\">System.in.read();</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"ByteBuffer-大小分配\"><a href=\"#ByteBuffer-大小分配\" class=\"headerlink\" title=\"ByteBuffer 大小分配\"></a>ByteBuffer 大小分配</h4><ul>\n<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>\n<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>\n<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href=\"http://tutorials.jenkov.com/java-performance/resizable-array.html\">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>\n<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-5-处理-write-事件\"><a href=\"#4-5-处理-write-事件\" class=\"headerlink\" title=\"4.5 处理 write 事件\"></a>4.5 处理 write 事件</h3><h4 id=\"一次无法写完例子\"><a href=\"#一次无法写完例子\" class=\"headerlink\" title=\"一次无法写完例子\"></a>一次无法写完例子</h4><ul>\n<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>\n<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>\n<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>\n<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>\n<li>如果不取消，会每次可写均会触发 write 事件</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteServer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">        ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                iter.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> ssc.accept();</span><br><span class=\"line\">                    sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sckey</span> <span class=\"operator\">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">                    <span class=\"comment\">// 1. 向客户端发送内容</span></span><br><span class=\"line\">                    <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">3000000</span>; i++) &#123;</span><br><span class=\"line\">                        sb.append(<span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> sc.write(buffer);</span><br><span class=\"line\">                    <span class=\"comment\">// 3. write 表示实际写了多少字节</span></span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;实际写入字节:&quot;</span> + write);</span><br><span class=\"line\">                    <span class=\"comment\">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (buffer.hasRemaining()) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// read 1  write 4</span></span><br><span class=\"line\">                        <span class=\"comment\">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class=\"line\">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class=\"line\">                        <span class=\"comment\">// 把 buffer 作为附件加入 sckey</span></span><br><span class=\"line\">                        sckey.attach(buffer);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuffer) key.attachment();</span><br><span class=\"line\">                    <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">write</span> <span class=\"operator\">=</span> sc.write(buffer);</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;实际写入字节:&quot;</span> + write);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!buffer.hasRemaining()) &#123; <span class=\"comment\">// 写完了</span></span><br><span class=\"line\">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class=\"line\">                        key.attach(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> SocketChannel.open();</span><br><span class=\"line\">        sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class=\"line\">        sc.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            selector.select();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                iter.remove();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">                    System.out.println(sc.finishConnect());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">1024</span> * <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    count += sc.read(buffer);</span><br><span class=\"line\">                    buffer.clear();</span><br><span class=\"line\">                    System.out.println(count);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-write-为何要取消\"><a href=\"#💡-write-为何要取消\" class=\"headerlink\" title=\"💡 write 为何要取消\"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>\n<h3 id=\"4-6-更进一步\"><a href=\"#4-6-更进一步\" class=\"headerlink\" title=\"4.6 更进一步\"></a>4.6 更进一步</h3><h4 id=\"💡-利用多线程优化\"><a href=\"#💡-利用多线程优化\" class=\"headerlink\" title=\"💡 利用多线程优化\"></a>💡 利用多线程优化</h4><blockquote>\n<p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>\n</blockquote>\n<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>\n<p>分两组选择器</p>\n<ul>\n<li>单线程配一个选择器，专门处理 accept 事件</li>\n<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChannelDemo7</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">BossEventLoop</span>().register();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Slf4j</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BossEventLoop</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector boss;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WorkerEventLoop[] workers;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!start) &#123;</span><br><span class=\"line\">                <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">                ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">                ssc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                boss = Selector.open();</span><br><span class=\"line\">                <span class=\"type\">SelectionKey</span> <span class=\"variable\">ssckey</span> <span class=\"operator\">=</span> ssc.register(boss, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">                workers = initEventLoops();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;boss&quot;</span>).start();</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;boss start...&quot;</span>);</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class=\"line\"><span class=\"comment\">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class=\"line\">            WorkerEventLoop[] workerEventLoops = <span class=\"keyword\">new</span> <span class=\"title class_\">WorkerEventLoop</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class=\"line\">                workerEventLoops[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">WorkerEventLoop</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> workerEventLoops;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    boss.select();</span><br><span class=\"line\">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                        iter.remove();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> c.accept();</span><br><span class=\"line\">                            sc.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class=\"line\">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Slf4j</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WorkerEventLoop</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Selector worker;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">WorkerEventLoop</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.index = index;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(SocketChannel sc)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!start) &#123;</span><br><span class=\"line\">                worker = Selector.open();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;worker-&quot;</span> + index).start();</span><br><span class=\"line\">                start = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tasks.add(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">SelectionKey</span> <span class=\"variable\">sckey</span> <span class=\"operator\">=</span> sc.register(worker, <span class=\"number\">0</span>, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class=\"line\">                    worker.selectNow();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            worker.wakeup();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    worker.select();</span><br><span class=\"line\">                    <span class=\"type\">Runnable</span> <span class=\"variable\">task</span> <span class=\"operator\">=</span> tasks.poll();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (task != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class=\"line\">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (iter.hasNext()) &#123;</span><br><span class=\"line\">                        <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">                            <span class=\"type\">SocketChannel</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">                            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">128</span>);</span><br><span class=\"line\">                            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> sc.read(buffer);</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (read == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                    key.cancel();</span><br><span class=\"line\">                                    sc.close();</span><br><span class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                    buffer.flip();</span><br><span class=\"line\">                                    log.debug(<span class=\"string\">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class=\"line\">                                    debugAll(buffer);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                                e.printStackTrace();</span><br><span class=\"line\">                                key.cancel();</span><br><span class=\"line\">                                sc.close();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        iter.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-如何拿到-cpu-个数\"><a href=\"#💡-如何拿到-cpu-个数\" class=\"headerlink\" title=\"💡 如何拿到 cpu 个数\"></a>💡 如何拿到 cpu 个数</h4><blockquote>\n<ul>\n<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>\n<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>\n</ul>\n</blockquote>\n<h3 id=\"4-7-UDP\"><a href=\"#4-7-UDP\" class=\"headerlink\" title=\"4.7 UDP\"></a>4.7 UDP</h3><ul>\n<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>\n<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>\n</ul>\n<p>首先启动服务器端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UdpServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">DatagramChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> DatagramChannel.open()) &#123;</span><br><span class=\"line\">            channel.socket().bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">9999</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">32</span>);</span><br><span class=\"line\">            channel.receive(buffer);</span><br><span class=\"line\">            buffer.flip();</span><br><span class=\"line\">            debug(buffer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">waiting...</span><br></pre></td></tr></table></figure>\n\n\n\n<p>运行客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UdpClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">DatagramChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> DatagramChannel.open()) &#123;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> StandardCharsets.UTF_8.encode(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">            <span class=\"type\">InetSocketAddress</span> <span class=\"variable\">address</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">9999</span>);</span><br><span class=\"line\">            channel.send(buffer, address);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来服务器端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"5-NIO-vs-BIO\"><a href=\"#5-NIO-vs-BIO\" class=\"headerlink\" title=\"5. NIO vs BIO\"></a>5. NIO vs BIO</h2><h3 id=\"5-1-stream-vs-channel\"><a href=\"#5-1-stream-vs-channel\" class=\"headerlink\" title=\"5.1 stream vs channel\"></a>5.1 stream vs channel</h3><ul>\n<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>\n<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>\n<li>二者均为全双工，即读写可以同时进行</li>\n</ul>\n<h3 id=\"5-2-IO-模型\"><a href=\"#5-2-IO-模型\" class=\"headerlink\" title=\"5.2 IO 模型\"></a>5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>\n<ul>\n<li>同步：线程自己去获取结果（一个线程）</li>\n<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>\n</ul>\n<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>\n<ul>\n<li>等待数据阶段</li>\n<li>复制数据阶段</li>\n</ul>\n<p><img src=\"/img/0033.png\"></p>\n<ul>\n<li><p>阻塞 IO</p>\n<p><img src=\"/img/0039.png\"></p>\n</li>\n<li><p>非阻塞  IO</p>\n<p><img src=\"/img/0035.png\"></p>\n</li>\n<li><p>多路复用</p>\n<p><img src=\"/img/0038.png\"></p>\n</li>\n<li><p>信号驱动</p>\n</li>\n<li><p>异步 IO</p>\n<p><img src=\"/img/0037.png\"></p>\n</li>\n<li><p>阻塞 IO vs 多路复用</p>\n<p><img src=\"/img/0034.png\"></p>\n<p><img src=\"/img/0036.png\"></p>\n</li>\n</ul>\n<h4 id=\"🔖-参考\"><a href=\"#🔖-参考\" class=\"headerlink\" title=\"🔖 参考\"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>\n<h3 id=\"5-3-零拷贝\"><a href=\"#5-3-零拷贝\" class=\"headerlink\" title=\"5.3 零拷贝\"></a>5.3 零拷贝</h3><h4 id=\"传统-IO-问题\"><a href=\"#传统-IO-问题\" class=\"headerlink\" title=\"传统 IO 问题\"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;helloword/data.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">RandomAccessFile</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomAccessFile</span>(file, <span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[(<span class=\"type\">int</span>)f.length()];</span><br><span class=\"line\">file.read(buf);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Socket</span> <span class=\"variable\">socket</span> <span class=\"operator\">=</span> ...;</span><br><span class=\"line\">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>\n\n<p>内部工作流程是这样的：</p>\n<p><img src=\"/img/0024.png\"></p>\n<ol>\n<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>\n<blockquote>\n<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>\n</blockquote>\n</li>\n<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>\n</li>\n<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>\n</li>\n<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>\n</li>\n</ol>\n<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>\n<ul>\n<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>\n<li>数据拷贝了共 4 次</li>\n</ul>\n<h4 id=\"NIO-优化\"><a href=\"#NIO-优化\" class=\"headerlink\" title=\"NIO 优化\"></a>NIO 优化</h4><p>通过 DirectByteBuf </p>\n<ul>\n<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>\n<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>\n</ul>\n<p><img src=\"/img/0025.png\"></p>\n<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>\n<ul>\n<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>\n<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>\n<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>\n<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>\n</ul>\n</li>\n<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>\n</ul>\n<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo&#x2F;transferFrom 方法拷贝数据</p>\n<p><img src=\"/img/0026.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>\n<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>可以看到</p>\n<ul>\n<li>只发生了一次用户态与内核态的切换</li>\n<li>数据拷贝了 3 次</li>\n</ul>\n<p>进一步优化（linux 2.4）</p>\n<p><img src=\"/img/0027.png\"></p>\n<ol>\n<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>\n<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>\n<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>\n</ol>\n<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>\n<ul>\n<li>更少的用户态与内核态的切换</li>\n<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>\n<li>零拷贝适合小文件传输</li>\n</ul>\n<h3 id=\"5-3-AIO\"><a href=\"#5-3-AIO\" class=\"headerlink\" title=\"5.3 AIO\"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>\n<ul>\n<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>\n<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>\n</ul>\n<blockquote>\n<p>异步模型需要底层操作系统（Kernel）提供支持</p>\n<ul>\n<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>\n<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>\n</ul>\n</blockquote>\n<h4 id=\"文件-AIO\"><a href=\"#文件-AIO\" class=\"headerlink\" title=\"文件 AIO\"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioDemo1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"type\">AsynchronousFileChannel</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">                AsynchronousFileChannel.open(</span><br><span class=\"line\">                \tPaths.get(<span class=\"string\">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">2</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">            s.read(buffer, <span class=\"number\">0</span>, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class=\"line\">                    buffer.flip();</span><br><span class=\"line\">                    debug(buffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;read failed...&quot;</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;do other things...&quot;</span>);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class=\"line\">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class=\"line\">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 0d                                           |a.              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>可以看到</p>\n<ul>\n<li>响应文件读取成功的是另一个线程 Thread-5</li>\n<li>主线程并没有 IO 操作阻塞</li>\n</ul>\n<h4 id=\"💡-守护线程\"><a href=\"#💡-守护线程\" class=\"headerlink\" title=\"💡 守护线程\"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>\n<h4 id=\"网络-AIO\"><a href=\"#网络-AIO\" class=\"headerlink\" title=\"网络 AIO\"></a>网络 AIO</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AioServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">AsynchronousServerSocketChannel</span> <span class=\"variable\">ssc</span> <span class=\"operator\">=</span> AsynchronousServerSocketChannel.open();</span><br><span class=\"line\">        ssc.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\">        ssc.accept(<span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">AcceptHandler</span>(ssc));</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">closeChannel</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;[%s] %s close\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            sc.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReadHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">ReadHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (result == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    closeChannel(sc);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s read\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">                attachment.flip();</span><br><span class=\"line\">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class=\"line\">                attachment.clear();</span><br><span class=\"line\">                <span class=\"comment\">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class=\"line\">                sc.read(attachment, attachment, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WriteHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousSocketChannel sc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"title function_\">WriteHandler</span><span class=\"params\">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sc = sc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (attachment.hasRemaining()) &#123;</span><br><span class=\"line\">                sc.write(attachment);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">            closeChannel(sc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AcceptHandler</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">AcceptHandler</span><span class=\"params\">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.ssc = ssc;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">completed</span><span class=\"params\">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.printf(<span class=\"string\">&quot;[%s] %s connected\\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">16</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 读事件由 ReadHandler 处理</span></span><br><span class=\"line\">            sc.read(buffer, buffer, <span class=\"keyword\">new</span> <span class=\"title class_\">ReadHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 写事件由 WriteHandler 处理</span></span><br><span class=\"line\">            sc.write(Charset.defaultCharset().encode(<span class=\"string\">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class=\"number\">16</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">WriteHandler</span>(sc));</span><br><span class=\"line\">            <span class=\"comment\">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class=\"line\">            ssc.accept(<span class=\"literal\">null</span>, <span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">failed</span><span class=\"params\">(Throwable exc, Object attachment)</span> &#123;</span><br><span class=\"line\">            exc.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Netty02-入门","date":"2023-05-06T13:22:02.000Z","_content":"\n该笔记是B站黑马的Netty视频的配套笔记2。\n<!-- more -->\n# 二. Netty 入门\n\n\n\n## 1. 概述\n\n### 1.1 Netty 是什么？\n\n```\nNetty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers & clients.\n```\n\nNetty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n\n\n\n### 1.2 Netty 的作者\n\n![](img/0005.png)\n\n他还是另一个著名网络应用框架 Mina 的重要贡献者\n\n\n\n### 1.3 Netty 的地位\n\nNetty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\n\n以下的框架都使用了 Netty，因为它们有网络通信需求！\n\n* Cassandra - nosql 数据库\n* Spark - 大数据分布式计算框架\n* Hadoop - 大数据分布式存储框架\n* RocketMQ - ali 开源的消息队列\n* ElasticSearch - 搜索引擎\n* gRPC - rpc 框架\n* Dubbo - rpc 框架\n* Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\n* Zookeeper - 分布式协调框架\n\n\n\n### 1.4 Netty 的优势\n\n* Netty vs NIO，工作量大，bug 多\n  * 需要自己构建协议\n  * 解决 TCP 传输问题，如粘包、半包\n  * epoll 空轮询导致 CPU 100%\n  * 对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal，ByteBuf => ByteBuffer\n* Netty vs 其它网络应用框架\n  * Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\n  * 久经考验，16年，Netty 版本\n    * 2.x 2004\n    * 3.x 2008\n    * 4.x 2013\n    * 5.x 已废弃（没有明显的性能提升，维护成本高）\n\n\n\n## 2. Hello World\n\n### 2.1 目标\n\n开发一个简单的服务器端和客户端\n\n* 客户端向服务器端发送 hello, world\n* 服务器仅接收，不返回\n\n\n\n加入依赖\n\n```xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.39.Final</version>\n</dependency>\n```\n\n\n\n\n\n### 2.2 服务器端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioServerSocketChannel.class) // 2\n    .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new StringDecoder()); // 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                    System.out.println(msg);\n                }\n            });\n        }\n    })\n    .bind(8080); // 4\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，可以简单理解为 `线程池 + Selector` 后面会详细展开\n\n* 2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\n\n  ![](img/0006.png)\n\n* 3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n\n* 4 处，ServerSocketChannel 绑定的监听端口\n\n* 5 处，SocketChannel 的处理器，解码 ByteBuf => String\n\n* 6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\n\n\n\n### 2.3 客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioSocketChannel.class) // 2\n    .handler(new ChannelInitializer<Channel>() { // 3\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder()); // 8\n        }\n    })\n    .connect(\"127.0.0.1\", 8080) // 4\n    .sync() // 5\n    .channel() // 6\n    .writeAndFlush(new Date() + \": hello world!\"); // 7\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，同 Server\n\n* 2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\n\n  ![](img/0007.png)\n\n* 3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n* 4 处，指定要连接的服务器和端口\n* 5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\n* 6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n* 7 处，写入消息并清空缓冲区\n* 8 处，消息会经过通道 handler 处理，这里是将 String => ByteBuf 发出\n* 数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\n\n\n\n### 2.4 流程梳理\n\n![](img/0040.png)\n\n#### 💡 提示\n\n> 一开始需要树立正确的观念\n>\n> * 把 channel 理解为数据的通道\n> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\n> * 把 handler 理解为数据的处理工序\n>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\n>   * handler 分 Inbound 和 Outbound 两类\n> * 把 eventLoop 理解为处理数据的工人\n>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\n>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\n>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\n\n\n\n## 3. 组件\n\n### 3.1 EventLoop\n\n事件循环对象\n\nEventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\n\n它的继承关系比较复杂\n\n* 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n* 另一条线是继承自 netty 自己的 OrderedEventExecutor，\n  * 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\n  * 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\n\n\n\n事件循环组\n\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n\n* 继承自 netty 自己的 EventExecutorGroup\n  * 实现了 Iterable 接口提供遍历 EventLoop 的能力\n  * 另有 next 方法获取集合中下一个 EventLoop\n\n\n\n以一个简单的实现为例：\n\n```java\n// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98\n```\n\n也可以使用 for 循环\n\n```java\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) {\n    System.out.println(eventLoop);\n}\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\n```\n\n\n\n#### 💡 优雅关闭\n\n优雅关闭 `shutdownGracefully` 方法。该方法会首先切换 `EventLoopGroup` 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n\n\n\n#### 演示 NioEventLoop 处理 io 事件\n\n服务器端两个 nio worker 工人\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    Channel channel = new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer<NioSocketChannel>() {\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception {\n                    System.out.println(\"init...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                }\n            })\n            .channel(NioSocketChannel.class).connect(\"localhost\", 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n```\n\n最后输出\n\n```\n22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         \n```\n\n可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定\n\n![](img/0042.png)\n\n\n\n再增加两个非 nio 工人\n\n```java\nDefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch)  {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(normalWorkers,\"myhandler\",\n              new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n输出\n\n```\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n```\n\n可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\n\n\n\n![](img/0041.png)\n\n\n\n#### 💡 handler 执行中如何换人？\n\n关键代码 `io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()`\n\n```java\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {\n    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next);\n    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor = next.executor();\n    \n    // 是，直接调用\n    if (executor.inEventLoop()) {\n        next.invokeChannelRead(m);\n    } \n    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else {\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                next.invokeChannelRead(m);\n            }\n        });\n    }\n}\n```\n\n* 如果两个 handler 绑定的是同一个线程，那么就直接调用\n* 否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\n\n\n\n#### 演示 NioEventLoop 处理普通任务\n\nNioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.execute(()->{\n    log.debug(\"normal task...\");\n});\n```\n\n输出\n\n```\n22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...\n```\n\n> 可以用来执行耗时较长的任务\n\n\n\n#### 演示 NioEventLoop 处理定时任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -> {\n    log.debug(\"running...\");\n}, 0, 1, TimeUnit.SECONDS);\n```\n\n输出\n\n```\n22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...\n```\n\n> 可以用来执行定时任务\n\n\n\n### 3.2 Channel\n\nchannel 的主要作用\n\n* close() 可以用来关闭 channel\n* closeFuture() 用来处理 channel 的关闭\n  * sync 方法作用是同步等待 channel 关闭\n  * 而 addListener 方法是异步等待 channel 关闭\n* pipeline() 方法添加处理器\n* write() 方法将数据写入\n* writeAndFlush() 方法将数据写入并刷出\n\n\n\n#### ChannelFuture\n\n这时刚才的客户端代码\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + \": hello world!\");\n```\n\n现在把它拆开来看\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080); // 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + \": hello world!\");\n```\n\n* 1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\n\n**注意** connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象\n\n实验如下：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\n\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.sync(); // 2\nSystem.out.println(channelFuture.channel()); // 3\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x2e1884dd]`\n* 执行到 2 时，sync 方法是同步等待连接建立完成\n* 执行到 3 时，连接肯定建立了，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`\n\n除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.addListener((ChannelFutureListener) future -> {\n    System.out.println(future.channel()); // 2\n});\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x749124ba]`\n* ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 `[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]`\n\n\n\n#### CloseFuture\n\n```java\n@Slf4j\npublic class CloseFutureClient {\n    public static void main(String[] args) throws InterruptedException {\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture = new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override // 在连接建立后被调用\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                })\n                .connect(new InetSocketAddress(\"localhost\", 8080));\n        Channel channel = channelFuture.sync().channel();\n        log.debug(\"{}\", channel);\n        new Thread(()->{\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if (\"q\".equals(line)) {\n                    channel.close(); // close 异步操作 1s 之后\n//                    log.debug(\"处理关闭之后的操作\"); // 不能在这里善后\n                    break;\n                }\n                channel.writeAndFlush(line);\n            }\n        }, \"input\").start();\n\n        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture = channel.closeFuture();\n        /*log.debug(\"waiting close...\");\n        closeFuture.sync();\n        log.debug(\"处理关闭之后的操作\");*/\n        closeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                log.debug(\"处理关闭之后的操作\");\n                group.shutdownGracefully();\n            }\n        });\n    }\n}\n```\n\n\n\n\n\n#### 💡 异步提升的是什么\n\n* 有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\n\n* 还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\n\n\n\n\n\n思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：`4 * 8 * 3 = 96`\n\n![](img/0044.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\n\n![](img/0048.png)\n\n\n\n\n\n\n\n\n\n\n\n因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 `4 * 8 * 12` 效率几乎是原来的四倍\n\n![](img/0047.png)\n\n要点\n\n* 单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\n* 异步并没有缩短响应时间，反而有所增加\n* 合理进行任务拆分，也是利用异步的关键\n\n\n\n### 3.3 Future & Promise\n\n在异步处理时，经常用到这两个接口\n\n首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\n\n* jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\n* netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\n* netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\n\n| 功能/名称    | jdk Future                     | netty Future                                                 | Promise      |\n| ------------ | ------------------------------ | ------------------------------------------------------------ | ------------ |\n| cancel       | 取消任务                       | -                                                            | -            |\n| isCanceled   | 任务是否取消                   | -                                                            | -            |\n| isDone       | 任务是否完成，不能区分成功失败 | -                                                            | -            |\n| get          | 获取任务结果，阻塞等待         | -                                                            | -            |\n| getNow       | -                              | 获取任务结果，非阻塞，还未产生结果时返回 null                | -            |\n| await        | -                              | 等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断 | -            |\n| sync         | -                              | 等待任务结束，如果任务失败，抛出异常                         | -            |\n| isSuccess    | -                              | 判断任务是否成功                                             | -            |\n| cause        | -                              | 获取失败信息，非阻塞，如果没有失败，返回null                 | -            |\n| addLinstener | -                              | 添加回调，异步接收结果                                       | -            |\n| setSuccess   | -                              | -                                                            | 设置成功结果 |\n| setFailure   | -                              | -                                                            | 设置失败结果 |\n\n\n\n#### 例1\n\n同步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\",promise.getNow()); // 还没有结果\nlog.debug(\"{}\",promise.get());\n```\n\n输出\n\n```\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例2\n\n异步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n// 设置回调，异步接收结果\npromise.addListener(future -> {\n    // 这里的 future 就是上面的 promise\n    log.debug(\"{}\",future.getNow());\n});\n\n// 等待 1000 后设置成功结果\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例3\n\n同步处理任务失败 - sync & get\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\n        DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n        eventExecutors.execute(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            RuntimeException e = new RuntimeException(\"error...\");\n            log.debug(\"set failure, {}\", e.toString());\n            promise.setFailure(e);\n        });\n\n        log.debug(\"start...\");\n        log.debug(\"{}\", promise.getNow());\n        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常\n```\n\n输出\n\n```\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread \"main\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\n\n\n#### 例4\n\n同步处理任务失败 - await\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\", promise.getNow());\npromise.await(); // 与 sync 和 get 区别在于，不会抛异常\nlog.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n```\n\n输出\n\n```\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例5\n\n异步处理任务失败\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\npromise.addListener(future -> {\n    log.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n});\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例6\n\nawait 死锁检查\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.submit(()->{\n    System.out.println(\"1\");\n    try {\n        promise.await();\n        // 注意不能仅捕获 InterruptedException 异常\n        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    } catch (Exception e) { \n        e.printStackTrace();\n    }\n    System.out.println(\"2\");\n});\neventExecutors.submit(()->{\n    System.out.println(\"3\");\n    try {\n        promise.await();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"4\");\n});\n```\n\n输出\n\n```\n1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n```\n\n\n\n\n\n### 3.4 Handler & Pipeline\n\nChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline\n\n* 入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\n* 出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\n\n打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\n\n\n\n先搞清楚顺序，服务端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); // 1\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); // 2\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(3);\n                    ctx.channel().write(msg); // 3\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(4);\n                    ctx.write(msg, promise); // 4\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(5);\n                    ctx.write(msg, promise); // 5\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(6);\n                    ctx.write(msg, promise); // 6\n                }\n            });\n        }\n    })\n    .bind(8080);\n```\n\n客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .addListener((ChannelFutureListener) future -> {\n        future.channel().writeAndFlush(\"hello,world\");\n    });\n```\n\n服务器端打印：\n\n```\n1\n2\n3\n6\n5\n4\n```\n\n可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\n\n![](img/0008.png)\n\n* 入站处理器中，ctx.fireChannelRead(msg) 是 **调用下一个入站处理器**\n  * 如果注释掉 1 处代码，则仅会打印 1\n  * 如果注释掉 2 处代码，则仅会打印 1 2\n* 3 处的 ctx.channel().write(msg) 会 **从尾部开始触发** 后续出站处理器的执行\n  * 如果注释掉 3 处代码，则仅会打印 1 2 3\n* 类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 **触发上一个出站处理器**\n  * 如果注释掉 6 处代码，则仅会打印 1 2 3 6\n* ctx.channel().write(msg) vs ctx.write(msg)\n  * 都是触发出站处理器的执行\n  * ctx.channel().write(msg) 从尾部开始查找出站处理器\n  * ctx.write(msg) 是从当前节点找上一个出站处理器\n  * 3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\n  * 6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\n\n\n\n图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\n\n![](img/0009.png)\n\n\n\n### 3.5 ByteBuf\n\n是对字节数据的封装\n\n#### 1）创建\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);\n```\n\n上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\n\n输出\n\n```\nread index:0 write index:0 capacity:10\n```\n\n其中 log 方法参考如下\n\n```java\nprivate static void log(ByteBuf buffer) {\n    int length = buffer.readableBytes();\n    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;\n    StringBuilder buf = new StringBuilder(rows * 80 * 2)\n        .append(\"read index:\").append(buffer.readerIndex())\n        .append(\" write index:\").append(buffer.writerIndex())\n        .append(\" capacity:\").append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n}\n```\n\n\n\n#### 2）直接内存 vs 堆内存\n\n可以使用下面的代码来创建池化基于堆的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);\n```\n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);\n```\n\n* 直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\n* 直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\n\n\n\n#### 3）池化 vs 非池化\n\n池化的最大意义在于可以重用 ByteBuf，优点有\n\n* 没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\n* 有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n* 高并发时，池化功能更节约内存，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n\n```java\n-Dio.netty.allocator.type={unpooled|pooled}\n```\n\n* 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n* 4.1 之前，池化功能还不成熟，默认是非池化实现\n\n\n\n#### 4）组成\n\nByteBuf 由四部分组成\n\n![](img/0010.png)\n\n最开始读写指针都在 0 位置\n\n\n\n#### 5）写入\n\n方法列表，省略一些不重要的方法\n\n| 方法签名                                                     | 含义                   | 备注                                        |\n| ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |\n| writeBoolean(boolean value)                                  | 写入 boolean 值        | 用一字节 01\\|00 代表 true\\|false            |\n| writeByte(int value)                                         | 写入 byte 值           |                                             |\n| writeShort(int value)                                        | 写入 short 值          |                                             |\n| writeInt(int value)                                          | 写入 int 值            | Big Endian，即 0x250，写入后 00 00 02 50    |\n| writeIntLE(int value)                                        | 写入 int 值            | Little Endian，即 0x250，写入后 50 02 00 00 |\n| writeLong(long value)                                        | 写入 long 值           |                                             |\n| writeChar(int value)                                         | 写入 char 值           |                                             |\n| writeFloat(float value)                                      | 写入 float 值          |                                             |\n| writeDouble(double value)                                    | 写入 double 值         |                                             |\n| writeBytes(ByteBuf src)                                      | 写入 netty 的 ByteBuf  |                                             |\n| writeBytes(byte[] src)                                       | 写入 byte[]            |                                             |\n| writeBytes(ByteBuffer src)                                   | 写入 nio 的 ByteBuffer |                                             |\n| int writeCharSequence(CharSequence sequence, Charset charset) | 写入字符串             |                                             |\n\n> 注意\n>\n> * 这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\n> * 网络传输，默认习惯是 Big Endian\n\n\n\n先写入 4 个字节\n\n```java\nbuffer.writeBytes(new byte[]{1, 2, 3, 4});\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n再写入一个 int 整数，也是 4 个字节\n\n```java\nbuffer.writeInt(5);\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n\n\n\n#### 6）扩容\n\n再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\n\n```java\nbuffer.writeInt(6);\nlog(buffer);\n```\n\n扩容规则是\n\n* 如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\n* 如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）\n* 扩容不能超过 max capacity 会报错\n\n结果是\n\n```\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 7）读取\n\n例如读了 4 次，每次一个字节\n\n```java\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);\n```\n\n读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\n\n```\n1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果需要重复读取 int 整数 5，怎么办？\n\n可以在 read 前先做个标记 mark\n\n```java\nbuffer.markReaderIndex();\nSystem.out.println(buffer.readInt());\nlog(buffer);\n```\n\n结果\n\n```\n5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时要重复读取的话，重置到标记位置 reset\n\n```java\nbuffer.resetReaderIndex();\nlog(buffer);\n```\n\n这时\n\n```\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\n\n\n\n#### 8）retain & release\n\n由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\n* UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\n* UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\n* PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\n\n\n\n> 回收内存的源码实现，请关注下面方法的不同实现\n>\n> `protected abstract void deallocate()`\n\n\n\nNetty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n* 每个 ByteBuf 对象的初始计数为 1\n* 调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n* 调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n* 当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\n\n\n\n谁来负责 release 呢？\n\n不是我们想象的（一般情况下）\n\n```java\nByteBuf buf = ...\ntry {\n    ...\n} finally {\n    buf.release();\n}\n```\n\n请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n\n基本规则是，**谁是最后使用者，谁负责 release**，详细分析如下\n\n* 起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n* 入站 ByteBuf 处理原则\n  * 对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\n  * 将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\n  * 如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\n  * 注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n  * 假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\n* 出站 ByteBuf 处理原则\n  * 出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\n* 异常处理原则\n  * 有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\n\n\n\nTailContext 释放未处理消息逻辑\n\n```java\n// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) {\n    try {\n        logger.debug(\n            \"Discarded inbound message {} that reached at the tail of the pipeline. \" +\n            \"Please check your pipeline configuration.\", msg);\n    } finally {\n        ReferenceCountUtil.release(msg);\n    }\n}\n```\n\n具体代码\n\n```java\n// io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) {\n    if (msg instanceof ReferenceCounted) {\n        return ((ReferenceCounted) msg).release();\n    }\n    return false;\n}\n```\n\n\n\n#### 9）slice\n\n【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n\n![](img/0011.png)\n\n例，原始 ByteBuf 进行一些初始操作\n\n```java\nByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]{1, 2, 3, 4});\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write\n\n```java\nByteBuf slice = origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果原始 ByteBuf 再次读操作（又读了一个字节）\n\n```java\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时的 slice 不受影响，因为它有独立的读写指针\n\n```java\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果 slice 的内容发生了更改\n\n```java\nslice.setByte(2, 5);\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\n\n```\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 10）duplicate\n\n【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\n\n![](img/0012.png)\n\n\n\n#### 11）copy\n\n会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\n\n\n\n#### 12）CompositeByteBuf\n\n【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\n\n有两个 ByteBuf 如下\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n```\n\n现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\n\n方法1：\n\n```java\nByteBuf buf3 = ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\n\n\n\n方法2：\n\n```java\nCompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);\n```\n\n结果是一样的\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\nCompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\n\n* 优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\n* 缺点，复杂了很多，多次操作会带来性能的损耗\n\n\n\n#### 13）Unpooled\n\nUnpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\n\n这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\n\n// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n也可以用来包装普通字节数组，底层也不会有拷贝操作\n\n```java\nByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6});\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));\n```\n\n输出\n\n```\nclass io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 ByteBuf 优势\n\n* 池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n* 读写指针分离，不需要像 ByteBuffer 一样切换读写模式\n* 可以自动扩容\n* 支持链式调用，使用更流畅\n* 很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\n\n\n\n## 4. 双向通信\n\n### 4.1 练习\n\n实现一个 echo server\n\n编写 server\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response = ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    // 思考：需要释放 buffer 吗\n                    // 思考：需要释放 response 吗\n                }\n            });\n        }\n    }).bind(8080);\n```\n\n编写 client\n\n```java\nNioEventLoopGroup group = new NioEventLoopGroup();\nChannel channel = new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 思考：需要释放 buffer 吗\n                }\n            });\n        }\n    }).connect(\"127.0.0.1\", 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -> {\n    group.shutdownGracefully();\n});\n\nnew Thread(() -> {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n        String line = scanner.nextLine();\n        if (\"q\".equals(line)) {\n            channel.close();\n            break;\n        }\n        channel.writeAndFlush(line);\n    }\n}).start();\n```\n\n\n\n### 💡 读和写的误解\n\n\n\n我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在`A 到 B` 和 `B 到 A` 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\n\n\n\n例如\n\n```java\npublic class TestServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888);\n        Socket s = ss.accept();\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n客户端\n\n```java\npublic class TestClient {\n    public static void main(String[] args) throws IOException {\n        Socket s = new Socket(\"localhost\", 8888);\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2023-05-06-Netty02-入门.md","raw":"---\ntitle: Netty02-入门\ndate: 2023-05-06 21:22:02\ntags: \n- Netty\n- programing\n- Java\ncategories: Netty\n---\n\n该笔记是B站黑马的Netty视频的配套笔记2。\n<!-- more -->\n# 二. Netty 入门\n\n\n\n## 1. 概述\n\n### 1.1 Netty 是什么？\n\n```\nNetty is an asynchronous event-driven network application framework\nfor rapid development of maintainable high performance protocol servers & clients.\n```\n\nNetty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n\n\n\n### 1.2 Netty 的作者\n\n![](img/0005.png)\n\n他还是另一个著名网络应用框架 Mina 的重要贡献者\n\n\n\n### 1.3 Netty 的地位\n\nNetty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位\n\n以下的框架都使用了 Netty，因为它们有网络通信需求！\n\n* Cassandra - nosql 数据库\n* Spark - 大数据分布式计算框架\n* Hadoop - 大数据分布式存储框架\n* RocketMQ - ali 开源的消息队列\n* ElasticSearch - 搜索引擎\n* gRPC - rpc 框架\n* Dubbo - rpc 框架\n* Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端\n* Zookeeper - 分布式协调框架\n\n\n\n### 1.4 Netty 的优势\n\n* Netty vs NIO，工作量大，bug 多\n  * 需要自己构建协议\n  * 解决 TCP 传输问题，如粘包、半包\n  * epoll 空轮询导致 CPU 100%\n  * 对 API 进行增强，使之更易用，如 FastThreadLocal => ThreadLocal，ByteBuf => ByteBuffer\n* Netty vs 其它网络应用框架\n  * Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀\n  * 久经考验，16年，Netty 版本\n    * 2.x 2004\n    * 3.x 2008\n    * 4.x 2013\n    * 5.x 已废弃（没有明显的性能提升，维护成本高）\n\n\n\n## 2. Hello World\n\n### 2.1 目标\n\n开发一个简单的服务器端和客户端\n\n* 客户端向服务器端发送 hello, world\n* 服务器仅接收，不返回\n\n\n\n加入依赖\n\n```xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.39.Final</version>\n</dependency>\n```\n\n\n\n\n\n### 2.2 服务器端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioServerSocketChannel.class) // 2\n    .childHandler(new ChannelInitializer<NioSocketChannel>() { // 3\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new StringDecoder()); // 5\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() { // 6\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                    System.out.println(msg);\n                }\n            });\n        }\n    })\n    .bind(8080); // 4\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，可以简单理解为 `线程池 + Selector` 后面会详细展开\n\n* 2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有\n\n  ![](img/0006.png)\n\n* 3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n\n* 4 处，ServerSocketChannel 绑定的监听端口\n\n* 5 处，SocketChannel 的处理器，解码 ByteBuf => String\n\n* 6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果\n\n\n\n### 2.3 客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup()) // 1\n    .channel(NioSocketChannel.class) // 2\n    .handler(new ChannelInitializer<Channel>() { // 3\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder()); // 8\n        }\n    })\n    .connect(\"127.0.0.1\", 8080) // 4\n    .sync() // 5\n    .channel() // 6\n    .writeAndFlush(new Date() + \": hello world!\"); // 7\n```\n\n代码解读\n\n* 1 处，创建 NioEventLoopGroup，同 Server\n\n* 2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有\n\n  ![](img/0007.png)\n\n* 3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器\n* 4 处，指定要连接的服务器和端口\n* 5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕\n* 6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n* 7 处，写入消息并清空缓冲区\n* 8 处，消息会经过通道 handler 处理，这里是将 String => ByteBuf 发出\n* 数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程\n\n\n\n### 2.4 流程梳理\n\n![](img/0040.png)\n\n#### 💡 提示\n\n> 一开始需要树立正确的观念\n>\n> * 把 channel 理解为数据的通道\n> * 把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf\n> * 把 handler 理解为数据的处理工序\n>   * 工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成...）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\n>   * handler 分 Inbound 和 Outbound 两类\n> * 把 eventLoop 理解为处理数据的工人\n>   * 工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）\n>   * 工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\n>   * 工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人\n\n\n\n## 3. 组件\n\n### 3.1 EventLoop\n\n事件循环对象\n\nEventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。\n\n它的继承关系比较复杂\n\n* 一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n* 另一条线是继承自 netty 自己的 OrderedEventExecutor，\n  * 提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\n  * 提供了 parent 方法来看看自己属于哪个 EventLoopGroup\n\n\n\n事件循环组\n\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n\n* 继承自 netty 自己的 EventExecutorGroup\n  * 实现了 Iterable 接口提供遍历 EventLoop 的能力\n  * 另有 next 方法获取集合中下一个 EventLoop\n\n\n\n以一个简单的实现为例：\n\n```java\n// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nSystem.out.println(group.next());\nSystem.out.println(group.next());\nSystem.out.println(group.next());\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\nio.netty.channel.DefaultEventLoop@60f82f98\n```\n\n也可以使用 for 循环\n\n```java\nDefaultEventLoopGroup group = new DefaultEventLoopGroup(2);\nfor (EventExecutor eventLoop : group) {\n    System.out.println(eventLoop);\n}\n```\n\n输出\n\n```\nio.netty.channel.DefaultEventLoop@60f82f98\nio.netty.channel.DefaultEventLoop@35f983a6\n```\n\n\n\n#### 💡 优雅关闭\n\n优雅关闭 `shutdownGracefully` 方法。该方法会首先切换 `EventLoopGroup` 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n\n\n\n#### 演示 NioEventLoop 处理 io 事件\n\n服务器端两个 nio worker 工人\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n```java\npublic static void main(String[] args) throws InterruptedException {\n    Channel channel = new Bootstrap()\n            .group(new NioEventLoopGroup(1))\n            .handler(new ChannelInitializer<NioSocketChannel>() {\n                @Override\n                protected void initChannel(NioSocketChannel ch) throws Exception {\n                    System.out.println(\"init...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                }\n            })\n            .channel(NioSocketChannel.class).connect(\"localhost\", 8080)\n            .sync()\n            .channel();\n\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n    Thread.sleep(2000);\n    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(\"wangwu\".getBytes()));\n```\n\n最后输出\n\n```\n22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       \n22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           \n22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        \n22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         \n```\n\n可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定\n\n![](img/0042.png)\n\n\n\n再增加两个非 nio 工人\n\n```java\nDefaultEventLoopGroup normalWorkers = new DefaultEventLoopGroup(2);\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch)  {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(normalWorkers,\"myhandler\",\n              new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf byteBuf = msg instanceof ByteBuf ? ((ByteBuf) msg) : null;\n                    if (byteBuf != null) {\n                        byte[] buf = new byte[16];\n                        ByteBuf len = byteBuf.readBytes(buf, 0, byteBuf.readableBytes());\n                        log.debug(new String(buf));\n                    }\n                }\n            });\n        }\n    }).bind(8080).sync();\n```\n\n客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）\n\n输出\n\n```\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |\n+--------+-------------------------------------------------+----------------+\n22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE\n22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        \n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED\n22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6c 69 73 69                                     |lisi            |\n+--------+-------------------------------------------------+----------------+\n22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE\n22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            \n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 77 61 6e 67 77 75                               |wangwu          |\n+--------+-------------------------------------------------+----------------+\n22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE\n22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          \n```\n\n可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）\n\n\n\n![](img/0041.png)\n\n\n\n#### 💡 handler 执行中如何换人？\n\n关键代码 `io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()`\n\n```java\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {\n    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next);\n    // 下一个 handler 的事件循环是否与当前的事件循环是同一个线程\n    EventExecutor executor = next.executor();\n    \n    // 是，直接调用\n    if (executor.inEventLoop()) {\n        next.invokeChannelRead(m);\n    } \n    // 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）\n    else {\n        executor.execute(new Runnable() {\n            @Override\n            public void run() {\n                next.invokeChannelRead(m);\n            }\n        });\n    }\n}\n```\n\n* 如果两个 handler 绑定的是同一个线程，那么就直接调用\n* 否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用\n\n\n\n#### 演示 NioEventLoop 处理普通任务\n\nNioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.execute(()->{\n    log.debug(\"normal task...\");\n});\n```\n\n输出\n\n```\n22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...\n```\n\n> 可以用来执行耗时较长的任务\n\n\n\n#### 演示 NioEventLoop 处理定时任务\n\n```java\nNioEventLoopGroup nioWorkers = new NioEventLoopGroup(2);\n\nlog.debug(\"server start...\");\nThread.sleep(2000);\nnioWorkers.scheduleAtFixedRate(() -> {\n    log.debug(\"running...\");\n}, 0, 1, TimeUnit.SECONDS);\n```\n\n输出\n\n```\n22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...\n22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...\n...\n```\n\n> 可以用来执行定时任务\n\n\n\n### 3.2 Channel\n\nchannel 的主要作用\n\n* close() 可以用来关闭 channel\n* closeFuture() 用来处理 channel 的关闭\n  * sync 方法作用是同步等待 channel 关闭\n  * 而 addListener 方法是异步等待 channel 关闭\n* pipeline() 方法添加处理器\n* write() 方法将数据写入\n* writeAndFlush() 方法将数据写入并刷出\n\n\n\n#### ChannelFuture\n\n这时刚才的客户端代码\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .sync()\n    .channel()\n    .writeAndFlush(new Date() + \": hello world!\");\n```\n\n现在把它拆开来看\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080); // 1\n\nchannelFuture.sync().channel().writeAndFlush(new Date() + \": hello world!\");\n```\n\n* 1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象\n\n**注意** connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象\n\n实验如下：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\n\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.sync(); // 2\nSystem.out.println(channelFuture.channel()); // 3\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x2e1884dd]`\n* 执行到 2 时，sync 方法是同步等待连接建立完成\n* 执行到 3 时，连接肯定建立了，打印 `[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]`\n\n除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：\n\n```java\nChannelFuture channelFuture = new Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080);\nSystem.out.println(channelFuture.channel()); // 1\nchannelFuture.addListener((ChannelFutureListener) future -> {\n    System.out.println(future.channel()); // 2\n});\n```\n\n* 执行到 1 时，连接未建立，打印 `[id: 0x749124ba]`\n* ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 `[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]`\n\n\n\n#### CloseFuture\n\n```java\n@Slf4j\npublic class CloseFutureClient {\n    public static void main(String[] args) throws InterruptedException {\n        NioEventLoopGroup group new NioEventLoopGroup();\n        ChannelFuture channelFuture = new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<NioSocketChannel>() {\n                    @Override // 在连接建立后被调用\n                    protected void initChannel(NioSocketChannel ch) throws Exception {\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                })\n                .connect(new InetSocketAddress(\"localhost\", 8080));\n        Channel channel = channelFuture.sync().channel();\n        log.debug(\"{}\", channel);\n        new Thread(()->{\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String line = scanner.nextLine();\n                if (\"q\".equals(line)) {\n                    channel.close(); // close 异步操作 1s 之后\n//                    log.debug(\"处理关闭之后的操作\"); // 不能在这里善后\n                    break;\n                }\n                channel.writeAndFlush(line);\n            }\n        }, \"input\").start();\n\n        // 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭\n        ChannelFuture closeFuture = channel.closeFuture();\n        /*log.debug(\"waiting close...\");\n        closeFuture.sync();\n        log.debug(\"处理关闭之后的操作\");*/\n        closeFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                log.debug(\"处理关闭之后的操作\");\n                group.shutdownGracefully();\n            }\n        });\n    }\n}\n```\n\n\n\n\n\n#### 💡 异步提升的是什么\n\n* 有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接\n\n* 还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的\n\n\n\n\n\n思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：`4 * 8 * 3 = 96`\n\n![](img/0044.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下\n\n![](img/0048.png)\n\n\n\n\n\n\n\n\n\n\n\n因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 `4 * 8 * 12` 效率几乎是原来的四倍\n\n![](img/0047.png)\n\n要点\n\n* 单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势\n* 异步并没有缩短响应时间，反而有所增加\n* 合理进行任务拆分，也是利用异步的关键\n\n\n\n### 3.3 Future & Promise\n\n在异步处理时，经常用到这两个接口\n\n首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\n\n* jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\n* netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\n* netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\n\n| 功能/名称    | jdk Future                     | netty Future                                                 | Promise      |\n| ------------ | ------------------------------ | ------------------------------------------------------------ | ------------ |\n| cancel       | 取消任务                       | -                                                            | -            |\n| isCanceled   | 任务是否取消                   | -                                                            | -            |\n| isDone       | 任务是否完成，不能区分成功失败 | -                                                            | -            |\n| get          | 获取任务结果，阻塞等待         | -                                                            | -            |\n| getNow       | -                              | 获取任务结果，非阻塞，还未产生结果时返回 null                | -            |\n| await        | -                              | 等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断 | -            |\n| sync         | -                              | 等待任务结束，如果任务失败，抛出异常                         | -            |\n| isSuccess    | -                              | 判断任务是否成功                                             | -            |\n| cause        | -                              | 获取失败信息，非阻塞，如果没有失败，返回null                 | -            |\n| addLinstener | -                              | 添加回调，异步接收结果                                       | -            |\n| setSuccess   | -                              | -                                                            | 设置成功结果 |\n| setFailure   | -                              | -                                                            | 设置失败结果 |\n\n\n\n#### 例1\n\n同步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\",promise.getNow()); // 还没有结果\nlog.debug(\"{}\",promise.get());\n```\n\n输出\n\n```\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例2\n\n异步处理任务成功\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n// 设置回调，异步接收结果\npromise.addListener(future -> {\n    // 这里的 future 就是上面的 promise\n    log.debug(\"{}\",future.getNow());\n});\n\n// 等待 1000 后设置成功结果\neventExecutors.execute(()->{\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    log.debug(\"set success, {}\",10);\n    promise.setSuccess(10);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10\n11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10\n```\n\n\n\n#### 例3\n\n同步处理任务失败 - sync & get\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\n        DefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\n        eventExecutors.execute(() -> {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            RuntimeException e = new RuntimeException(\"error...\");\n            log.debug(\"set failure, {}\", e.toString());\n            promise.setFailure(e);\n        });\n\n        log.debug(\"start...\");\n        log.debug(\"{}\", promise.getNow());\n        promise.get(); // sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常\n```\n\n输出\n\n```\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\nException in thread \"main\" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...\n\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)\n\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)\nCaused by: java.lang.RuntimeException: error...\n\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n```\n\n\n\n#### 例4\n\n同步处理任务失败 - await\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\nlog.debug(\"{}\", promise.getNow());\npromise.await(); // 与 sync 和 get 区别在于，不会抛异常\nlog.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n```\n\n输出\n\n```\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null\n12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例5\n\n异步处理任务失败\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\npromise.addListener(future -> {\n    log.debug(\"result {}\", (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());\n});\n\neventExecutors.execute(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    RuntimeException e = new RuntimeException(\"error...\");\n    log.debug(\"set failure, {}\", e.toString());\n    promise.setFailure(e);\n});\n\nlog.debug(\"start...\");\n```\n\n输出\n\n```\n12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...\n12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...\n```\n\n\n\n#### 例6\n\nawait 死锁检查\n\n```java\nDefaultEventLoop eventExecutors = new DefaultEventLoop();\nDefaultPromise<Integer> promise = new DefaultPromise<>(eventExecutors);\n\neventExecutors.submit(()->{\n    System.out.println(\"1\");\n    try {\n        promise.await();\n        // 注意不能仅捕获 InterruptedException 异常\n        // 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播\n        // 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出\n    } catch (Exception e) { \n        e.printStackTrace();\n    }\n    System.out.println(\"2\");\n});\neventExecutors.submit(()->{\n    System.out.println(\"3\");\n    try {\n        promise.await();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    System.out.println(\"4\");\n});\n```\n\n输出\n\n```\n1\n2\n3\n4\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\nio.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)\n\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)\n\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)\n\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)\n\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)\n\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)\n\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.lang.Thread.run(Thread.java:745)\n\n```\n\n\n\n\n\n### 3.4 Handler & Pipeline\n\nChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline\n\n* 入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果\n* 出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工\n\n打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品\n\n\n\n先搞清楚顺序，服务端\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(1);\n                    ctx.fireChannelRead(msg); // 1\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(2);\n                    ctx.fireChannelRead(msg); // 2\n                }\n            });\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    System.out.println(3);\n                    ctx.channel().write(msg); // 3\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(4);\n                    ctx.write(msg, promise); // 4\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(5);\n                    ctx.write(msg, promise); // 5\n                }\n            });\n            ch.pipeline().addLast(new ChannelOutboundHandlerAdapter(){\n                @Override\n                public void write(ChannelHandlerContext ctx, Object msg, \n                                  ChannelPromise promise) {\n                    System.out.println(6);\n                    ctx.write(msg, promise); // 6\n                }\n            });\n        }\n    })\n    .bind(8080);\n```\n\n客户端\n\n```java\nnew Bootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) {\n            ch.pipeline().addLast(new StringEncoder());\n        }\n    })\n    .connect(\"127.0.0.1\", 8080)\n    .addListener((ChannelFutureListener) future -> {\n        future.channel().writeAndFlush(\"hello,world\");\n    });\n```\n\n服务器端打印：\n\n```\n1\n2\n3\n6\n5\n4\n```\n\n可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表\n\n![](img/0008.png)\n\n* 入站处理器中，ctx.fireChannelRead(msg) 是 **调用下一个入站处理器**\n  * 如果注释掉 1 处代码，则仅会打印 1\n  * 如果注释掉 2 处代码，则仅会打印 1 2\n* 3 处的 ctx.channel().write(msg) 会 **从尾部开始触发** 后续出站处理器的执行\n  * 如果注释掉 3 处代码，则仅会打印 1 2 3\n* 类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 **触发上一个出站处理器**\n  * 如果注释掉 6 处代码，则仅会打印 1 2 3 6\n* ctx.channel().write(msg) vs ctx.write(msg)\n  * 都是触发出站处理器的执行\n  * ctx.channel().write(msg) 从尾部开始查找出站处理器\n  * ctx.write(msg) 是从当前节点找上一个出站处理器\n  * 3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了\n  * 6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6... 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己\n\n\n\n图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序\n\n![](img/0009.png)\n\n\n\n### 3.5 ByteBuf\n\n是对字节数据的封装\n\n#### 1）创建\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(10);\nlog(buffer);\n```\n\n上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10\n\n输出\n\n```\nread index:0 write index:0 capacity:10\n```\n\n其中 log 方法参考如下\n\n```java\nprivate static void log(ByteBuf buffer) {\n    int length = buffer.readableBytes();\n    int rows = length / 16 + (length % 15 == 0 ? 0 : 1) + 4;\n    StringBuilder buf = new StringBuilder(rows * 80 * 2)\n        .append(\"read index:\").append(buffer.readerIndex())\n        .append(\" write index:\").append(buffer.writerIndex())\n        .append(\" capacity:\").append(buffer.capacity())\n        .append(NEWLINE);\n    appendPrettyHexDump(buf, buffer);\n    System.out.println(buf.toString());\n}\n```\n\n\n\n#### 2）直接内存 vs 堆内存\n\n可以使用下面的代码来创建池化基于堆的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(10);\n```\n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\n\n```java\nByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(10);\n```\n\n* 直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\n* 直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\n\n\n\n#### 3）池化 vs 非池化\n\n池化的最大意义在于可以重用 ByteBuf，优点有\n\n* 没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\n* 有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n* 高并发时，池化功能更节约内存，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n\n```java\n-Dio.netty.allocator.type={unpooled|pooled}\n```\n\n* 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n* 4.1 之前，池化功能还不成熟，默认是非池化实现\n\n\n\n#### 4）组成\n\nByteBuf 由四部分组成\n\n![](img/0010.png)\n\n最开始读写指针都在 0 位置\n\n\n\n#### 5）写入\n\n方法列表，省略一些不重要的方法\n\n| 方法签名                                                     | 含义                   | 备注                                        |\n| ------------------------------------------------------------ | ---------------------- | ------------------------------------------- |\n| writeBoolean(boolean value)                                  | 写入 boolean 值        | 用一字节 01\\|00 代表 true\\|false            |\n| writeByte(int value)                                         | 写入 byte 值           |                                             |\n| writeShort(int value)                                        | 写入 short 值          |                                             |\n| writeInt(int value)                                          | 写入 int 值            | Big Endian，即 0x250，写入后 00 00 02 50    |\n| writeIntLE(int value)                                        | 写入 int 值            | Little Endian，即 0x250，写入后 50 02 00 00 |\n| writeLong(long value)                                        | 写入 long 值           |                                             |\n| writeChar(int value)                                         | 写入 char 值           |                                             |\n| writeFloat(float value)                                      | 写入 float 值          |                                             |\n| writeDouble(double value)                                    | 写入 double 值         |                                             |\n| writeBytes(ByteBuf src)                                      | 写入 netty 的 ByteBuf  |                                             |\n| writeBytes(byte[] src)                                       | 写入 byte[]            |                                             |\n| writeBytes(ByteBuffer src)                                   | 写入 nio 的 ByteBuffer |                                             |\n| int writeCharSequence(CharSequence sequence, Charset charset) | 写入字符串             |                                             |\n\n> 注意\n>\n> * 这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用\n> * 网络传输，默认习惯是 Big Endian\n\n\n\n先写入 4 个字节\n\n```java\nbuffer.writeBytes(new byte[]{1, 2, 3, 4});\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:4 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n再写入一个 int 整数，也是 4 个字节\n\n```java\nbuffer.writeInt(5);\nlog(buffer);\n```\n\n结果是\n\n```\nread index:0 write index:8 capacity:10\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n\n\n\n#### 6）扩容\n\n再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容\n\n```java\nbuffer.writeInt(6);\nlog(buffer);\n```\n\n扩容规则是\n\n* 如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16\n* 如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）\n* 扩容不能超过 max capacity 会报错\n\n结果是\n\n```\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 7）读取\n\n例如读了 4 次，每次一个字节\n\n```java\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nSystem.out.println(buffer.readByte());\nlog(buffer);\n```\n\n读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分\n\n```\n1\n2\n3\n4\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果需要重复读取 int 整数 5，怎么办？\n\n可以在 read 前先做个标记 mark\n\n```java\nbuffer.markReaderIndex();\nSystem.out.println(buffer.readInt());\nlog(buffer);\n```\n\n结果\n\n```\n5\nread index:8 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 06                                     |....            |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时要重复读取的话，重置到标记位置 reset\n\n```java\nbuffer.resetReaderIndex();\nlog(buffer);\n```\n\n这时\n\n```\nread index:4 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05 00 00 00 06                         |........        |\n+--------+-------------------------------------------------+----------------+\n```\n\n还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index\n\n\n\n#### 8）retain & release\n\n由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\n* UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\n* UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\n* PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\n\n\n\n> 回收内存的源码实现，请关注下面方法的不同实现\n>\n> `protected abstract void deallocate()`\n\n\n\nNetty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n* 每个 ByteBuf 对象的初始计数为 1\n* 调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n* 调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n* 当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\n\n\n\n谁来负责 release 呢？\n\n不是我们想象的（一般情况下）\n\n```java\nByteBuf buf = ...\ntry {\n    ...\n} finally {\n    buf.release();\n}\n```\n\n请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n\n基本规则是，**谁是最后使用者，谁负责 release**，详细分析如下\n\n* 起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n* 入站 ByteBuf 处理原则\n  * 对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\n  * 将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\n  * 如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\n  * 注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n  * 假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\n* 出站 ByteBuf 处理原则\n  * 出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\n* 异常处理原则\n  * 有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\n\n\n\nTailContext 释放未处理消息逻辑\n\n```java\n// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)\nprotected void onUnhandledInboundMessage(Object msg) {\n    try {\n        logger.debug(\n            \"Discarded inbound message {} that reached at the tail of the pipeline. \" +\n            \"Please check your pipeline configuration.\", msg);\n    } finally {\n        ReferenceCountUtil.release(msg);\n    }\n}\n```\n\n具体代码\n\n```java\n// io.netty.util.ReferenceCountUtil#release(java.lang.Object)\npublic static boolean release(Object msg) {\n    if (msg instanceof ReferenceCounted) {\n        return ((ReferenceCounted) msg).release();\n    }\n    return false;\n}\n```\n\n\n\n#### 9）slice\n\n【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n\n![](img/0011.png)\n\n例，原始 ByteBuf 进行一些初始操作\n\n```java\nByteBuf origin = ByteBufAllocator.DEFAULT.buffer(10);\norigin.writeBytes(new byte[]{1, 2, 3, 4});\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write\n\n```java\nByteBuf slice = origin.slice();\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果原始 ByteBuf 再次读操作（又读了一个字节）\n\n```java\norigin.readByte();\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 04                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时的 slice 不受影响，因为它有独立的读写指针\n\n```java\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 04                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n如果 slice 的内容发生了更改\n\n```java\nslice.setByte(2, 5);\nSystem.out.println(ByteBufUtil.prettyHexDump(slice));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 02 03 05                                        |...             |\n+--------+-------------------------------------------------+----------------+\n```\n\n这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存\n\n```\nSystem.out.println(ByteBufUtil.prettyHexDump(origin));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 03 05                                           |..              |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 10）duplicate\n\n【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的\n\n![](img/0012.png)\n\n\n\n#### 11）copy\n\n会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关\n\n\n\n#### 12）CompositeByteBuf\n\n【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝\n\n有两个 ByteBuf 如下\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\nSystem.out.println(ByteBufUtil.prettyHexDump(buf1));\nSystem.out.println(ByteBufUtil.prettyHexDump(buf2));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n```\n\n现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？\n\n方法1：\n\n```java\nByteBuf buf3 = ByteBufAllocator.DEFAULT\n    .buffer(buf1.readableBytes()+buf2.readableBytes());\nbuf3.writeBytes(buf1);\nbuf3.writeBytes(buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n结果\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n这种方法好不好？回答是不太好，因为进行了数据的内存复制操作\n\n\n\n方法2：\n\n```java\nCompositeByteBuf buf3 = ByteBufAllocator.DEFAULT.compositeBuffer();\n// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0\nbuf3.addComponents(true, buf1, buf2);\n```\n\n结果是一样的\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\nCompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。\n\n* 优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制\n* 缺点，复杂了很多，多次操作会带来性能的损耗\n\n\n\n#### 13）Unpooled\n\nUnpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作\n\n这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf\n\n```java\nByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf1.writeBytes(new byte[]{1, 2, 3, 4, 5});\nByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer(5);\nbuf2.writeBytes(new byte[]{6, 7, 8, 9, 10});\n\n// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf\nByteBuf buf3 = Unpooled.wrappedBuffer(buf1, buf2);\nSystem.out.println(ByteBufUtil.prettyHexDump(buf3));\n```\n\n输出\n\n```\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |\n+--------+-------------------------------------------------+----------------+\n```\n\n也可以用来包装普通字节数组，底层也不会有拷贝操作\n\n```java\nByteBuf buf4 = Unpooled.wrappedBuffer(new byte[]{1, 2, 3}, new byte[]{4, 5, 6});\nSystem.out.println(buf4.getClass());\nSystem.out.println(ByteBufUtil.prettyHexDump(buf4));\n```\n\n输出\n\n```\nclass io.netty.buffer.CompositeByteBuf\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05 06                               |......          |\n+--------+-------------------------------------------------+----------------+\n```\n\n\n\n#### 💡 ByteBuf 优势\n\n* 池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n* 读写指针分离，不需要像 ByteBuffer 一样切换读写模式\n* 可以自动扩容\n* 支持链式调用，使用更流畅\n* 很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf\n\n\n\n## 4. 双向通信\n\n### 4.1 练习\n\n实现一个 echo server\n\n编写 server\n\n```java\nnew ServerBootstrap()\n    .group(new NioEventLoopGroup())\n    .channel(NioServerSocketChannel.class)\n    .childHandler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) {\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter(){\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 建议使用 ctx.alloc() 创建 ByteBuf\n                    ByteBuf response = ctx.alloc().buffer();\n                    response.writeBytes(buffer);\n                    ctx.writeAndFlush(response);\n\n                    // 思考：需要释放 buffer 吗\n                    // 思考：需要释放 response 吗\n                }\n            });\n        }\n    }).bind(8080);\n```\n\n编写 client\n\n```java\nNioEventLoopGroup group = new NioEventLoopGroup();\nChannel channel = new Bootstrap()\n    .group(group)\n    .channel(NioSocketChannel.class)\n    .handler(new ChannelInitializer<NioSocketChannel>() {\n        @Override\n        protected void initChannel(NioSocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new StringEncoder());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                    ByteBuf buffer = (ByteBuf) msg;\n                    System.out.println(buffer.toString(Charset.defaultCharset()));\n\n                    // 思考：需要释放 buffer 吗\n                }\n            });\n        }\n    }).connect(\"127.0.0.1\", 8080).sync().channel();\n\nchannel.closeFuture().addListener(future -> {\n    group.shutdownGracefully();\n});\n\nnew Thread(() -> {\n    Scanner scanner = new Scanner(System.in);\n    while (true) {\n        String line = scanner.nextLine();\n        if (\"q\".equals(line)) {\n            channel.close();\n            break;\n        }\n        channel.writeAndFlush(line);\n    }\n}).start();\n```\n\n\n\n### 💡 读和写的误解\n\n\n\n我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在`A 到 B` 和 `B 到 A` 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读\n\n\n\n例如\n\n```java\npublic class TestServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888);\n        Socket s = ss.accept();\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                // 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n客户端\n\n```java\npublic class TestClient {\n    public static void main(String[] args) throws IOException {\n        Socket s = new Socket(\"localhost\", 8888);\n\n        new Thread(() -> {\n            try {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(s.getInputStream()));\n                while (true) {\n                    System.out.println(reader.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n        new Thread(() -> {\n            try {\n                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(s.getOutputStream()));\n                for (int i = 0; i < 100; i++) {\n                    writer.write(String.valueOf(i));\n                    writer.newLine();\n                    writer.flush();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"Netty02-入门","published":1,"updated":"2023-05-06T13:27:56.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhc0tpou0000d8wef0w30lps","content":"<p>该笔记是B站黑马的Netty视频的配套笔记2。</p>\n<span id=\"more\"></span>\n<h1 id=\"二-Netty-入门\"><a href=\"#二-Netty-入门\" class=\"headerlink\" title=\"二. Netty 入门\"></a>二. Netty 入门</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><h3 id=\"1-1-Netty-是什么？\"><a href=\"#1-1-Netty-是什么？\" class=\"headerlink\" title=\"1.1 Netty 是什么？\"></a>1.1 Netty 是什么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Netty is an asynchronous event-driven network application framework</span><br><span class=\"line\">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure>\n\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<h3 id=\"1-2-Netty-的作者\"><a href=\"#1-2-Netty-的作者\" class=\"headerlink\" title=\"1.2 Netty 的作者\"></a>1.2 Netty 的作者</h3><p><img src=\"/img/0005.png\"></p>\n<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>\n<h3 id=\"1-3-Netty-的地位\"><a href=\"#1-3-Netty-的地位\" class=\"headerlink\" title=\"1.3 Netty 的地位\"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>\n<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>\n<ul>\n<li>Cassandra - nosql 数据库</li>\n<li>Spark - 大数据分布式计算框架</li>\n<li>Hadoop - 大数据分布式存储框架</li>\n<li>RocketMQ - ali 开源的消息队列</li>\n<li>ElasticSearch - 搜索引擎</li>\n<li>gRPC - rpc 框架</li>\n<li>Dubbo - rpc 框架</li>\n<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>\n<li>Zookeeper - 分布式协调框架</li>\n</ul>\n<h3 id=\"1-4-Netty-的优势\"><a href=\"#1-4-Netty-的优势\" class=\"headerlink\" title=\"1.4 Netty 的优势\"></a>1.4 Netty 的优势</h3><ul>\n<li>Netty vs NIO，工作量大，bug 多<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>epoll 空轮询导致 CPU 100%</li>\n<li>对 API 进行增强，使之更易用，如 FastThreadLocal &#x3D;&gt; ThreadLocal，ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n</li>\n<li>Netty vs 其它网络应用框架<ul>\n<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>\n<li>久经考验，16年，Netty 版本<ul>\n<li>2.x 2004</li>\n<li>3.x 2008</li>\n<li>4.x 2013</li>\n<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Hello-World\"><a href=\"#2-Hello-World\" class=\"headerlink\" title=\"2. Hello World\"></a>2. Hello World</h2><h3 id=\"2-1-目标\"><a href=\"#2-1-目标\" class=\"headerlink\" title=\"2.1 目标\"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>\n<ul>\n<li>客户端向服务器端发送 hello, world</li>\n<li>服务器仅接收，不返回</li>\n</ul>\n<p>加入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.39.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"2-2-服务器端\"><a href=\"#2-2-服务器端\" class=\"headerlink\" title=\"2.2 服务器端\"></a>2.2 服务器端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>()) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    .channel(NioServerSocketChannel.class) <span class=\"comment\">// 2</span></span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>()); <span class=\"comment\">// 5</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class=\"comment\">// 6</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>\n</li>\n<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>\n<p><img src=\"/img/0006.png\"></p>\n</li>\n<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>\n</li>\n<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String</p>\n</li>\n<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>\n</li>\n</ul>\n<h3 id=\"2-3-客户端\"><a href=\"#2-3-客户端\" class=\"headerlink\" title=\"2.3 客户端\"></a>2.3 客户端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>()) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    .channel(NioSocketChannel.class) <span class=\"comment\">// 2</span></span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>()); <span class=\"comment\">// 8</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">    .sync() <span class=\"comment\">// 5</span></span><br><span class=\"line\">    .channel() <span class=\"comment\">// 6</span></span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>\n</li>\n<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>\n<p><img src=\"/img/0007.png\"></p>\n</li>\n<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，指定要连接的服务器和端口</p>\n</li>\n<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>\n</li>\n<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>\n</li>\n<li><p>7 处，写入消息并清空缓冲区</p>\n</li>\n<li><p>8 处，消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 发出</p>\n</li>\n<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>\n</li>\n</ul>\n<h3 id=\"2-4-流程梳理\"><a href=\"#2-4-流程梳理\" class=\"headerlink\" title=\"2.4 流程梳理\"></a>2.4 流程梳理</h3><p><img src=\"/img/0040.png\"></p>\n<h4 id=\"💡-提示\"><a href=\"#💡-提示\" class=\"headerlink\" title=\"💡 提示\"></a>💡 提示</h4><blockquote>\n<p>一开始需要树立正确的观念</p>\n<ul>\n<li>把 channel 理解为数据的通道</li>\n<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>把 handler 理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>\n<li>handler 分 Inbound 和 Outbound 两类</li>\n</ul>\n</li>\n<li>把 eventLoop 理解为处理数据的工人<ul>\n<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>\n<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3. 组件\"></a>3. 组件</h2><h3 id=\"3-1-EventLoop\"><a href=\"#3-1-EventLoop\" class=\"headerlink\" title=\"3.1 EventLoop\"></a>3.1 EventLoop</h3><p>事件循环对象</p>\n<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>\n<p>它的继承关系比较复杂</p>\n<ul>\n<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p>事件循环组</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<p>以一个简单的实现为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(group.next());</span><br><span class=\"line\">System.out.println(group.next());</span><br><span class=\"line\">System.out.println(group.next());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用 for 循环</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class=\"line\">    System.out.println(eventLoop);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-优雅关闭\"><a href=\"#💡-优雅关闭\" class=\"headerlink\" title=\"💡 优雅关闭\"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"演示-NioEventLoop-处理-io-事件\"><a href=\"#演示-NioEventLoop-处理-io-事件\" class=\"headerlink\" title=\"演示 NioEventLoop 处理 io 事件\"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> msg <span class=\"keyword\">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (byteBuf != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">                        <span class=\"type\">ByteBuf</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> byteBuf.readBytes(buf, <span class=\"number\">0</span>, byteBuf.readableBytes());</span><br><span class=\"line\">                        log.debug(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>).sync();</span><br></pre></td></tr></table></figure>\n\n<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">            .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;init...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .channel(NioSocketChannel.class).connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">            .sync()</span><br><span class=\"line\">            .channel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class=\"string\">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class=\"string\">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>\n\n<p>最后输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class=\"line\">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class=\"line\">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class=\"line\">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class=\"line\">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class=\"line\">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>\n\n<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>\n<p><img src=\"/img/0042.png\"></p>\n<p>再增加两个非 nio 工人</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">normalWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span>  &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">            ch.pipeline().addLast(normalWorkers,<span class=\"string\">&quot;myhandler&quot;</span>,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> msg <span class=\"keyword\">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (byteBuf != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">                        <span class=\"type\">ByteBuf</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> byteBuf.readBytes(buf, <span class=\"number\">0</span>, byteBuf.readableBytes());</span><br><span class=\"line\">                        log.debug(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>).sync();</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class=\"line\">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class=\"line\">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class=\"line\">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class=\"line\">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class=\"line\">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class=\"line\">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class=\"line\">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class=\"line\">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class=\"line\">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class=\"line\">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class=\"line\">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class=\"line\">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>\n\n<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>\n<p><img src=\"/img/0041.png\"></p>\n<h4 id=\"💡-handler-执行中如何换人？\"><a href=\"#💡-handler-执行中如何换人？\" class=\"headerlink\" title=\"💡 handler 执行中如何换人？\"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">invokeChannelRead</span><span class=\"params\">(<span class=\"keyword\">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class=\"string\">&quot;msg&quot;</span>), next);</span><br><span class=\"line\">    <span class=\"comment\">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class=\"line\">    <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> next.executor();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是，直接调用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor.inEventLoop()) &#123;</span><br><span class=\"line\">        next.invokeChannelRead(m);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                next.invokeChannelRead(m);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>\n</ul>\n<h4 id=\"演示-NioEventLoop-处理普通任务\"><a href=\"#演示-NioEventLoop-处理普通任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理普通任务\"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">nioWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;server start...&quot;</span>);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">nioWorkers.execute(()-&gt;&#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;normal task...&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class=\"line\">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以用来执行耗时较长的任务</p>\n</blockquote>\n<h4 id=\"演示-NioEventLoop-处理定时任务\"><a href=\"#演示-NioEventLoop-处理定时任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理定时任务\"></a>演示 NioEventLoop 处理定时任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">nioWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;server start...&quot;</span>);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;running...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class=\"line\">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以用来执行定时任务</p>\n</blockquote>\n<h3 id=\"3-2-Channel\"><a href=\"#3-2-Channel\" class=\"headerlink\" title=\"3.2 Channel\"></a>3.2 Channel</h3><p>channel 的主要作用</p>\n<ul>\n<li>close() 可以用来关闭 channel</li>\n<li>closeFuture() 用来处理 channel 的关闭<ul>\n<li>sync 方法作用是同步等待 channel 关闭</li>\n<li>而 addListener 方法是异步等待 channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法添加处理器</li>\n<li>write() 方法将数据写入</li>\n<li>writeAndFlush() 方法将数据写入并刷出</li>\n</ul>\n<h4 id=\"ChannelFuture\"><a href=\"#ChannelFuture\" class=\"headerlink\" title=\"ChannelFuture\"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">    .sync()</span><br><span class=\"line\">    .channel()</span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>现在把它拆开来看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">channelFuture.sync().channel().writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>\n</ul>\n<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>\n<p>实验如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 1</span></span><br><span class=\"line\">channelFuture.sync(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>\n<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>\n<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 1</span></span><br><span class=\"line\">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">    System.out.println(future.channel()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>\n<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<h4 id=\"CloseFuture\"><a href=\"#CloseFuture\" class=\"headerlink\" title=\"CloseFuture\"></a>CloseFuture</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CloseFutureClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        NioEventLoopGroup group <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">                .group(group)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span> <span class=\"comment\">// 在连接建立后被调用</span></span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                        ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> channelFuture.sync().channel();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class=\"line\">                    channel.close(); <span class=\"comment\">// close 异步操作 1s 之后</span></span><br><span class=\"line\"><span class=\"comment\">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                channel.writeAndFlush(line);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;input&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">closeFuture</span> <span class=\"operator\">=</span> channel.closeFuture();</span><br><span class=\"line\">        <span class=\"comment\">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        closeFuture.sync();</span></span><br><span class=\"line\"><span class=\"comment\">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class=\"line\">        closeFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class=\"line\">                group.shutdownGracefully();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"💡-异步提升的是什么\"><a href=\"#💡-异步提升的是什么\" class=\"headerlink\" title=\"💡 异步提升的是什么\"></a>💡 异步提升的是什么</h4><ul>\n<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>\n</li>\n<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>\n</li>\n</ul>\n<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>\n<p><img src=\"/img/0044.png\"></p>\n<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>\n<p><img src=\"/img/0048.png\"></p>\n<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>\n<p><img src=\"/img/0047.png\"></p>\n<p>要点</p>\n<ul>\n<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>\n<li>异步并没有缩短响应时间，反而有所增加</li>\n<li>合理进行任务拆分，也是利用异步的关键</li>\n</ul>\n<h3 id=\"3-3-Future-amp-Promise\"><a href=\"#3-3-Future-amp-Promise\" class=\"headerlink\" title=\"3.3 Future &amp; Promise\"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>\n<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h4><p>同步处理任务成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set success, &#123;&#125;&quot;</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    promise.setSuccess(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class=\"comment\">// 还没有结果</span></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,promise.get());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class=\"line\">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h4><p>异步处理任务成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置回调，异步接收结果</span></span><br><span class=\"line\">promise.addListener(future -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 future 就是上面的 promise</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待 1000 后设置成功结果</span></span><br><span class=\"line\">eventExecutors.execute(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set success, &#123;&#125;&quot;</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    promise.setSuccess(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class=\"line\">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">        DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">        eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">            promise.setFailure(e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class=\"line\">        promise.get(); <span class=\"comment\">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class=\"line\">\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class=\"line\">Caused by: java.lang.RuntimeException: error...</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h4><p>同步处理任务失败 - await</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">    promise.setFailure(e);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class=\"line\">promise.await(); <span class=\"comment\">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h4><p>异步处理任务失败</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.addListener(future -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">    promise.setFailure(e);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h4><p>await 死锁检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.submit(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        promise.await();</span><br><span class=\"line\">        <span class=\"comment\">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class=\"line\">        <span class=\"comment\">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; </span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">eventExecutors.submit(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        promise.await();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-4-Handler-amp-Pipeline\"><a href=\"#3-4-Handler-amp-Pipeline\" class=\"headerlink\" title=\"3.4 Handler &amp; Pipeline\"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>\n<ul>\n<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>\n<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>\n</ul>\n<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>\n<p>先搞清楚顺序，服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    ctx.fireChannelRead(msg); <span class=\"comment\">// 1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    ctx.fireChannelRead(msg); <span class=\"comment\">// 2</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    ctx.channel().write(msg); <span class=\"comment\">// 3</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">4</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 4</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">5</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 5</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">6</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 6</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">        future.channel().writeAndFlush(<span class=\"string\">&quot;hello,world&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>服务器端打印：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>\n<p><img src=\"/img/0008.png\"></p>\n<ul>\n<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>\n<li>如果注释掉 1 处代码，则仅会打印 1</li>\n<li>如果注释掉 2 处代码，则仅会打印 1 2</li>\n</ul>\n</li>\n<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>\n<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>\n</ul>\n</li>\n<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>\n<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>\n</ul>\n</li>\n<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>\n<li>都是触发出站处理器的执行</li>\n<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>\n<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>\n<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>\n<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>\n</ul>\n</li>\n</ul>\n<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>\n<p><img src=\"/img/0009.png\"></p>\n<h3 id=\"3-5-ByteBuf\"><a href=\"#3-5-ByteBuf\" class=\"headerlink\" title=\"3.5 ByteBuf\"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>\n<h4 id=\"1）创建\"><a href=\"#1）创建\" class=\"headerlink\" title=\"1）创建\"></a>1）创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">10</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>\n\n<p>其中 log 方法参考如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(ByteBuf buffer)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> buffer.readableBytes();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> length / <span class=\"number\">16</span> + (length % <span class=\"number\">15</span> == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>) + <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(rows * <span class=\"number\">80</span> * <span class=\"number\">2</span>)</span><br><span class=\"line\">        .append(<span class=\"string\">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class=\"line\">        .append(<span class=\"string\">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class=\"line\">        .append(<span class=\"string\">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class=\"line\">        .append(NEWLINE);</span><br><span class=\"line\">    appendPrettyHexDump(buf, buffer);</span><br><span class=\"line\">    System.out.println(buf.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）直接内存-vs-堆内存\"><a href=\"#2）直接内存-vs-堆内存\" class=\"headerlink\" title=\"2）直接内存 vs 堆内存\"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>\n<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<h4 id=\"3）池化-vs-非池化\"><a href=\"#3）池化-vs-非池化\" class=\"headerlink\" title=\"3）池化 vs 非池化\"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>\n<ul>\n<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>\n<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>\n<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<h4 id=\"4）组成\"><a href=\"#4）组成\" class=\"headerlink\" title=\"4）组成\"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>\n<p><img src=\"/img/0010.png\"></p>\n<p>最开始读写指针都在 0 位置</p>\n<h4 id=\"5）写入\"><a href=\"#5）写入\" class=\"headerlink\" title=\"5）写入\"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td>用一字节 01|00 代表 true|false</td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian，即 0x250，写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td>Little Endian，即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 ByteBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>\n<li>网络传输，默认习惯是 Big Endian</li>\n</ul>\n</blockquote>\n<p>先写入 4 个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:4 capacity:10</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>再写入一个 int 整数，也是 4 个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeInt(<span class=\"number\">5</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:8 capacity:10</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>\n<h4 id=\"6）扩容\"><a href=\"#6）扩容\" class=\"headerlink\" title=\"6）扩容\"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeInt(<span class=\"number\">6</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>扩容规则是</p>\n<ul>\n<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>\n<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li>\n<li>扩容不能超过 max capacity 会报错</li>\n</ul>\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"7）读取\"><a href=\"#7）读取\" class=\"headerlink\" title=\"7）读取\"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">read index:4 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果需要重复读取 int 整数 5，怎么办？</p>\n<p>可以在 read 前先做个标记 mark</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.markReaderIndex();</span><br><span class=\"line\">System.out.println(buffer.readInt());</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">read index:8 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 06                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时要重复读取的话，重置到标记位置 reset</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.resetReaderIndex();</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>这时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:4 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>\n<h4 id=\"8）retain-amp-release\"><a href=\"#8）retain-amp-release\" class=\"headerlink\" title=\"8）retain &amp; release\"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>\n</ul>\n<blockquote>\n<p>回收内存的源码实现，请关注下面方法的不同实现</p>\n<p><code>protected abstract void deallocate()</code></p>\n</blockquote>\n<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>\n<ul>\n<li>每个 ByteBuf 对象的初始计数为 1</li>\n<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>\n</ul>\n<p>谁来负责 release 呢？</p>\n<p>不是我们想象的（一般情况下）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    buf.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>\n<ul>\n<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>\n<li>入站 ByteBuf 处理原则<ul>\n<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>\n<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>\n<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>\n<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>\n<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>\n</ul>\n</li>\n<li>出站 ByteBuf 处理原则<ul>\n<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>\n</ul>\n</li>\n<li>异常处理原则<ul>\n<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>\n</ul>\n</li>\n</ul>\n<p>TailContext 释放未处理消息逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUnhandledInboundMessage</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        logger.debug(</span><br><span class=\"line\">            <span class=\"string\">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ReferenceCountUtil.release(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg <span class=\"keyword\">instanceof</span> ReferenceCounted) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ReferenceCounted) msg).release();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"9）slice\"><a href=\"#9）slice\" class=\"headerlink\" title=\"9）slice\"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>\n<p><img src=\"/img/0011.png\"></p>\n<p>例，原始 ByteBuf 进行一些初始操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">origin</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">10</span>);</span><br><span class=\"line\">origin.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">origin.readByte();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">slice</span> <span class=\"operator\">=</span> origin.slice();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class=\"line\"><span class=\"comment\">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin.readByte();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 03 04                                           |..              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时的 slice 不受影响，因为它有独立的读写指针</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果 slice 的内容发生了更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice.setByte(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 05                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 03 05                                           |..              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"10）duplicate\"><a href=\"#10）duplicate\" class=\"headerlink\" title=\"10）duplicate\"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>\n<p><img src=\"/img/0012.png\"></p>\n<h4 id=\"11）copy\"><a href=\"#11）copy\" class=\"headerlink\" title=\"11）copy\"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>\n<h4 id=\"12）CompositeByteBuf\"><a href=\"#12）CompositeByteBuf\" class=\"headerlink\" title=\"12）CompositeByteBuf\"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>\n<p>有两个 ByteBuf 如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf2</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf2.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>\n<p>方法1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT</span><br><span class=\"line\">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class=\"line\">buf3.writeBytes(buf1);</span><br><span class=\"line\">buf3.writeBytes(buf2);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>\n<p>方法2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CompositeByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class=\"line\"><span class=\"comment\">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class=\"line\">buf3.addComponents(<span class=\"literal\">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>\n\n<p>结果是一样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>\n<ul>\n<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>\n<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>\n</ul>\n<h4 id=\"13）Unpooled\"><a href=\"#13）Unpooled\" class=\"headerlink\" title=\"13）Unpooled\"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>\n<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf2</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf2.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf4</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;);</span><br><span class=\"line\">System.out.println(buf4.getClass());</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class io.netty.buffer.CompositeByteBuf</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-ByteBuf-优势\"><a href=\"#💡-ByteBuf-优势\" class=\"headerlink\" title=\"💡 ByteBuf 优势\"></a>💡 ByteBuf 优势</h4><ul>\n<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以自动扩容</li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>\n</ul>\n<h2 id=\"4-双向通信\"><a href=\"#4-双向通信\" class=\"headerlink\" title=\"4. 双向通信\"></a>4. 双向通信</h2><h3 id=\"4-1-练习\"><a href=\"#4-1-练习\" class=\"headerlink\" title=\"4.1 练习\"></a>4.1 练习</h3><p>实现一个 echo server</p>\n<p>编写 server</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    response.writeBytes(buffer);</span><br><span class=\"line\">                    ctx.writeAndFlush(response);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 response 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编写 client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(group)</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\"></span><br><span class=\"line\">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class=\"line\">    group.shutdownGracefully();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class=\"line\">            channel.close();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channel.writeAndFlush(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"💡-读和写的误解\"><a href=\"#💡-读和写的误解\" class=\"headerlink\" title=\"💡 读和写的误解\"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">ss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">8888</span>);</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(s.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    System.out.println(reader.readLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class=\"line\">                <span class=\"comment\">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                    writer.write(String.valueOf(i));</span><br><span class=\"line\">                    writer.newLine();</span><br><span class=\"line\">                    writer.flush();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(s.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    System.out.println(reader.readLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                    writer.write(String.valueOf(i));</span><br><span class=\"line\">                    writer.newLine();</span><br><span class=\"line\">                    writer.flush();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>该笔记是B站黑马的Netty视频的配套笔记2。</p>","more":"<h1 id=\"二-Netty-入门\"><a href=\"#二-Netty-入门\" class=\"headerlink\" title=\"二. Netty 入门\"></a>二. Netty 入门</h1><h2 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h2><h3 id=\"1-1-Netty-是什么？\"><a href=\"#1-1-Netty-是什么？\" class=\"headerlink\" title=\"1.1 Netty 是什么？\"></a>1.1 Netty 是什么？</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Netty is an asynchronous event-driven network application framework</span><br><span class=\"line\">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure>\n\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<h3 id=\"1-2-Netty-的作者\"><a href=\"#1-2-Netty-的作者\" class=\"headerlink\" title=\"1.2 Netty 的作者\"></a>1.2 Netty 的作者</h3><p><img src=\"/img/0005.png\"></p>\n<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>\n<h3 id=\"1-3-Netty-的地位\"><a href=\"#1-3-Netty-的地位\" class=\"headerlink\" title=\"1.3 Netty 的地位\"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>\n<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>\n<ul>\n<li>Cassandra - nosql 数据库</li>\n<li>Spark - 大数据分布式计算框架</li>\n<li>Hadoop - 大数据分布式存储框架</li>\n<li>RocketMQ - ali 开源的消息队列</li>\n<li>ElasticSearch - 搜索引擎</li>\n<li>gRPC - rpc 框架</li>\n<li>Dubbo - rpc 框架</li>\n<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>\n<li>Zookeeper - 分布式协调框架</li>\n</ul>\n<h3 id=\"1-4-Netty-的优势\"><a href=\"#1-4-Netty-的优势\" class=\"headerlink\" title=\"1.4 Netty 的优势\"></a>1.4 Netty 的优势</h3><ul>\n<li>Netty vs NIO，工作量大，bug 多<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>epoll 空轮询导致 CPU 100%</li>\n<li>对 API 进行增强，使之更易用，如 FastThreadLocal &#x3D;&gt; ThreadLocal，ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n</li>\n<li>Netty vs 其它网络应用框架<ul>\n<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>\n<li>久经考验，16年，Netty 版本<ul>\n<li>2.x 2004</li>\n<li>3.x 2008</li>\n<li>4.x 2013</li>\n<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-Hello-World\"><a href=\"#2-Hello-World\" class=\"headerlink\" title=\"2. Hello World\"></a>2. Hello World</h2><h3 id=\"2-1-目标\"><a href=\"#2-1-目标\" class=\"headerlink\" title=\"2.1 目标\"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>\n<ul>\n<li>客户端向服务器端发送 hello, world</li>\n<li>服务器仅接收，不返回</li>\n</ul>\n<p>加入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.39.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"2-2-服务器端\"><a href=\"#2-2-服务器端\" class=\"headerlink\" title=\"2.2 服务器端\"></a>2.2 服务器端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>()) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    .channel(NioServerSocketChannel.class) <span class=\"comment\">// 2</span></span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringDecoder</span>()); <span class=\"comment\">// 5</span></span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class=\"comment\">// 6</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(msg);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>\n</li>\n<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>\n<p><img src=\"/img/0006.png\"></p>\n</li>\n<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>\n</li>\n<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String</p>\n</li>\n<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>\n</li>\n</ul>\n<h3 id=\"2-3-客户端\"><a href=\"#2-3-客户端\" class=\"headerlink\" title=\"2.3 客户端\"></a>2.3 客户端</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>()) <span class=\"comment\">// 1</span></span><br><span class=\"line\">    .channel(NioSocketChannel.class) <span class=\"comment\">// 2</span></span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class=\"comment\">// 3</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>()); <span class=\"comment\">// 8</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">    .sync() <span class=\"comment\">// 5</span></span><br><span class=\"line\">    .channel() <span class=\"comment\">// 6</span></span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>); <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读</p>\n<ul>\n<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>\n</li>\n<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>\n<p><img src=\"/img/0007.png\"></p>\n</li>\n<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>\n</li>\n<li><p>4 处，指定要连接的服务器和端口</p>\n</li>\n<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>\n</li>\n<li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p>\n</li>\n<li><p>7 处，写入消息并清空缓冲区</p>\n</li>\n<li><p>8 处，消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 发出</p>\n</li>\n<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>\n</li>\n</ul>\n<h3 id=\"2-4-流程梳理\"><a href=\"#2-4-流程梳理\" class=\"headerlink\" title=\"2.4 流程梳理\"></a>2.4 流程梳理</h3><p><img src=\"/img/0040.png\"></p>\n<h4 id=\"💡-提示\"><a href=\"#💡-提示\" class=\"headerlink\" title=\"💡 提示\"></a>💡 提示</h4><blockquote>\n<p>一开始需要树立正确的观念</p>\n<ul>\n<li>把 channel 理解为数据的通道</li>\n<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>把 handler 理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>\n<li>handler 分 Inbound 和 Outbound 两类</li>\n</ul>\n</li>\n<li>把 eventLoop 理解为处理数据的工人<ul>\n<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>\n<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"3-组件\"><a href=\"#3-组件\" class=\"headerlink\" title=\"3. 组件\"></a>3. 组件</h2><h3 id=\"3-1-EventLoop\"><a href=\"#3-1-EventLoop\" class=\"headerlink\" title=\"3.1 EventLoop\"></a>3.1 EventLoop</h3><p>事件循环对象</p>\n<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>\n<p>它的继承关系比较复杂</p>\n<ul>\n<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p>事件循环组</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<p>以一个简单的实现为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(group.next());</span><br><span class=\"line\">System.out.println(group.next());</span><br><span class=\"line\">System.out.println(group.next());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用 for 循环</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class=\"line\">    System.out.println(eventLoop);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class=\"line\">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-优雅关闭\"><a href=\"#💡-优雅关闭\" class=\"headerlink\" title=\"💡 优雅关闭\"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"演示-NioEventLoop-处理-io-事件\"><a href=\"#演示-NioEventLoop-处理-io-事件\" class=\"headerlink\" title=\"演示 NioEventLoop 处理 io 事件\"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> msg <span class=\"keyword\">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (byteBuf != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">                        <span class=\"type\">ByteBuf</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> byteBuf.readBytes(buf, <span class=\"number\">0</span>, byteBuf.readableBytes());</span><br><span class=\"line\">                        log.debug(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>).sync();</span><br></pre></td></tr></table></figure>\n\n<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">            .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">            .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;init...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            .channel(NioSocketChannel.class).connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">            .sync()</span><br><span class=\"line\">            .channel();</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class=\"string\">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class=\"string\">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>\n\n<p>最后输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class=\"line\">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class=\"line\">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class=\"line\">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class=\"line\">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class=\"line\">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>\n\n<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>\n<p><img src=\"/img/0042.png\"></p>\n<p>再增加两个非 nio 工人</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoopGroup</span> <span class=\"variable\">normalWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span>  &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">            ch.pipeline().addLast(normalWorkers,<span class=\"string\">&quot;myhandler&quot;</span>,</span><br><span class=\"line\">              <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> msg <span class=\"keyword\">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (byteBuf != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">16</span>];</span><br><span class=\"line\">                        <span class=\"type\">ByteBuf</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> byteBuf.readBytes(buf, <span class=\"number\">0</span>, byteBuf.readableBytes());</span><br><span class=\"line\">                        log.debug(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>).sync();</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class=\"line\">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class=\"line\">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class=\"line\">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class=\"line\">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class=\"line\">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class=\"line\">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class=\"line\">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class=\"line\">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class=\"line\">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class=\"line\">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class=\"line\">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class=\"line\">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>\n\n<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>\n<p><img src=\"/img/0041.png\"></p>\n<h4 id=\"💡-handler-执行中如何换人？\"><a href=\"#💡-handler-执行中如何换人？\" class=\"headerlink\" title=\"💡 handler 执行中如何换人？\"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">invokeChannelRead</span><span class=\"params\">(<span class=\"keyword\">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class=\"string\">&quot;msg&quot;</span>), next);</span><br><span class=\"line\">    <span class=\"comment\">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class=\"line\">    <span class=\"type\">EventExecutor</span> <span class=\"variable\">executor</span> <span class=\"operator\">=</span> next.executor();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 是，直接调用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor.inEventLoop()) &#123;</span><br><span class=\"line\">        next.invokeChannelRead(m);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                next.invokeChannelRead(m);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>\n</ul>\n<h4 id=\"演示-NioEventLoop-处理普通任务\"><a href=\"#演示-NioEventLoop-处理普通任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理普通任务\"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">nioWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;server start...&quot;</span>);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">nioWorkers.execute(()-&gt;&#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;normal task...&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class=\"line\">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以用来执行耗时较长的任务</p>\n</blockquote>\n<h4 id=\"演示-NioEventLoop-处理定时任务\"><a href=\"#演示-NioEventLoop-处理定时任务\" class=\"headerlink\" title=\"演示 NioEventLoop 处理定时任务\"></a>演示 NioEventLoop 处理定时任务</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">nioWorkers</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;server start...&quot;</span>);</span><br><span class=\"line\">Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;running...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class=\"line\">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以用来执行定时任务</p>\n</blockquote>\n<h3 id=\"3-2-Channel\"><a href=\"#3-2-Channel\" class=\"headerlink\" title=\"3.2 Channel\"></a>3.2 Channel</h3><p>channel 的主要作用</p>\n<ul>\n<li>close() 可以用来关闭 channel</li>\n<li>closeFuture() 用来处理 channel 的关闭<ul>\n<li>sync 方法作用是同步等待 channel 关闭</li>\n<li>而 addListener 方法是异步等待 channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法添加处理器</li>\n<li>write() 方法将数据写入</li>\n<li>writeAndFlush() 方法将数据写入并刷出</li>\n</ul>\n<h4 id=\"ChannelFuture\"><a href=\"#ChannelFuture\" class=\"headerlink\" title=\"ChannelFuture\"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">    .sync()</span><br><span class=\"line\">    .channel()</span><br><span class=\"line\">    .writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>现在把它拆开来看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">channelFuture.sync().channel().writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>() + <span class=\"string\">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>\n</ul>\n<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>\n<p>实验如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 1</span></span><br><span class=\"line\">channelFuture.sync(); <span class=\"comment\">// 2</span></span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>\n<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>\n<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\">System.out.println(channelFuture.channel()); <span class=\"comment\">// 1</span></span><br><span class=\"line\">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">    System.out.println(future.channel()); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>\n<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>\n</ul>\n<h4 id=\"CloseFuture\"><a href=\"#CloseFuture\" class=\"headerlink\" title=\"CloseFuture\"></a>CloseFuture</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CloseFutureClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        NioEventLoopGroup group <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">                .group(group)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span> <span class=\"comment\">// 在连接建立后被调用</span></span><br><span class=\"line\">                    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                        ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                        ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> channelFuture.sync().channel();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class=\"line\">                    channel.close(); <span class=\"comment\">// close 异步操作 1s 之后</span></span><br><span class=\"line\"><span class=\"comment\">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                channel.writeAndFlush(line);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"string\">&quot;input&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class=\"line\">        <span class=\"type\">ChannelFuture</span> <span class=\"variable\">closeFuture</span> <span class=\"operator\">=</span> channel.closeFuture();</span><br><span class=\"line\">        <span class=\"comment\">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">        closeFuture.sync();</span></span><br><span class=\"line\"><span class=\"comment\">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class=\"line\">        closeFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class=\"line\">                group.shutdownGracefully();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"💡-异步提升的是什么\"><a href=\"#💡-异步提升的是什么\" class=\"headerlink\" title=\"💡 异步提升的是什么\"></a>💡 异步提升的是什么</h4><ul>\n<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>\n</li>\n<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>\n</li>\n</ul>\n<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>\n<p><img src=\"/img/0044.png\"></p>\n<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>\n<p><img src=\"/img/0048.png\"></p>\n<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>\n<p><img src=\"/img/0047.png\"></p>\n<p>要点</p>\n<ul>\n<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>\n<li>异步并没有缩短响应时间，反而有所增加</li>\n<li>合理进行任务拆分，也是利用异步的关键</li>\n</ul>\n<h3 id=\"3-3-Future-amp-Promise\"><a href=\"#3-3-Future-amp-Promise\" class=\"headerlink\" title=\"3.3 Future &amp; Promise\"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>\n<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h4><p>同步处理任务成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set success, &#123;&#125;&quot;</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    promise.setSuccess(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class=\"comment\">// 还没有结果</span></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,promise.get());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class=\"line\">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h4><p>异步处理任务成功</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置回调，异步接收结果</span></span><br><span class=\"line\">promise.addListener(future -&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 future 就是上面的 promise</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待 1000 后设置成功结果</span></span><br><span class=\"line\">eventExecutors.execute(()-&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set success, &#123;&#125;&quot;</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    promise.setSuccess(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class=\"line\">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">        DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">        eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">            promise.setFailure(e);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class=\"line\">        promise.get(); <span class=\"comment\">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class=\"line\">\tat io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class=\"line\">Caused by: java.lang.RuntimeException: error...</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h4><p>同步处理任务失败 - await</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">    promise.setFailure(e);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class=\"line\">promise.await(); <span class=\"comment\">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class=\"line\">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h4><p>异步处理任务失败</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">promise.addListener(future -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.execute(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">RuntimeException</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;error...&quot;</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class=\"line\">    promise.setFailure(e);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class=\"line\">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class=\"line\">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h4><p>await 死锁检查</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DefaultEventLoop</span> <span class=\"variable\">eventExecutors</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultEventLoop</span>();</span><br><span class=\"line\">DefaultPromise&lt;Integer&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class=\"line\"></span><br><span class=\"line\">eventExecutors.submit(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        promise.await();</span><br><span class=\"line\">        <span class=\"comment\">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class=\"line\">        <span class=\"comment\">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class=\"line\">        <span class=\"comment\">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123; </span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">eventExecutors.submit(()-&gt;&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        promise.await();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class=\"line\">\tat io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class=\"line\">\tat com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class=\"line\">\tat io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class=\"line\">\tat io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class=\"line\">\tat io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class=\"line\">\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class=\"line\">\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:745)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"3-4-Handler-amp-Pipeline\"><a href=\"#3-4-Handler-amp-Pipeline\" class=\"headerlink\" title=\"3.4 Handler &amp; Pipeline\"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>\n<ul>\n<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>\n<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>\n</ul>\n<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>\n<p>先搞清楚顺序，服务端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    ctx.fireChannelRead(msg); <span class=\"comment\">// 1</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">2</span>);</span><br><span class=\"line\">                    ctx.fireChannelRead(msg); <span class=\"comment\">// 2</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">3</span>);</span><br><span class=\"line\">                    ctx.channel().write(msg); <span class=\"comment\">// 3</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">4</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 4</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">5</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 5</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">write</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class=\"line\"><span class=\"params\">                                  ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"number\">6</span>);</span><br><span class=\"line\">                    ctx.write(msg, promise); <span class=\"comment\">// 6</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(Channel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class=\"line\">        future.channel().writeAndFlush(<span class=\"string\">&quot;hello,world&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>服务器端打印：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">6</span><br><span class=\"line\">5</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>\n<p><img src=\"/img/0008.png\"></p>\n<ul>\n<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>\n<li>如果注释掉 1 处代码，则仅会打印 1</li>\n<li>如果注释掉 2 处代码，则仅会打印 1 2</li>\n</ul>\n</li>\n<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>\n<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>\n</ul>\n</li>\n<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>\n<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>\n</ul>\n</li>\n<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>\n<li>都是触发出站处理器的执行</li>\n<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>\n<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>\n<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>\n<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>\n</ul>\n</li>\n</ul>\n<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>\n<p><img src=\"/img/0009.png\"></p>\n<h3 id=\"3-5-ByteBuf\"><a href=\"#3-5-ByteBuf\" class=\"headerlink\" title=\"3.5 ByteBuf\"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>\n<h4 id=\"1）创建\"><a href=\"#1）创建\" class=\"headerlink\" title=\"1）创建\"></a>1）创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">10</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>\n\n<p>其中 log 方法参考如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">log</span><span class=\"params\">(ByteBuf buffer)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> buffer.readableBytes();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> length / <span class=\"number\">16</span> + (length % <span class=\"number\">15</span> == <span class=\"number\">0</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>) + <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(rows * <span class=\"number\">80</span> * <span class=\"number\">2</span>)</span><br><span class=\"line\">        .append(<span class=\"string\">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class=\"line\">        .append(<span class=\"string\">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class=\"line\">        .append(<span class=\"string\">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class=\"line\">        .append(NEWLINE);</span><br><span class=\"line\">    appendPrettyHexDump(buf, buffer);</span><br><span class=\"line\">    System.out.println(buf.toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）直接内存-vs-堆内存\"><a href=\"#2）直接内存-vs-堆内存\" class=\"headerlink\" title=\"2）直接内存 vs 堆内存\"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>\n<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<h4 id=\"3）池化-vs-非池化\"><a href=\"#3）池化-vs-非池化\" class=\"headerlink\" title=\"3）池化 vs 非池化\"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>\n<ul>\n<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>\n<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>\n<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<h4 id=\"4）组成\"><a href=\"#4）组成\" class=\"headerlink\" title=\"4）组成\"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>\n<p><img src=\"/img/0010.png\"></p>\n<p>最开始读写指针都在 0 位置</p>\n<h4 id=\"5）写入\"><a href=\"#5）写入\" class=\"headerlink\" title=\"5）写入\"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td>用一字节 01|00 代表 true|false</td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian，即 0x250，写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td>Little Endian，即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 ByteBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>\n<li>网络传输，默认习惯是 Big Endian</li>\n</ul>\n</blockquote>\n<p>先写入 4 个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:4 capacity:10</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>再写入一个 int 整数，也是 4 个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeInt(<span class=\"number\">5</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:8 capacity:10</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>\n<h4 id=\"6）扩容\"><a href=\"#6）扩容\" class=\"headerlink\" title=\"6）扩容\"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.writeInt(<span class=\"number\">6</span>);</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>扩容规则是</p>\n<ul>\n<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>\n<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10&#x3D;1024（2^9&#x3D;512 已经不够了）</li>\n<li>扩容不能超过 max capacity 会报错</li>\n</ul>\n<p>结果是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:0 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"7）读取\"><a href=\"#7）读取\" class=\"headerlink\" title=\"7）读取\"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">System.out.println(buffer.readByte());</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">read index:4 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果需要重复读取 int 整数 5，怎么办？</p>\n<p>可以在 read 前先做个标记 mark</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.markReaderIndex();</span><br><span class=\"line\">System.out.println(buffer.readInt());</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">read index:8 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 06                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时要重复读取的话，重置到标记位置 reset</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buffer.resetReaderIndex();</span><br><span class=\"line\">log(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>这时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read index:4 write index:12 capacity:16</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>\n<h4 id=\"8）retain-amp-release\"><a href=\"#8）retain-amp-release\" class=\"headerlink\" title=\"8）retain &amp; release\"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>\n</ul>\n<blockquote>\n<p>回收内存的源码实现，请关注下面方法的不同实现</p>\n<p><code>protected abstract void deallocate()</code></p>\n</blockquote>\n<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>\n<ul>\n<li>每个 ByteBuf 对象的初始计数为 1</li>\n<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>\n</ul>\n<p>谁来负责 release 呢？</p>\n<p>不是我们想象的（一般情况下）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    buf.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>\n<ul>\n<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>\n<li>入站 ByteBuf 处理原则<ul>\n<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>\n<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>\n<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>\n<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>\n<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>\n</ul>\n</li>\n<li>出站 ByteBuf 处理原则<ul>\n<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>\n</ul>\n</li>\n<li>异常处理原则<ul>\n<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>\n</ul>\n</li>\n</ul>\n<p>TailContext 释放未处理消息逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onUnhandledInboundMessage</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        logger.debug(</span><br><span class=\"line\">            <span class=\"string\">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        ReferenceCountUtil.release(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">release</span><span class=\"params\">(Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (msg <span class=\"keyword\">instanceof</span> ReferenceCounted) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ReferenceCounted) msg).release();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"9）slice\"><a href=\"#9）slice\" class=\"headerlink\" title=\"9）slice\"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>\n<p><img src=\"/img/0011.png\"></p>\n<p>例，原始 ByteBuf 进行一些初始操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">origin</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">10</span>);</span><br><span class=\"line\">origin.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">origin.readByte();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">slice</span> <span class=\"operator\">=</span> origin.slice();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class=\"line\"><span class=\"comment\">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">origin.readByte();</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 03 04                                           |..              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时的 slice 不受影响，因为它有独立的读写指针</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 04                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>如果 slice 的内容发生了更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice.setByte(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 02 03 05                                        |...             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 03 05                                           |..              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"10）duplicate\"><a href=\"#10）duplicate\" class=\"headerlink\" title=\"10）duplicate\"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>\n<p><img src=\"/img/0012.png\"></p>\n<h4 id=\"11）copy\"><a href=\"#11）copy\" class=\"headerlink\" title=\"11）copy\"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>\n<h4 id=\"12）CompositeByteBuf\"><a href=\"#12）CompositeByteBuf\" class=\"headerlink\" title=\"12）CompositeByteBuf\"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>\n<p>有两个 ByteBuf 如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf2</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf2.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>\n<p>方法1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT</span><br><span class=\"line\">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class=\"line\">buf3.writeBytes(buf1);</span><br><span class=\"line\">buf3.writeBytes(buf2);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>\n\n<p>结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>\n<p>方法2：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">CompositeByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class=\"line\"><span class=\"comment\">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class=\"line\">buf3.addComponents(<span class=\"literal\">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>\n\n<p>结果是一样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>\n<ul>\n<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>\n<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>\n</ul>\n<h4 id=\"13）Unpooled\"><a href=\"#13）Unpooled\" class=\"headerlink\" title=\"13）Unpooled\"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>\n<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf1</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf1.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf2</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer(<span class=\"number\">5</span>);</span><br><span class=\"line\">buf2.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf3</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf4</span> <span class=\"operator\">=</span> Unpooled.wrappedBuffer(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;, <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>&#125;);</span><br><span class=\"line\">System.out.println(buf4.getClass());</span><br><span class=\"line\">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class io.netty.buffer.CompositeByteBuf</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"💡-ByteBuf-优势\"><a href=\"#💡-ByteBuf-优势\" class=\"headerlink\" title=\"💡 ByteBuf 优势\"></a>💡 ByteBuf 优势</h4><ul>\n<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以自动扩容</li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>\n</ul>\n<h2 id=\"4-双向通信\"><a href=\"#4-双向通信\" class=\"headerlink\" title=\"4. 双向通信\"></a>4. 双向通信</h2><h3 id=\"4-1-练习\"><a href=\"#4-1-练习\" class=\"headerlink\" title=\"4.1 练习\"></a>4.1 练习</h3><p>实现一个 echo server</p>\n<p>编写 server</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>()</span><br><span class=\"line\">    .group(<span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>())</span><br><span class=\"line\">    .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">    .childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    response.writeBytes(buffer);</span><br><span class=\"line\">                    ctx.writeAndFlush(response);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 response 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).bind(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编写 client</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">    .group(group)</span><br><span class=\"line\">    .channel(NioSocketChannel.class)</span><br><span class=\"line\">    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">StringEncoder</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 思考：需要释放 buffer 吗</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\"></span><br><span class=\"line\">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class=\"line\">    group.shutdownGracefully();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">line</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class=\"line\">            channel.close();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        channel.writeAndFlush(line);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"💡-读和写的误解\"><a href=\"#💡-读和写的误解\" class=\"headerlink\" title=\"💡 读和写的误解\"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>\n<p>例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">ss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">8888</span>);</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(s.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    System.out.println(reader.readLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class=\"line\">                <span class=\"comment\">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                    writer.write(String.valueOf(i));</span><br><span class=\"line\">                    writer.newLine();</span><br><span class=\"line\">                    writer.flush();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(s.getInputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                    System.out.println(reader.readLine());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">BufferedWriter</span> <span class=\"variable\">writer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">                    writer.write(String.valueOf(i));</span><br><span class=\"line\">                    writer.newLine();</span><br><span class=\"line\">                    writer.flush();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Netty04-优化与源码","date":"2023-05-06T13:26:15.000Z","_content":"\n该笔记是B站黑马的Netty视频的配套笔记4。\n<!-- more -->\n# 四. 优化与源码\n\n## 1. 优化\n\n### 1.1 扩展序列化算法\n\n序列化，反序列化主要用在消息正文的转换上\n\n* 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\n* 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\n\n目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\n\n```java\n// 反序列化\nbyte[] body = new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message = (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n// 序列化\nByteArrayOutputStream out = new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes = out.toByteArray();\n```\n\n为了支持更多序列化算法，抽象一个 Serializer 接口\n\n```java\npublic interface Serializer {\n\n    // 反序列化方法\n    <T> T deserialize(Class<T> clazz, byte[] bytes);\n\n    // 序列化方法\n    <T> byte[] serialize(T object);\n\n}\n```\n\n提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\n\n```java\nenum SerializerAlgorithm implements Serializer {\n\t// Java 实现\n    Java {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            try {\n                ObjectInputStream in = \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object = in.readObject();\n                return (T) object;\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 反序列化错误\", e);\n            }\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            try {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            } catch (IOException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 序列化错误\", e);\n            }\n        }\n    }, \n    // Json 实现(引入了 Gson 依赖)\n    Json {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);\n        }\n    };\n\n    // 需要从协议的字节中得到是哪种序列化算法\n    public static SerializerAlgorithm getByInt(int type) {\n        SerializerAlgorithm[] array = SerializerAlgorithm.values();\n        if (type < 0 || type > array.length - 1) {\n            throw new IllegalArgumentException(\"超过 SerializerAlgorithm 范围\");\n        }\n        return array[type];\n    }\n}\n```\n\n\n\n增加配置类和配置文件\n\n```java\npublic abstract class Config {\n    static Properties properties;\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n        } catch (IOException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    public static int getServerPort() {\n        String value = properties.getProperty(\"server.port\");\n        if(value == null) {\n            return 8080;\n        } else {\n            return Integer.parseInt(value);\n        }\n    }\n    public static Serializer.Algorithm getSerializerAlgorithm() {\n        String value = properties.getProperty(\"serializer.algorithm\");\n        if(value == null) {\n            return Serializer.Algorithm.Java;\n        } else {\n            return Serializer.Algorithm.valueOf(value);\n        }\n    }\n}\n```\n\n\n\n配置文件\n\n```properties\nserializer.algorithm=Json\n```\n\n\n\n修改编解码器\n\n```java\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerAlgorithm = in.readByte(); // 0 或 1\n        byte messageType = in.readByte(); // 0,1,2...\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n\n        // 找到反序列化算法\n        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];\n        // 确定具体消息类型\n        Class<? extends Message> messageClass = Message.getMessageClass(messageType);\n        Message message = algorithm.deserialize(messageClass, bytes);\n//        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n//        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n其中确定具体消息类型，可以根据 `消息类型字节` 获取到对应的 `消息 class`\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    /**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     */\n    public static Class<? extends Message> getMessageClass(int messageType) {\n        return messageClasses.get(messageType);\n    }\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage = 0;\n    public static final int LoginResponseMessage = 1;\n    public static final int ChatRequestMessage = 2;\n    public static final int ChatResponseMessage = 3;\n    public static final int GroupCreateRequestMessage = 4;\n    public static final int GroupCreateResponseMessage = 5;\n    public static final int GroupJoinRequestMessage = 6;\n    public static final int GroupJoinResponseMessage = 7;\n    public static final int GroupQuitRequestMessage = 8;\n    public static final int GroupQuitResponseMessage = 9;\n    public static final int GroupChatRequestMessage = 10;\n    public static final int GroupChatResponseMessage = 11;\n    public static final int GroupMembersRequestMessage = 12;\n    public static final int GroupMembersResponseMessage = 13;\n    public static final int PingMessage = 14;\n    public static final int PongMessage = 15;\n    private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>();\n\n    static {\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    }\n}\n```\n\n\n\n### 1.2 参数调优\n\n#### 1）CONNECT_TIMEOUT_MILLIS\n\n* 属于 SocketChannal 参数\n* 用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\n\n* SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\n\n```java\n@Slf4j\npublic class TestConnectionTimeout {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future = bootstrap.connect(\"127.0.0.1\", 8080);\n            future.sync().channel().closeFuture().sync(); // 断点1\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.debug(\"timeout\");\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n另外源码部分 `io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect`\n\n```java\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    // Schedule connect timeout.\n    int connectTimeoutMillis = config().getConnectTimeoutMillis();\n    if (connectTimeoutMillis > 0) {\n        connectTimeoutFuture = eventLoop().schedule(new Runnable() {\n            @Override\n            public void run() {                \n                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause =\n                    new ConnectTimeoutException(\"connection timed out: \" + remoteAddress); // 断点2\n                if (connectPromise != null && connectPromise.tryFailure(cause)) {\n                    close(voidPromise());\n                }\n            }\n        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\t// ...\n}\n```\n\n\n\n#### 2）SO_BACKLOG\n\n* 属于 ServerSocketChannal 参数\n\n```mermaid\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as syns queue\nparticipant aq as accept queue\n\ns ->> s : bind()\ns ->> s : listen()\nc ->> c : connect()\nc ->> s : 1. SYN\nNote left of c : SYN_SEND\ns ->> sq : put\nNote right of s : SYN_RCVD\ns ->> c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc ->> s : 3. ACK\nsq ->> aq : put\nNote right of s : ESTABLISHED\naq -->> s : \ns ->> s : accept()\n```\n\n1. 第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\n2. 第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\n3. 第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\n\n其中\n\n* 在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\n\n* sync queue - 半连接队列\n  * 大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 `syncookies` 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n* accept queue - 全连接队列\n  * 其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\n  * 如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\n\n\n\nnetty 中\n\n可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小\n\n\n\n可以通过下面源码查看默认大小\n\n```java\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig {\n\n    private volatile int backlog = NetUtil.SOMAXCONN;\n    // ...\n}\n```\n\n\n\n课堂调试关键断点为：`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n\n\noio 中更容易说明，不用 debug 模式\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888, 2);\n        Socket accept = ss.accept();\n        System.out.println(accept);\n        System.in.read();\n    }\n}\n```\n\n客户端启动 4 个\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        try {\n            Socket s = new Socket();\n            System.out.println(new Date()+\" connecting...\");\n            s.connect(new InetSocketAddress(\"localhost\", 8888),1000);\n            System.out.println(new Date()+\" connected...\");\n            s.getOutputStream().write(1);\n            System.in.read();\n        } catch (IOException e) {\n            System.out.println(new Date()+\" connecting timeout...\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\n\n```java\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...\n```\n\n第 4 个客户端连接时\n\n```\nTue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out\n```\n\n\n\n\n\n#### 3）ulimit -n\n\n* 属于操作系统参数\n\n\n\n#### 4）TCP_NODELAY\n\n* 属于 SocketChannal 参数\n\n\n\n#### 5）SO_SNDBUF & SO_RCVBUF\n\n* SO_SNDBUF 属于 SocketChannal 参数\n* SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n\n\n\n#### 6）ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 用来分配 ByteBuf， ctx.alloc()\n\n\n\n#### 7）RCVBUF_ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 控制 netty 接收缓冲区大小\n* 负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\n\n\n\n### 1.3 RPC 框架\n\n#### 1）准备工作\n\n这些代码可以认为是现成的，无需从头编写练习\n\n为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    // 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;\n\n    static {\n        // ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    }\n\n}\n```\n\n请求消息\n\n```java\n@Getter\n@ToString(callSuper = true)\npublic class RpcRequestMessage extends Message {\n\n    /**\n     * 调用的接口全限定名，服务端根据它找到实现\n     */\n    private String interfaceName;\n    /**\n     * 调用接口中的方法名\n     */\n    private String methodName;\n    /**\n     * 方法返回类型\n     */\n    private Class<?> returnType;\n    /**\n     * 方法参数类型数组\n     */\n    private Class[] parameterTypes;\n    /**\n     * 方法参数值数组\n     */\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) {\n        super.setSequenceId(sequenceId);\n        this.interfaceName = interfaceName;\n        this.methodName = methodName;\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.parameterValue = parameterValue;\n    }\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_REQUEST;\n    }\n}\n```\n\n响应消息\n\n```java\n@Data\n@ToString(callSuper = true)\npublic class RpcResponseMessage extends Message {\n    /**\n     * 返回值\n     */\n    private Object returnValue;\n    /**\n     * 异常值\n     */\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    }\n}\n```\n\n服务器架子\n\n```java\n@Slf4j\npublic class RpcServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端架子\n\n```java\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的 service 获取\n\n```java\npublic class ServicesFactory {\n\n    static Properties properties;\n    static Map<Class<?>, Object> map = new ConcurrentHashMap<>();\n\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n            Set<String> names = properties.stringPropertyNames();\n            for (String name : names) {\n                if (name.endsWith(\"Service\")) {\n                    Class<?> interfaceClass = Class.forName(name);\n                    Class<?> instanceClass = Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                }\n            }\n        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    public static <T> T getService(Class<T> interfaceClass) {\n        return (T) map.get(interfaceClass);\n    }\n}\n```\n\n相关配置 application.properties\n\n```\nserializer.algorithm=Json\ncn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl\n```\n\n\n\n#### 2）服务器 handler\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> {\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) {\n        RpcResponseMessage response = new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());\n        try {\n            // 获取真正的实现对象\n            HelloService service = (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            // 获取要调用的方法\n            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            // 调用方法\n            Object invoke = method.invoke(service, message.getParameterValue());\n            // 调用成功\n            response.setReturnValue(invoke);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 调用异常\n            response.setExceptionValue(e);\n        }\n        // 返回结果\n        ctx.writeAndFlush(response);\n    }\n}\n```\n\n\n\n\n\n#### 3）客户端代码第一版\n\n只发消息\n\n```java\n@Slf4j\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n\n            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    \"cn.itcast.server.service.HelloService\",\n                    \"sayHello\",\n                    String.class,\n                    new Class[]{String.class},\n                    new Object[]{\"张三\"}\n            )).addListener(promise -> {\n                if (!promise.isSuccess()) {\n                    Throwable cause = promise.cause();\n                    log.error(\"error\", cause);\n                }\n            });\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n#### 4）客户端 handler 第一版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n    }\n}\n```\n\n\n\n\n\n#### 5）客户端代码 第二版\n\n包括 channel 管理，代理，接收结果\n\n```java\n@Slf4j\npublic class RpcClientManager {\n\n\n    public static void main(String[] args) {\n        HelloService service = getProxyService(HelloService.class);\n        System.out.println(service.sayHello(\"zhangsan\"));\n//        System.out.println(service.sayHello(\"lisi\"));\n//        System.out.println(service.sayHello(\"wangwu\"));\n    }\n\n    // 创建代理类\n    public static <T> T getProxyService(Class<T> serviceClass) {\n        ClassLoader loader = serviceClass.getClassLoader();\n        Class<?>[] interfaces = new Class[]{serviceClass};\n        //                                                            sayHello  \"张三\"\n        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> {\n            // 1. 将方法调用转换为 消息对象\n            int sequenceId = SequenceIdGenerator.nextId();\n            RpcRequestMessage msg = new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            // 2. 将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程\n            DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop());\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n//            promise.addListener(future -> {\n//                // 线程\n//            });\n\n            // 4. 等待 promise 结果\n            promise.await();\n            if(promise.isSuccess()) {\n                // 调用正常\n                return promise.getNow();\n            } else {\n                // 调用失败\n                throw new RuntimeException(promise.cause());\n            }\n        });\n        return (T) o;\n    }\n\n    private static Channel channel = null;\n    private static final Object LOCK = new Object();\n\n    // 获取唯一的 channel 对象\n    public static Channel getChannel() {\n        if (channel != null) {\n            return channel;\n        }\n        synchronized (LOCK) { //  t2\n            if (channel != null) { // t1\n                return channel;\n            }\n            initChannel();\n            return channel;\n        }\n    }\n\n    // 初始化 channel 方法\n    private static void initChannel() {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            }\n        });\n        try {\n            channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().addListener(future -> {\n                group.shutdownGracefully();\n            });\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        }\n    }\n}\n```\n\n\n\n#### 6）客户端 handler 第二版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n\n    //                       序号      用来接收结果的 promise 对象\n    public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n        // 拿到空的 promise\n        Promise<Object> promise = PROMISES.remove(msg.getSequenceId());\n        if (promise != null) {\n            Object returnValue = msg.getReturnValue();\n            Exception exceptionValue = msg.getExceptionValue();\n            if(exceptionValue != null) {\n                promise.setFailure(exceptionValue);\n            } else {\n                promise.setSuccess(returnValue);\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n## 2. 源码分析\n\n### 2.1 启动剖析\n\n我们就来看看 netty 中对下面的代码是怎样进行处理的\n\n```java\n//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector = Selector.open(); \n\n//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment = new NioServerSocketChannel();\n\n//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n//4 启动 nio boss 线程执行接下来的操作\n\n//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);\n\n//6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor\n\n//7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n//8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n```\n\n\n\n\n\n\n\n入口 `io.netty.bootstrap.ServerBootstrap#bind`\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind`\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n\t// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) {\n        return regFuture;\n    }\n\n    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    // 2.1 如果已经完成\n    if (regFuture.isDone()) {\n        ChannelPromise promise = channel.newPromise();\n        // 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    } \n    // 2.2 还没有完成\n    else {\n        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n        // 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                Throwable cause = future.cause();\n                if (cause != null) {\n                    // 处理异常...\n                    promise.setFailure(cause);\n                } else {\n                    promise.registered();\n\t\t\t\t\t// 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                }\n            }\n        });\n        return promise;\n    }\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#initAndRegister`\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    try {\n        channel = channelFactory.newChannel();\n        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    } catch (Throwable t) {\n        // 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    }\n\n    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) {\n        // 处理异常...\n    }\n    return regFuture;\n}\n```\n\n关键代码 `io.netty.bootstrap.ServerBootstrap#init`\n\n```java\n// 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception {\n    final Map<ChannelOption<?>, Object> options = options0();\n    synchronized (options) {\n        setChannelOptions(channel, options, logger);\n    }\n\n    final Map<AttributeKey<?>, Object> attrs = attrs0();\n    synchronized (attrs) {\n        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n            @SuppressWarnings(\"unchecked\")\n            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n            channel.attr(key).set(e.getValue());\n        }\n    }\n\n    ChannelPipeline p = channel.pipeline();\n\n    final EventLoopGroup currentChildGroup = childGroup;\n    final ChannelHandler currentChildHandler = childHandler;\n    final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n    synchronized (childOptions) {\n        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));\n    }\n    synchronized (childAttrs) {\n        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));\n    }\n\t\n    // 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer<Channel>() {\n        @Override\n        public void initChannel(final Channel ch) throws Exception {\n            final ChannelPipeline pipeline = ch.pipeline();\n            ChannelHandler handler = config.handler();\n            if (handler != null) {\n                pipeline.addLast(handler);\n            }\n\n            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() {\n                @Override\n                public void run() {\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                }\n            });\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行\n            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            // 这行代码完成的事实是 main -> nio boss 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\n        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        // 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) {\n            if (firstRegistration) {\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        // Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n关键代码 `io.netty.channel.ChannelInitializer#initChannel`\n\n```java\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n    if (initMap.add(ctx)) { // Guard against re-entrance.\n        try {\n            // 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        } catch (Throwable cause) {\n            exceptionCaught(ctx, cause);\n        } finally {\n            // 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline = ctx.pipeline();\n            if (pipeline.context(this) != null) {\n                pipeline.remove(this);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind0`\n\n```java\n// 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) {\n\n    channel.eventLoop().execute(new Runnable() {\n        @Override\n        public void run() {\n            if (regFuture.isSuccess()) {\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                promise.setFailure(regFuture.cause());\n            }\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#bind`\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) {\n        return;\n    }\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&\n        localAddress instanceof InetSocketAddress &&\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&\n        !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {\n        // 记录日志...\n    }\n\n    boolean wasActive = isActive();\n    try {\n        // 3.3 执行端口绑定\n        doBind(localAddress);\n    } catch (Throwable t) {\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    }\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // 3.4 触发 active 事件\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n\n    safeSetSuccess(promise);\n}\n```\n\n3.3 关键代码 `io.netty.channel.socket.nio.NioServerSocketChannel#doBind`\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n```\n\n3.4 关键代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();\n}\n```\n\n关键代码 `io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps & readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.2 NioEventLoop 剖析\n\nNioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\n\n提交任务代码 `io.netty.util.concurrent.SingleThreadEventExecutor#execute`\n\n```java\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException(\"task\");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) {\n        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) {\n            // 如果已经 shutdown，做拒绝逻辑，代码略...\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    }\n}\n```\n\n\n\n唤醒 select 阻塞线程`io.netty.channel.nio.NioEventLoop#wakeup`\n\n```java\n@Override\nprotected void wakeup(boolean inEventLoop) {\n    if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n        selector.wakeup();\n    }\n}\n```\n\n\n\n启动 EventLoop 主循环 `io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread`\n\n```java\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            // 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            } finally {\n\t\t\t\t// 清理工作，代码略...\n            }\n        }\n    });\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#run` 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\n\n```java\nprotected void run() {\n    for (;;) {\n        try {\n            try {\n                // calculateStrategy 的逻辑如下：\n                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        // 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp = wakenUp.getAndSet(false);\n                        \n                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        // 下面的 select 方法不会阻塞\n                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        // 才能执行，让 select 方法无谓阻塞\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                }\n            } catch (IOException e) {\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // ioRatio 默认是 50\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // ioRatio 为 100 时，总是运行完所有非 IO 任务\n                    runAllTasks();\n                }\n            } else {                \n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // 记录 io 事件处理耗时\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    // 运行非 IO 任务，一旦超时会退出 runAllTasks\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n\n\n#### ⚠️ 注意\n\n> 这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\n>\n> * 由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\n> * 由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\n\n\n\n参考下图\n\n<img src=\"img/0032.png\"  />\n\n\n\n`io.netty.channel.nio.NioEventLoop#select`\n\n```java\nprivate void select(boolean oldWakenUp) throws IOException {\n    Selector selector = this.selector;\n    try {\n        int selectCnt = 0;\n        long currentTimeNanos = System.nanoTime();\n        // 计算等待时间\n        // * 没有 scheduledTask，超时时间为 1s\n        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`\n        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) {\n            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;\n            // 如果超时，退出循环\n            if (timeoutMillis <= 0) {\n                if (selectCnt == 0) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                }\n                break;\n            }\n\n            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                selector.selectNow();\n                selectCnt = 1;\n                break;\n            }\n\n            // select 有限时阻塞\n            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%\n            int selectedKeys = selector.select(timeoutMillis);\n            // 计数加 1\n            selectCnt ++;\n\n            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环\n            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                break;\n            }\n            if (Thread.interrupted()) {\n               \t// 线程被打断，退出循环\n                // 记录日志\n                selectCnt = 1;\n                break;\n            }\n\n            long time = System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                // 如果超时，计数重置为 1，下次循环就会 break\n                selectCnt = 1;\n            } \n            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            // 这是为了解决 nio 空轮询 bug\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {\n                // 重建 selector\n                selector = selectRebuildSelector(selectCnt);\n                selectCnt = 1;\n                break;\n            }\n\n            currentTimeNanos = time;\n        }\n\n        if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) {\n            // 记录日志\n        }\n    } catch (CancelledKeyException e) {\n        // 记录日志\n    }\n}\n```\n\n\n\n处理 keys `io.netty.channel.nio.NioEventLoop#processSelectedKeys`\n\n```java\nprivate void processSelectedKeys() {\n    if (selectedKeys != null) {\n        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();\n    } else {\n        processSelectedKeysPlain(selector.selectedKeys());\n    }\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n    // 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) {\n        // 无效时处理...\n        return;\n    }\n\n    try {\n        int readyOps = k.readyOps();\n        // 连接事件\n        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n            int ops = k.interestOps();\n            ops &= ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        }\n\n        // 可写事件\n        if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n            ch.unsafe().forceFlush();\n        }\n\n        // 可读或可接入事件\n        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();\n        }\n    } catch (CancelledKeyException ignored) {\n        unsafe.close(unsafe.voidPromise());\n    }\n}\n```\n\n\n\n### 2.3 accept 剖析\n\nnio 中如下代码，在 netty 中的流程\n\n```java\n//1 阻塞直到事件发生\nselector.select();\n\nIterator<SelectionKey> iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) {    \n    //2 拿到一个事件\n    SelectionKey key = iter.next();\n    \n    //3 如果是 accept 事件\n    if (key.isAcceptable()) {\n        \n        //4 执行 accept\n        SocketChannel channel = serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        //5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n先来看可接入事件处理（accept）\n\n`io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read`\n\n```java\npublic void read() {\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config = config();\n    final ChannelPipeline pipeline = pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed = false;\n    Throwable exception = null;\n    try {\n        try {\n            do {\n\t\t\t\t// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf\n                // readBuf 是一个 ArrayList 用来缓存消息\n                int localRead = doReadMessages(readBuf);\n                if (localRead == 0) {\n                    break;\n                }\n                if (localRead < 0) {\n                    closed = true;\n                    break;\n                }\n\t\t\t\t// localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            } while (allocHandle.continueReading());\n        } catch (Throwable t) {\n            exception = t;\n        }\n\n        int size = readBuf.size();\n        for (int i = 0; i < size; i ++) {\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        }\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception != null) {\n            closed = closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        }\n\n        if (closed) {\n            inputShutdown = true;\n            if (isOpen()) {\n                close(voidPromise());\n            }\n        }\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n关键代码 `io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead`\n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // 这时的 msg 是 NioSocketChannel\n    final Channel child = (Channel) msg;\n\n    // NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    // 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n        child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n    }\n\n    try {\n        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}\n```\n\n\n\n又回到了熟悉的 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`  方法\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 这行代码完成的事实是 nio boss -> nio worker 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\t\t\n        // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        // 执行后就是 head -> logging handler -> my handler -> tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) {\n            if (firstRegistration) {\n                // 触发 pipeline 上 active 事件\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n\n\n回到了熟悉的代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n}\n```\n\n`io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\t// 这时候 interestOps 是 0\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps & readInterestOp) == 0) {\n        // 关注 read 事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.4 read 剖析\n\n再来看可读事件 `io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read`，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\n\n```java\npublic final void read() {\n    final ChannelConfig config = config();\n    if (shouldBreakReadReady(config)) {\n        clearReadPending();\n        return;\n    }\n    final ChannelPipeline pipeline = pipeline();\n    // io.netty.allocator.type 决定 allocator 的实现\n    final ByteBufAllocator allocator = config.getAllocator();\n    // 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            // 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() <= 0) {\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() < 0;\n                if (close) {\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } \n        // 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        // 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)`\n\n```java\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {\n    return \n           // 一般为 true\n           config.isAutoRead() &&\n           // respectMaybeMoreData 默认为 true\n           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&\n           // 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages < maxMessagePerRead &&\n           // 实际读到了数据\n           totalBytesRead > 0;\n}\n```\n\n\n\n\n","source":"_posts/2023-05-06-Netty04-优化与源码.md","raw":"---\ntitle: Netty04-优化与源码\ndate: 2023-05-06 21:26:15\ntags: \n- Netty\n- programing\n- Java\ncategories: Netty\n---\n\n该笔记是B站黑马的Netty视频的配套笔记4。\n<!-- more -->\n# 四. 优化与源码\n\n## 1. 优化\n\n### 1.1 扩展序列化算法\n\n序列化，反序列化主要用在消息正文的转换上\n\n* 序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）\n* 反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理\n\n目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下\n\n```java\n// 反序列化\nbyte[] body = new byte[bodyLength];\nbyteByf.readBytes(body);\nObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(body));\nMessage message = (Message) in.readObject();\nmessage.setSequenceId(sequenceId);\n\n// 序列化\nByteArrayOutputStream out = new ByteArrayOutputStream();\nnew ObjectOutputStream(out).writeObject(message);\nbyte[] bytes = out.toByteArray();\n```\n\n为了支持更多序列化算法，抽象一个 Serializer 接口\n\n```java\npublic interface Serializer {\n\n    // 反序列化方法\n    <T> T deserialize(Class<T> clazz, byte[] bytes);\n\n    // 序列化方法\n    <T> byte[] serialize(T object);\n\n}\n```\n\n提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中\n\n```java\nenum SerializerAlgorithm implements Serializer {\n\t// Java 实现\n    Java {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            try {\n                ObjectInputStream in = \n                    new ObjectInputStream(new ByteArrayInputStream(bytes));\n                Object object = in.readObject();\n                return (T) object;\n            } catch (IOException | ClassNotFoundException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 反序列化错误\", e);\n            }\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            try {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                new ObjectOutputStream(out).writeObject(object);\n                return out.toByteArray();\n            } catch (IOException e) {\n                throw new RuntimeException(\"SerializerAlgorithm.Java 序列化错误\", e);\n            }\n        }\n    }, \n    // Json 实现(引入了 Gson 依赖)\n    Json {\n        @Override\n        public <T> T deserialize(Class<T> clazz, byte[] bytes) {\n            return new Gson().fromJson(new String(bytes, StandardCharsets.UTF_8), clazz);\n        }\n\n        @Override\n        public <T> byte[] serialize(T object) {\n            return new Gson().toJson(object).getBytes(StandardCharsets.UTF_8);\n        }\n    };\n\n    // 需要从协议的字节中得到是哪种序列化算法\n    public static SerializerAlgorithm getByInt(int type) {\n        SerializerAlgorithm[] array = SerializerAlgorithm.values();\n        if (type < 0 || type > array.length - 1) {\n            throw new IllegalArgumentException(\"超过 SerializerAlgorithm 范围\");\n        }\n        return array[type];\n    }\n}\n```\n\n\n\n增加配置类和配置文件\n\n```java\npublic abstract class Config {\n    static Properties properties;\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n        } catch (IOException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n    public static int getServerPort() {\n        String value = properties.getProperty(\"server.port\");\n        if(value == null) {\n            return 8080;\n        } else {\n            return Integer.parseInt(value);\n        }\n    }\n    public static Serializer.Algorithm getSerializerAlgorithm() {\n        String value = properties.getProperty(\"serializer.algorithm\");\n        if(value == null) {\n            return Serializer.Algorithm.Java;\n        } else {\n            return Serializer.Algorithm.valueOf(value);\n        }\n    }\n}\n```\n\n\n\n配置文件\n\n```properties\nserializer.algorithm=Json\n```\n\n\n\n修改编解码器\n\n```java\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    public void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(Config.getSerializerAlgorithm().ordinal());\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        byte[] bytes = Config.getSerializerAlgorithm().serialize(msg);\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerAlgorithm = in.readByte(); // 0 或 1\n        byte messageType = in.readByte(); // 0,1,2...\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n\n        // 找到反序列化算法\n        Serializer.Algorithm algorithm = Serializer.Algorithm.values()[serializerAlgorithm];\n        // 确定具体消息类型\n        Class<? extends Message> messageClass = Message.getMessageClass(messageType);\n        Message message = algorithm.deserialize(messageClass, bytes);\n//        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n//        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n其中确定具体消息类型，可以根据 `消息类型字节` 获取到对应的 `消息 class`\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    /**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     */\n    public static Class<? extends Message> getMessageClass(int messageType) {\n        return messageClasses.get(messageType);\n    }\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage = 0;\n    public static final int LoginResponseMessage = 1;\n    public static final int ChatRequestMessage = 2;\n    public static final int ChatResponseMessage = 3;\n    public static final int GroupCreateRequestMessage = 4;\n    public static final int GroupCreateResponseMessage = 5;\n    public static final int GroupJoinRequestMessage = 6;\n    public static final int GroupJoinResponseMessage = 7;\n    public static final int GroupQuitRequestMessage = 8;\n    public static final int GroupQuitResponseMessage = 9;\n    public static final int GroupChatRequestMessage = 10;\n    public static final int GroupChatResponseMessage = 11;\n    public static final int GroupMembersRequestMessage = 12;\n    public static final int GroupMembersResponseMessage = 13;\n    public static final int PingMessage = 14;\n    public static final int PongMessage = 15;\n    private static final Map<Integer, Class<? extends Message>> messageClasses = new HashMap<>();\n\n    static {\n        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);\n    }\n}\n```\n\n\n\n### 1.2 参数调优\n\n#### 1）CONNECT_TIMEOUT_MILLIS\n\n* 属于 SocketChannal 参数\n* 用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\n\n* SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间\n\n```java\n@Slf4j\npublic class TestConnectionTimeout {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap()\n                    .group(group)\n                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)\n                    .channel(NioSocketChannel.class)\n                    .handler(new LoggingHandler());\n            ChannelFuture future = bootstrap.connect(\"127.0.0.1\", 8080);\n            future.sync().channel().closeFuture().sync(); // 断点1\n        } catch (Exception e) {\n            e.printStackTrace();\n            log.debug(\"timeout\");\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n另外源码部分 `io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect`\n\n```java\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {\n    // ...\n    // Schedule connect timeout.\n    int connectTimeoutMillis = config().getConnectTimeoutMillis();\n    if (connectTimeoutMillis > 0) {\n        connectTimeoutFuture = eventLoop().schedule(new Runnable() {\n            @Override\n            public void run() {                \n                ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause =\n                    new ConnectTimeoutException(\"connection timed out: \" + remoteAddress); // 断点2\n                if (connectPromise != null && connectPromise.tryFailure(cause)) {\n                    close(voidPromise());\n                }\n            }\n        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    }\n\t// ...\n}\n```\n\n\n\n#### 2）SO_BACKLOG\n\n* 属于 ServerSocketChannal 参数\n\n```mermaid\nsequenceDiagram\n\nparticipant c as client\nparticipant s as server\nparticipant sq as syns queue\nparticipant aq as accept queue\n\ns ->> s : bind()\ns ->> s : listen()\nc ->> c : connect()\nc ->> s : 1. SYN\nNote left of c : SYN_SEND\ns ->> sq : put\nNote right of s : SYN_RCVD\ns ->> c : 2. SYN + ACK\nNote left of c : ESTABLISHED\nc ->> s : 3. ACK\nsq ->> aq : put\nNote right of s : ESTABLISHED\naq -->> s : \ns ->> s : accept()\n```\n\n1. 第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列\n2. 第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server\n3. 第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue\n\n其中\n\n* 在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制\n\n* sync queue - 半连接队列\n  * 大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 `syncookies` 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n* accept queue - 全连接队列\n  * 其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\n  * 如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\n\n\n\nnetty 中\n\n可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小\n\n\n\n可以通过下面源码查看默认大小\n\n```java\npublic class DefaultServerSocketChannelConfig extends DefaultChannelConfig\n                                              implements ServerSocketChannelConfig {\n\n    private volatile int backlog = NetUtil.SOMAXCONN;\n    // ...\n}\n```\n\n\n\n课堂调试关键断点为：`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n\n\noio 中更容易说明，不用 debug 模式\n\n```java\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket ss = new ServerSocket(8888, 2);\n        Socket accept = ss.accept();\n        System.out.println(accept);\n        System.in.read();\n    }\n}\n```\n\n客户端启动 4 个\n\n```java\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        try {\n            Socket s = new Socket();\n            System.out.println(new Date()+\" connecting...\");\n            s.connect(new InetSocketAddress(\"localhost\", 8888),1000);\n            System.out.println(new Date()+\" connected...\");\n            s.getOutputStream().write(1);\n            System.in.read();\n        } catch (IOException e) {\n            System.out.println(new Date()+\" connecting timeout...\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中\n\n```java\nTue Apr 21 20:30:28 CST 2020 connecting...\nTue Apr 21 20:30:28 CST 2020 connected...\n```\n\n第 4 个客户端连接时\n\n```\nTue Apr 21 20:53:58 CST 2020 connecting...\nTue Apr 21 20:53:59 CST 2020 connecting timeout...\njava.net.SocketTimeoutException: connect timed out\n```\n\n\n\n\n\n#### 3）ulimit -n\n\n* 属于操作系统参数\n\n\n\n#### 4）TCP_NODELAY\n\n* 属于 SocketChannal 参数\n\n\n\n#### 5）SO_SNDBUF & SO_RCVBUF\n\n* SO_SNDBUF 属于 SocketChannal 参数\n* SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n\n\n\n#### 6）ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 用来分配 ByteBuf， ctx.alloc()\n\n\n\n#### 7）RCVBUF_ALLOCATOR\n\n* 属于 SocketChannal 参数\n* 控制 netty 接收缓冲区大小\n* 负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\n\n\n\n### 1.3 RPC 框架\n\n#### 1）准备工作\n\n这些代码可以认为是现成的，无需从头编写练习\n\n为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息\n\n```java\n@Data\npublic abstract class Message implements Serializable {\n\n    // 省略旧的代码\n\n    public static final int RPC_MESSAGE_TYPE_REQUEST = 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE = 102;\n\n    static {\n        // ...\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    }\n\n}\n```\n\n请求消息\n\n```java\n@Getter\n@ToString(callSuper = true)\npublic class RpcRequestMessage extends Message {\n\n    /**\n     * 调用的接口全限定名，服务端根据它找到实现\n     */\n    private String interfaceName;\n    /**\n     * 调用接口中的方法名\n     */\n    private String methodName;\n    /**\n     * 方法返回类型\n     */\n    private Class<?> returnType;\n    /**\n     * 方法参数类型数组\n     */\n    private Class[] parameterTypes;\n    /**\n     * 方法参数值数组\n     */\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class<?> returnType, Class[] parameterTypes, Object[] parameterValue) {\n        super.setSequenceId(sequenceId);\n        this.interfaceName = interfaceName;\n        this.methodName = methodName;\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.parameterValue = parameterValue;\n    }\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_REQUEST;\n    }\n}\n```\n\n响应消息\n\n```java\n@Data\n@ToString(callSuper = true)\npublic class RpcResponseMessage extends Message {\n    /**\n     * 返回值\n     */\n    private Object returnValue;\n    /**\n     * 异常值\n     */\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() {\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    }\n}\n```\n\n服务器架子\n\n```java\n@Slf4j\npublic class RpcServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 请求消息处理器，待实现\n        RpcRequestMessageHandler RPC_HANDLER = new RpcRequestMessageHandler();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端架子\n\n```java\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        \n        // rpc 响应消息处理器，待实现\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的 service 获取\n\n```java\npublic class ServicesFactory {\n\n    static Properties properties;\n    static Map<Class<?>, Object> map = new ConcurrentHashMap<>();\n\n    static {\n        try (InputStream in = Config.class.getResourceAsStream(\"/application.properties\")) {\n            properties = new Properties();\n            properties.load(in);\n            Set<String> names = properties.stringPropertyNames();\n            for (String name : names) {\n                if (name.endsWith(\"Service\")) {\n                    Class<?> interfaceClass = Class.forName(name);\n                    Class<?> instanceClass = Class.forName(properties.getProperty(name));\n                    map.put(interfaceClass, instanceClass.newInstance());\n                }\n            }\n        } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    public static <T> T getService(Class<T> interfaceClass) {\n        return (T) map.get(interfaceClass);\n    }\n}\n```\n\n相关配置 application.properties\n\n```\nserializer.algorithm=Json\ncn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl\n```\n\n\n\n#### 2）服务器 handler\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler<RpcRequestMessage> {\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage message) {\n        RpcResponseMessage response = new RpcResponseMessage();\n        response.setSequenceId(message.getSequenceId());\n        try {\n            // 获取真正的实现对象\n            HelloService service = (HelloService)\n                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));\n            \n            // 获取要调用的方法\n            Method method = service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());\n            \n            // 调用方法\n            Object invoke = method.invoke(service, message.getParameterValue());\n            // 调用成功\n            response.setReturnValue(invoke);\n        } catch (Exception e) {\n            e.printStackTrace();\n            // 调用异常\n            response.setExceptionValue(e);\n        }\n        // 返回结果\n        ctx.writeAndFlush(response);\n    }\n}\n```\n\n\n\n\n\n#### 3）客户端代码第一版\n\n只发消息\n\n```java\n@Slf4j\npublic class RpcClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(RPC_HANDLER);\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n\n            ChannelFuture future = channel.writeAndFlush(new RpcRequestMessage(\n                    1,\n                    \"cn.itcast.server.service.HelloService\",\n                    \"sayHello\",\n                    String.class,\n                    new Class[]{String.class},\n                    new Object[]{\"张三\"}\n            )).addListener(promise -> {\n                if (!promise.isSuccess()) {\n                    Throwable cause = promise.cause();\n                    log.error(\"error\", cause);\n                }\n            });\n\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n#### 4）客户端 handler 第一版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n    }\n}\n```\n\n\n\n\n\n#### 5）客户端代码 第二版\n\n包括 channel 管理，代理，接收结果\n\n```java\n@Slf4j\npublic class RpcClientManager {\n\n\n    public static void main(String[] args) {\n        HelloService service = getProxyService(HelloService.class);\n        System.out.println(service.sayHello(\"zhangsan\"));\n//        System.out.println(service.sayHello(\"lisi\"));\n//        System.out.println(service.sayHello(\"wangwu\"));\n    }\n\n    // 创建代理类\n    public static <T> T getProxyService(Class<T> serviceClass) {\n        ClassLoader loader = serviceClass.getClassLoader();\n        Class<?>[] interfaces = new Class[]{serviceClass};\n        //                                                            sayHello  \"张三\"\n        Object o = Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -> {\n            // 1. 将方法调用转换为 消息对象\n            int sequenceId = SequenceIdGenerator.nextId();\n            RpcRequestMessage msg = new RpcRequestMessage(\n                    sequenceId,\n                    serviceClass.getName(),\n                    method.getName(),\n                    method.getReturnType(),\n                    method.getParameterTypes(),\n                    args\n            );\n            // 2. 将消息对象发送出去\n            getChannel().writeAndFlush(msg);\n\n            // 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程\n            DefaultPromise<Object> promise = new DefaultPromise<>(getChannel().eventLoop());\n            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);\n\n//            promise.addListener(future -> {\n//                // 线程\n//            });\n\n            // 4. 等待 promise 结果\n            promise.await();\n            if(promise.isSuccess()) {\n                // 调用正常\n                return promise.getNow();\n            } else {\n                // 调用失败\n                throw new RuntimeException(promise.cause());\n            }\n        });\n        return (T) o;\n    }\n\n    private static Channel channel = null;\n    private static final Object LOCK = new Object();\n\n    // 获取唯一的 channel 对象\n    public static Channel getChannel() {\n        if (channel != null) {\n            return channel;\n        }\n        synchronized (LOCK) { //  t2\n            if (channel != null) { // t1\n                return channel;\n            }\n            initChannel();\n            return channel;\n        }\n    }\n\n    // 初始化 channel 方法\n    private static void initChannel() {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        RpcResponseMessageHandler RPC_HANDLER = new RpcResponseMessageHandler();\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                ch.pipeline().addLast(new ProcotolFrameDecoder());\n                ch.pipeline().addLast(LOGGING_HANDLER);\n                ch.pipeline().addLast(MESSAGE_CODEC);\n                ch.pipeline().addLast(RPC_HANDLER);\n            }\n        });\n        try {\n            channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().addListener(future -> {\n                group.shutdownGracefully();\n            });\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        }\n    }\n}\n```\n\n\n\n#### 6）客户端 handler 第二版\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler<RpcResponseMessage> {\n\n    //                       序号      用来接收结果的 promise 对象\n    public static final Map<Integer, Promise<Object>> PROMISES = new ConcurrentHashMap<>();\n\n    @Override\n\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception {\n        log.debug(\"{}\", msg);\n        // 拿到空的 promise\n        Promise<Object> promise = PROMISES.remove(msg.getSequenceId());\n        if (promise != null) {\n            Object returnValue = msg.getReturnValue();\n            Exception exceptionValue = msg.getExceptionValue();\n            if(exceptionValue != null) {\n                promise.setFailure(exceptionValue);\n            } else {\n                promise.setSuccess(returnValue);\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n## 2. 源码分析\n\n### 2.1 启动剖析\n\n我们就来看看 netty 中对下面的代码是怎样进行处理的\n\n```java\n//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector = Selector.open(); \n\n//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment = new NioServerSocketChannel();\n\n//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n//4 启动 nio boss 线程执行接下来的操作\n\n//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey = serverSocketChannel.register(selector, 0, attachment);\n\n//6 head -> 初始化器 -> ServerBootstrapAcceptor -> tail，初始化器是一次性的，只为添加 acceptor\n\n//7 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n//8 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n```\n\n\n\n\n\n\n\n入口 `io.netty.bootstrap.ServerBootstrap#bind`\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind`\n\n```java\nprivate ChannelFuture doBind(final SocketAddress localAddress) {\n\t// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) {\n        return regFuture;\n    }\n\n    // 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分\n    // 2.1 如果已经完成\n    if (regFuture.isDone()) {\n        ChannelPromise promise = channel.newPromise();\n        // 3.1 立刻调用 doBind0\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    } \n    // 2.2 还没有完成\n    else {\n        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n        // 3.2 回调 doBind0\n        regFuture.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                Throwable cause = future.cause();\n                if (cause != null) {\n                    // 处理异常...\n                    promise.setFailure(cause);\n                } else {\n                    promise.registered();\n\t\t\t\t\t// 3. 由注册线程去执行 doBind0\n                    doBind0(regFuture, channel, localAddress, promise);\n                }\n            }\n        });\n        return promise;\n    }\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#initAndRegister`\n\n```java\nfinal ChannelFuture initAndRegister() {\n    Channel channel = null;\n    try {\n        channel = channelFactory.newChannel();\n        // 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer\n        init(channel);\n    } catch (Throwable t) {\n        // 处理异常...\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    }\n\n    // 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) {\n        // 处理异常...\n    }\n    return regFuture;\n}\n```\n\n关键代码 `io.netty.bootstrap.ServerBootstrap#init`\n\n```java\n// 这里 channel 实际上是 NioServerSocketChannel\nvoid init(Channel channel) throws Exception {\n    final Map<ChannelOption<?>, Object> options = options0();\n    synchronized (options) {\n        setChannelOptions(channel, options, logger);\n    }\n\n    final Map<AttributeKey<?>, Object> attrs = attrs0();\n    synchronized (attrs) {\n        for (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {\n            @SuppressWarnings(\"unchecked\")\n            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();\n            channel.attr(key).set(e.getValue());\n        }\n    }\n\n    ChannelPipeline p = channel.pipeline();\n\n    final EventLoopGroup currentChildGroup = childGroup;\n    final ChannelHandler currentChildHandler = childHandler;\n    final Entry<ChannelOption<?>, Object>[] currentChildOptions;\n    final Entry<AttributeKey<?>, Object>[] currentChildAttrs;\n    synchronized (childOptions) {\n        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));\n    }\n    synchronized (childAttrs) {\n        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));\n    }\n\t\n    // 为 NioServerSocketChannel 添加初始化器\n    p.addLast(new ChannelInitializer<Channel>() {\n        @Override\n        public void initChannel(final Channel ch) throws Exception {\n            final ChannelPipeline pipeline = ch.pipeline();\n            ChannelHandler handler = config.handler();\n            if (handler != null) {\n                pipeline.addLast(handler);\n            }\n\n            // 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel\n            ch.eventLoop().execute(new Runnable() {\n                @Override\n                public void run() {\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                }\n            });\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行\n            // 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程\n            // 这行代码完成的事实是 main -> nio boss 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        // 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\n        // 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        // 对应 server socket channel 还未绑定，isActive 为 false\n        if (isActive()) {\n            if (firstRegistration) {\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        // Close the channel directly to avoid FD leak.\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n关键代码 `io.netty.channel.ChannelInitializer#initChannel`\n\n```java\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n    if (initMap.add(ctx)) { // Guard against re-entrance.\n        try {\n            // 1.2.2.1 执行初始化\n            initChannel((C) ctx.channel());\n        } catch (Throwable cause) {\n            exceptionCaught(ctx, cause);\n        } finally {\n            // 1.2.2.2 移除初始化器\n            ChannelPipeline pipeline = ctx.pipeline();\n            if (pipeline.context(this) != null) {\n                pipeline.remove(this);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n关键代码 `io.netty.bootstrap.AbstractBootstrap#doBind0`\n\n```java\n// 3.1 或 3.2 执行 doBind0\nprivate static void doBind0(\n        final ChannelFuture regFuture, final Channel channel,\n        final SocketAddress localAddress, final ChannelPromise promise) {\n\n    channel.eventLoop().execute(new Runnable() {\n        @Override\n        public void run() {\n            if (regFuture.isSuccess()) {\n                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n            } else {\n                promise.setFailure(regFuture.cause());\n            }\n        }\n    });\n}\n```\n\n关键代码 `io.netty.channel.AbstractChannel.AbstractUnsafe#bind`\n\n```java\npublic final void bind(final SocketAddress localAddress, final ChannelPromise promise) {\n    assertEventLoop();\n\n    if (!promise.setUncancellable() || !ensureOpen(promise)) {\n        return;\n    }\n\n    if (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &&\n        localAddress instanceof InetSocketAddress &&\n        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &&\n        !PlatformDependent.isWindows() && !PlatformDependent.maybeSuperUser()) {\n        // 记录日志...\n    }\n\n    boolean wasActive = isActive();\n    try {\n        // 3.3 执行端口绑定\n        doBind(localAddress);\n    } catch (Throwable t) {\n        safeSetFailure(promise, t);\n        closeIfClosed();\n        return;\n    }\n\n    if (!wasActive && isActive()) {\n        invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                // 3.4 触发 active 事件\n                pipeline.fireChannelActive();\n            }\n        });\n    }\n\n    safeSetSuccess(promise);\n}\n```\n\n3.3 关键代码 `io.netty.channel.socket.nio.NioServerSocketChannel#doBind`\n\n```java\nprotected void doBind(SocketAddress localAddress) throws Exception {\n    if (PlatformDependent.javaVersion() >= 7) {\n        javaChannel().bind(localAddress, config.getBacklog());\n    } else {\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    }\n}\n```\n\n3.4 关键代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)\n    readIfIsAutoRead();\n}\n```\n\n关键代码 `io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\n    final int interestOps = selectionKey.interestOps();\n    // readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件\n    if ((interestOps & readInterestOp) == 0) {\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.2 NioEventLoop 剖析\n\nNioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），\n\n提交任务代码 `io.netty.util.concurrent.SingleThreadEventExecutor#execute`\n\n```java\npublic void execute(Runnable task) {\n    if (task == null) {\n        throw new NullPointerException(\"task\");\n    }\n\n    boolean inEventLoop = inEventLoop();\n    // 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列\n    addTask(task);\n    if (!inEventLoop) {\n        // inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread\n        startThread();\n        if (isShutdown()) {\n            // 如果已经 shutdown，做拒绝逻辑，代码略...\n        }\n    }\n\n    if (!addTaskWakesUp && wakesUpForTask(task)) {\n        // 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程\n        wakeup(inEventLoop);\n    }\n}\n```\n\n\n\n唤醒 select 阻塞线程`io.netty.channel.nio.NioEventLoop#wakeup`\n\n```java\n@Override\nprotected void wakeup(boolean inEventLoop) {\n    if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n        selector.wakeup();\n    }\n}\n```\n\n\n\n启动 EventLoop 主循环 `io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread`\n\n```java\nprivate void doStartThread() {\n    assert thread == null;\n    executor.execute(new Runnable() {\n        @Override\n        public void run() {\n            // 将线程池的当前线程保存在成员变量中，以便后续使用\n            thread = Thread.currentThread();\n            if (interrupted) {\n                thread.interrupt();\n            }\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try {\n                // 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            } catch (Throwable t) {\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            } finally {\n\t\t\t\t// 清理工作，代码略...\n            }\n        }\n    });\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#run` 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件\n\n```java\nprotected void run() {\n    for (;;) {\n        try {\n            try {\n                // calculateStrategy 的逻辑如下：\n                // 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch\n                // 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n\n                    case SelectStrategy.BUSY_WAIT:\n\n                    case SelectStrategy.SELECT:\n                        // 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒\n                        // 进行 select 阻塞，并设置唤醒状态为 false\n                        boolean oldWakenUp = wakenUp.getAndSet(false);\n                        \n                        // 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup\n                        // 下面的 select 方法不会阻塞\n                        // 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?\n                        // 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时\n                        // 才能执行，让 select 方法无谓阻塞\n                        select(oldWakenUp);\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                }\n            } catch (IOException e) {\n                rebuildSelector0();\n                handleLoopException(e);\n                continue;\n            }\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // ioRatio 默认是 50\n            final int ioRatio = this.ioRatio;\n            if (ioRatio == 100) {\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // ioRatio 为 100 时，总是运行完所有非 IO 任务\n                    runAllTasks();\n                }\n            } else {                \n                final long ioStartTime = System.nanoTime();\n                try {\n                    processSelectedKeys();\n                } finally {\n                    // 记录 io 事件处理耗时\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    // 运行非 IO 任务，一旦超时会退出 runAllTasks\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n        try {\n            if (isShuttingDown()) {\n                closeAll();\n                if (confirmShutdown()) {\n                    return;\n                }\n            }\n        } catch (Throwable t) {\n            handleLoopException(t);\n        }\n    }\n}\n```\n\n\n\n#### ⚠️ 注意\n\n> 这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：\n>\n> * 由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程\n> * 由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作\n\n\n\n参考下图\n\n<img src=\"img/0032.png\"  />\n\n\n\n`io.netty.channel.nio.NioEventLoop#select`\n\n```java\nprivate void select(boolean oldWakenUp) throws IOException {\n    Selector selector = this.selector;\n    try {\n        int selectCnt = 0;\n        long currentTimeNanos = System.nanoTime();\n        // 计算等待时间\n        // * 没有 scheduledTask，超时时间为 1s\n        // * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`\n        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);\n\n        for (;;) {\n            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;\n            // 如果超时，退出循环\n            if (timeoutMillis <= 0) {\n                if (selectCnt == 0) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                }\n                break;\n            }\n\n            // 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行\n            // wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup\n            if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                selector.selectNow();\n                selectCnt = 1;\n                break;\n            }\n\n            // select 有限时阻塞\n            // 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%\n            int selectedKeys = selector.select(timeoutMillis);\n            // 计数加 1\n            selectCnt ++;\n\n            // 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环\n            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                break;\n            }\n            if (Thread.interrupted()) {\n               \t// 线程被打断，退出循环\n                // 记录日志\n                selectCnt = 1;\n                break;\n            }\n\n            long time = System.nanoTime();\n            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                // 如果超时，计数重置为 1，下次循环就会 break\n                selectCnt = 1;\n            } \n            // 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512\n            // 这是为了解决 nio 空轮询 bug\n            else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {\n                // 重建 selector\n                selector = selectRebuildSelector(selectCnt);\n                selectCnt = 1;\n                break;\n            }\n\n            currentTimeNanos = time;\n        }\n\n        if (selectCnt > MIN_PREMATURE_SELECTOR_RETURNS) {\n            // 记录日志\n        }\n    } catch (CancelledKeyException e) {\n        // 记录日志\n    }\n}\n```\n\n\n\n处理 keys `io.netty.channel.nio.NioEventLoop#processSelectedKeys`\n\n```java\nprivate void processSelectedKeys() {\n    if (selectedKeys != null) {\n        // 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet \n        // SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）\n        processSelectedKeysOptimized();\n    } else {\n        processSelectedKeysPlain(selector.selectedKeys());\n    }\n}\n```\n\n\n\n`io.netty.channel.nio.NioEventLoop#processSelectedKey`\n\n```java\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {\n    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n    // 当 key 取消或关闭时会导致这个 key 无效\n    if (!k.isValid()) {\n        // 无效时处理...\n        return;\n    }\n\n    try {\n        int readyOps = k.readyOps();\n        // 连接事件\n        if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n            int ops = k.interestOps();\n            ops &= ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        }\n\n        // 可写事件\n        if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n            ch.unsafe().forceFlush();\n        }\n\n        // 可读或可接入事件\n        if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n            // 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read\n            // 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read\n            unsafe.read();\n        }\n    } catch (CancelledKeyException ignored) {\n        unsafe.close(unsafe.voidPromise());\n    }\n}\n```\n\n\n\n### 2.3 accept 剖析\n\nnio 中如下代码，在 netty 中的流程\n\n```java\n//1 阻塞直到事件发生\nselector.select();\n\nIterator<SelectionKey> iter = selector.selectedKeys().iterator();\nwhile (iter.hasNext()) {    \n    //2 拿到一个事件\n    SelectionKey key = iter.next();\n    \n    //3 如果是 accept 事件\n    if (key.isAcceptable()) {\n        \n        //4 执行 accept\n        SocketChannel channel = serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        //5 关注 read 事件\n        channel.register(selector, SelectionKey.OP_READ);\n    }\n    // ...\n}\n```\n\n\n\n\n\n\n\n先来看可接入事件处理（accept）\n\n`io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read`\n\n```java\npublic void read() {\n    assert eventLoop().inEventLoop();\n    final ChannelConfig config = config();\n    final ChannelPipeline pipeline = pipeline();    \n    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    boolean closed = false;\n    Throwable exception = null;\n    try {\n        try {\n            do {\n\t\t\t\t// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf\n                // readBuf 是一个 ArrayList 用来缓存消息\n                int localRead = doReadMessages(readBuf);\n                if (localRead == 0) {\n                    break;\n                }\n                if (localRead < 0) {\n                    closed = true;\n                    break;\n                }\n\t\t\t\t// localRead 为 1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            } while (allocHandle.continueReading());\n        } catch (Throwable t) {\n            exception = t;\n        }\n\n        int size = readBuf.size();\n        for (int i = 0; i < size; i ++) {\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理\n            // io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        }\n        readBuf.clear();\n        allocHandle.readComplete();\n        pipeline.fireChannelReadComplete();\n\n        if (exception != null) {\n            closed = closeOnReadError(exception);\n\n            pipeline.fireExceptionCaught(exception);\n        }\n\n        if (closed) {\n            inputShutdown = true;\n            if (isOpen()) {\n                close(voidPromise());\n            }\n        }\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n关键代码 `io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead`\n\n```java\npublic void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // 这时的 msg 是 NioSocketChannel\n    final Channel child = (Channel) msg;\n\n    // NioSocketChannel 添加  childHandler 即初始化器\n    child.pipeline().addLast(childHandler);\n\n    // 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n        child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n    }\n\n    try {\n        // 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程\n        childGroup.register(child).addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                if (!future.isSuccess()) {\n                    forceClose(child, future.cause());\n                }\n            }\n        });\n    } catch (Throwable t) {\n        forceClose(child, t);\n    }\n}\n```\n\n\n\n又回到了熟悉的 `io.netty.channel.AbstractChannel.AbstractUnsafe#register`  方法\n\n```java\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) {\n    // 一些检查，略...\n\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    if (eventLoop.inEventLoop()) {\n        register0(promise);\n    } else {\n        try {\n            // 这行代码完成的事实是 nio boss -> nio worker 线程的切换\n            eventLoop.execute(new Runnable() {\n                @Override\n                public void run() {\n                    register0(promise);\n                }\n            });\n        } catch (Throwable t) {\n            // 日志记录...\n            closeForcibly();\n            closeFuture.setClosed();\n            safeSetFailure(promise, t);\n        }\n    }\n}\n```\n\n`io.netty.channel.AbstractChannel.AbstractUnsafe#register0`\n\n```java\nprivate void register0(ChannelPromise promise) {\n    try {\n        if (!promise.setUncancellable() || !ensureOpen(promise)) {\n            return;\n        }\n        boolean firstRegistration = neverRegistered;\n        doRegister();\n        neverRegistered = false;\n        registered = true;\n\t\t\n        // 执行初始化器，执行前 pipeline 中只有 head -> 初始化器 -> tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        // 执行后就是 head -> logging handler -> my handler -> tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) {\n            if (firstRegistration) {\n                // 触发 pipeline 上 active 事件\n                pipeline.fireChannelActive();\n            } else if (config().isAutoRead()) {\n                beginRead();\n            }\n        }\n    } catch (Throwable t) {\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    }\n}\n```\n\n\n\n回到了熟悉的代码 `io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive`\n\n```java\npublic void channelActive(ChannelHandlerContext ctx) {\n    ctx.fireChannelActive();\n\t// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n}\n```\n\n`io.netty.channel.nio.AbstractNioChannel#doBeginRead`\n\n```java\nprotected void doBeginRead() throws Exception {\n    // Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey = this.selectionKey;\n    if (!selectionKey.isValid()) {\n        return;\n    }\n\n    readPending = true;\n\t// 这时候 interestOps 是 0\n    final int interestOps = selectionKey.interestOps();\n    if ((interestOps & readInterestOp) == 0) {\n        // 关注 read 事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    }\n}\n```\n\n\n\n### 2.4 read 剖析\n\n再来看可读事件 `io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read`，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete\n\n```java\npublic final void read() {\n    final ChannelConfig config = config();\n    if (shouldBreakReadReady(config)) {\n        clearReadPending();\n        return;\n    }\n    final ChannelPipeline pipeline = pipeline();\n    // io.netty.allocator.type 决定 allocator 的实现\n    final ByteBufAllocator allocator = config.getAllocator();\n    // 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf = null;\n    boolean close = false;\n    try {\n        do {\n            byteBuf = allocHandle.allocate(allocator);\n            // 读取\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() <= 0) {\n                byteBuf.release();\n                byteBuf = null;\n                close = allocHandle.lastBytesRead() < 0;\n                if (close) {\n                    readPending = false;\n                }\n                break;\n            }\n\n            allocHandle.incMessagesRead(1);\n            readPending = false;\n            // 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf = null;\n        } \n        // 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        // 触发 read complete 事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) {\n            closeOnRead(pipeline);\n        }\n    } catch (Throwable t) {\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    } finally {\n        if (!readPending && !config.isAutoRead()) {\n            removeReadOp();\n        }\n    }\n}\n```\n\n\n\n`io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)`\n\n```java\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) {\n    return \n           // 一般为 true\n           config.isAutoRead() &&\n           // respectMaybeMoreData 默认为 true\n           // maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &&\n           // 小于最大次数，maxMessagePerRead 默认 16\n           totalMessages < maxMessagePerRead &&\n           // 实际读到了数据\n           totalBytesRead > 0;\n}\n```\n\n\n\n\n","slug":"Netty04-优化与源码","published":1,"updated":"2023-05-06T13:28:02.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhc0tpoy0003d8we5kg68stk","content":"<p>该笔记是B站黑马的Netty视频的配套笔记4。</p>\n<span id=\"more\"></span>\n<h1 id=\"四-优化与源码\"><a href=\"#四-优化与源码\" class=\"headerlink\" title=\"四. 优化与源码\"></a>四. 优化与源码</h1><h2 id=\"1-优化\"><a href=\"#1-优化\" class=\"headerlink\" title=\"1. 优化\"></a>1. 优化</h2><h3 id=\"1-1-扩展序列化算法\"><a href=\"#1-1-扩展序列化算法\" class=\"headerlink\" title=\"1.1 扩展序列化算法\"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>\n<ul>\n<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>\n<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>\n</ul>\n<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反序列化</span></span><br><span class=\"line\"><span class=\"type\">byte</span>[] body = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[bodyLength];</span><br><span class=\"line\">byteByf.readBytes(body);</span><br><span class=\"line\"><span class=\"type\">ObjectInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(body));</span><br><span class=\"line\"><span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) in.readObject();</span><br><span class=\"line\">message.setSequenceId(sequenceId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化</span></span><br><span class=\"line\"><span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure>\n\n<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 反序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">SerializerAlgorithm</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 实现</span></span><br><span class=\"line\">    Java &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> in.readObject();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (T) object;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> out.toByteArray();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, </span><br><span class=\"line\">    <span class=\"comment\">// Json 实现(引入了 Gson 依赖)</span></span><br><span class=\"line\">    Json &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().fromJson(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SerializerAlgorithm <span class=\"title function_\">getByInt</span><span class=\"params\">(<span class=\"type\">int</span> type)</span> &#123;</span><br><span class=\"line\">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type &lt; <span class=\"number\">0</span> || type &gt; array.length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array[type];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>增加配置类和配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> Config.class.getResourceAsStream(<span class=\"string\">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class=\"line\">            properties = <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">            properties.load(in);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionInInitializerError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getServerPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;server.port&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">8080</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Integer.parseInt(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Serializer.Algorithm <span class=\"title function_\">getSerializerAlgorithm</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;serializer.algorithm&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Serializer.Algorithm.Java;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">serializer.algorithm</span>=<span class=\"string\">Json</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改编解码器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodecSharable</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">        outList.add(out);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerAlgorithm</span> <span class=\"operator\">=</span> in.readByte(); <span class=\"comment\">// 0 或 1</span></span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte(); <span class=\"comment\">// 0,1,2...</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 找到反序列化算法</span></span><br><span class=\"line\">        Serializer.<span class=\"type\">Algorithm</span> <span class=\"variable\">algorithm</span> <span class=\"operator\">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class=\"line\">        <span class=\"comment\">// 确定具体消息类型</span></span><br><span class=\"line\">        Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class=\"line\"><span class=\"comment\">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class=\"line\"><span class=\"comment\">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> messageType 消息类型字节</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息 class</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt; getMessageClass(<span class=\"type\">int</span> messageType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageClasses.get(messageType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> sequenceId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> messageType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LoginRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LoginResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ChatRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ChatResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupCreateRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupCreateResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupJoinRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupJoinResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupQuitRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupQuitResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupChatRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupChatResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">11</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupMembersRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupMembersResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">13</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PingMessage</span> <span class=\"operator\">=</span> <span class=\"number\">14</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PongMessage</span> <span class=\"operator\">=</span> <span class=\"number\">15</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt;&gt; messageClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-2-参数调优\"><a href=\"#1-2-参数调优\" class=\"headerlink\" title=\"1.2 参数调优\"></a>1.2 参数调优</h3><h4 id=\"1）CONNECT-TIMEOUT-MILLIS\"><a href=\"#1）CONNECT-TIMEOUT-MILLIS\" class=\"headerlink\" title=\"1）CONNECT_TIMEOUT_MILLIS\"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>\n<li><p>属于 SocketChannal 参数</p>\n</li>\n<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>\n</li>\n<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestConnectionTimeout</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">                    .group(group)</span><br><span class=\"line\">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">300</span>)</span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>());</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">future</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\">            future.sync().channel().closeFuture().sync(); <span class=\"comment\">// 断点1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;timeout&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">connect</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress remoteAddress, <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// Schedule connect timeout.</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">connectTimeoutMillis</span> <span class=\"operator\">=</span> config().getConnectTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connectTimeoutMillis &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        connectTimeoutFuture = eventLoop().schedule(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;                </span><br><span class=\"line\">                <span class=\"type\">ChannelPromise</span> <span class=\"variable\">connectPromise</span> <span class=\"operator\">=</span> AbstractNioChannel.<span class=\"built_in\">this</span>.connectPromise;</span><br><span class=\"line\">                <span class=\"type\">ConnectTimeoutException</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectTimeoutException</span>(<span class=\"string\">&quot;connection timed out: &quot;</span> + remoteAddress); <span class=\"comment\">// 断点2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (connectPromise != <span class=\"literal\">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class=\"line\">                    close(voidPromise());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）SO-BACKLOG\"><a href=\"#2）SO-BACKLOG\" class=\"headerlink\" title=\"2）SO_BACKLOG\"></a>2）SO_BACKLOG</h4><ul>\n<li>属于 ServerSocketChannal 参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\"></span><br><span class=\"line\">participant c as client</span><br><span class=\"line\">participant s as server</span><br><span class=\"line\">participant sq as syns queue</span><br><span class=\"line\">participant aq as accept queue</span><br><span class=\"line\"></span><br><span class=\"line\">s -&gt;&gt; s : bind()</span><br><span class=\"line\">s -&gt;&gt; s : listen()</span><br><span class=\"line\">c -&gt;&gt; c : connect()</span><br><span class=\"line\">c -&gt;&gt; s : 1. SYN</span><br><span class=\"line\">Note left of c : SYN_SEND</span><br><span class=\"line\">s -&gt;&gt; sq : put</span><br><span class=\"line\">Note right of s : SYN_RCVD</span><br><span class=\"line\">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class=\"line\">Note left of c : ESTABLISHED</span><br><span class=\"line\">c -&gt;&gt; s : 3. ACK</span><br><span class=\"line\">sq -&gt;&gt; aq : put</span><br><span class=\"line\">Note right of s : ESTABLISHED</span><br><span class=\"line\">aq --&gt;&gt; s : </span><br><span class=\"line\">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>\n<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>\n<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>\n</ol>\n<p>其中</p>\n<ul>\n<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>\n</li>\n<li><p>sync queue - 半连接队列</p>\n<ul>\n<li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>\n</ul>\n</li>\n<li><p>accept queue - 全连接队列</p>\n<ul>\n<li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>\n<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>\n</ul>\n</li>\n</ul>\n<p>netty 中</p>\n<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p>\n<p>可以通过下面源码查看默认大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultServerSocketChannelConfig</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DefaultChannelConfig</span></span><br><span class=\"line\">                                              <span class=\"keyword\">implements</span> <span class=\"title class_\">ServerSocketChannelConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> <span class=\"variable\">backlog</span> <span class=\"operator\">=</span> NetUtil.SOMAXCONN;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<p>oio 中更容易说明，不用 debug 模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">ss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">8888</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">accept</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\">        System.out.println(accept);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端启动 4 个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connecting...&quot;</span>);</span><br><span class=\"line\">            s.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>),<span class=\"number\">1000</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connected...&quot;</span>);</span><br><span class=\"line\">            s.getOutputStream().write(<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.in.read();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connecting timeout...&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tue Apr <span class=\"number\">21</span> <span class=\"number\">20</span>:<span class=\"number\">30</span>:<span class=\"number\">28</span> CST <span class=\"number\">2020</span> connecting...</span><br><span class=\"line\">Tue Apr <span class=\"number\">21</span> <span class=\"number\">20</span>:<span class=\"number\">30</span>:<span class=\"number\">28</span> CST <span class=\"number\">2020</span> connected...</span><br></pre></td></tr></table></figure>\n\n<p>第 4 个客户端连接时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class=\"line\">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class=\"line\">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3）ulimit-n\"><a href=\"#3）ulimit-n\" class=\"headerlink\" title=\"3）ulimit -n\"></a>3）ulimit -n</h4><ul>\n<li>属于操作系统参数</li>\n</ul>\n<h4 id=\"4）TCP-NODELAY\"><a href=\"#4）TCP-NODELAY\" class=\"headerlink\" title=\"4）TCP_NODELAY\"></a>4）TCP_NODELAY</h4><ul>\n<li>属于 SocketChannal 参数</li>\n</ul>\n<h4 id=\"5）SO-SNDBUF-amp-SO-RCVBUF\"><a href=\"#5）SO-SNDBUF-amp-SO-RCVBUF\" class=\"headerlink\" title=\"5）SO_SNDBUF &amp; SO_RCVBUF\"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul>\n<li>SO_SNDBUF 属于 SocketChannal 参数</li>\n<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>\n</ul>\n<h4 id=\"6）ALLOCATOR\"><a href=\"#6）ALLOCATOR\" class=\"headerlink\" title=\"6）ALLOCATOR\"></a>6）ALLOCATOR</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>用来分配 ByteBuf， ctx.alloc()</li>\n</ul>\n<h4 id=\"7）RCVBUF-ALLOCATOR\"><a href=\"#7）RCVBUF-ALLOCATOR\" class=\"headerlink\" title=\"7）RCVBUF_ALLOCATOR\"></a>7）RCVBUF_ALLOCATOR</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>控制 netty 接收缓冲区大小</li>\n<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>\n</ul>\n<h3 id=\"1-3-RPC-框架\"><a href=\"#1-3-RPC-框架\" class=\"headerlink\" title=\"1.3 RPC 框架\"></a>1.3 RPC 框架</h3><h4 id=\"1）准备工作\"><a href=\"#1）准备工作\" class=\"headerlink\" title=\"1）准备工作\"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>\n<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略旧的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RPC_MESSAGE_TYPE_REQUEST</span> <span class=\"operator\">=</span> <span class=\"number\">101</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span>  <span class=\"variable\">RPC_MESSAGE_TYPE_RESPONSE</span> <span class=\"operator\">=</span> <span class=\"number\">102</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请求消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@ToString(callSuper = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcRequestMessage</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String interfaceName;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用接口中的方法名</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String methodName;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法返回类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;?&gt; returnType;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法参数类型数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class[] parameterTypes;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法参数值数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] parameterValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RpcRequestMessage</span><span class=\"params\">(<span class=\"type\">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.setSequenceId(sequenceId);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.interfaceName = interfaceName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.methodName = methodName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.returnType = returnType;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameterTypes = parameterTypes;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameterValue = parameterValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@ToString(callSuper = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessage</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object returnValue;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 异常值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Exception exceptionValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器架子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// rpc 请求消息处理器，待实现</span></span><br><span class=\"line\">        <span class=\"type\">RpcRequestMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端架子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// rpc 响应消息处理器，待实现</span></span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的 service 获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServicesFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> Config.class.getResourceAsStream(<span class=\"string\">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class=\"line\">            properties = <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">            properties.load(in);</span><br><span class=\"line\">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (name.endsWith(<span class=\"string\">&quot;Service&quot;</span>)) &#123;</span><br><span class=\"line\">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class=\"line\">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class=\"line\">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionInInitializerError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getService</span><span class=\"params\">(Class&lt;T&gt; interfaceClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) map.get(interfaceClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关配置 application.properties</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serializer.algorithm=Json</span><br><span class=\"line\">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）服务器-handler\"><a href=\"#2）服务器-handler\" class=\"headerlink\" title=\"2）服务器 handler\"></a>2）服务器 handler</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcRequestMessage&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessage</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessage</span>();</span><br><span class=\"line\">        response.setSequenceId(message.getSequenceId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取真正的实现对象</span></span><br><span class=\"line\">            <span class=\"type\">HelloService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> (HelloService)</span><br><span class=\"line\">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 获取要调用的方法</span></span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 调用方法</span></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">invoke</span> <span class=\"operator\">=</span> method.invoke(service, message.getParameterValue());</span><br><span class=\"line\">            <span class=\"comment\">// 调用成功</span></span><br><span class=\"line\">            response.setReturnValue(invoke);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">// 调用异常</span></span><br><span class=\"line\">            response.setExceptionValue(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">        ctx.writeAndFlush(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3）客户端代码第一版\"><a href=\"#3）客户端代码第一版\" class=\"headerlink\" title=\"3）客户端代码第一版\"></a>3）客户端代码第一版</h4><p>只发消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">future</span> <span class=\"operator\">=</span> channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessage</span>(</span><br><span class=\"line\">                    <span class=\"number\">1</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;cn.itcast.server.service.HelloService&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;sayHello&quot;</span>,</span><br><span class=\"line\">                    String.class,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;String.class&#125;,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"string\">&quot;张三&quot;</span>&#125;</span><br><span class=\"line\">            )).addListener(promise -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!promise.isSuccess()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> promise.cause();</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;error&quot;</span>, cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4）客户端-handler-第一版\"><a href=\"#4）客户端-handler-第一版\" class=\"headerlink\" title=\"4）客户端 handler 第一版\"></a>4）客户端 handler 第一版</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"5）客户端代码-第二版\"><a href=\"#5）客户端代码-第二版\" class=\"headerlink\" title=\"5）客户端代码 第二版\"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClientManager</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HelloService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> getProxyService(HelloService.class);</span><br><span class=\"line\">        System.out.println(service.sayHello(<span class=\"string\">&quot;zhangsan&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getProxyService</span><span class=\"params\">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loader</span> <span class=\"operator\">=</span> serviceClass.getClassLoader();</span><br><span class=\"line\">        Class&lt;?&gt;[] interfaces = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;serviceClass&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//                                                            sayHello  &quot;张三&quot;</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 将方法调用转换为 消息对象</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> SequenceIdGenerator.nextId();</span><br><span class=\"line\">            <span class=\"type\">RpcRequestMessage</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessage</span>(</span><br><span class=\"line\">                    sequenceId,</span><br><span class=\"line\">                    serviceClass.getName(),</span><br><span class=\"line\">                    method.getName(),</span><br><span class=\"line\">                    method.getReturnType(),</span><br><span class=\"line\">                    method.getParameterTypes(),</span><br><span class=\"line\">                    args</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"comment\">// 2. 将消息对象发送出去</span></span><br><span class=\"line\">            getChannel().writeAndFlush(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span></span><br><span class=\"line\">            DefaultPromise&lt;Object&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(getChannel().eventLoop());</span><br><span class=\"line\">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//            promise.addListener(future -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                // 线程</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 4. 等待 promise 结果</span></span><br><span class=\"line\">            promise.await();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(promise.isSuccess()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用正常</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> promise.getNow();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用失败</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(promise.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取唯一的 channel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title function_\">getChannel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LOCK) &#123; <span class=\"comment\">//  t2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (channel != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// t1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            initChannel();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 channel 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">        bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">        bootstrap.group(group);</span><br><span class=\"line\">        bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            channel = bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class=\"line\">                group.shutdownGracefully();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6）客户端-handler-第二版\"><a href=\"#6）客户端-handler-第二版\" class=\"headerlink\" title=\"6）客户端 handler 第二版\"></a>6）客户端 handler 第二版</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//                       序号      用来接收结果的 promise 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">        <span class=\"comment\">// 拿到空的 promise</span></span><br><span class=\"line\">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (promise != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> msg.getReturnValue();</span><br><span class=\"line\">            <span class=\"type\">Exception</span> <span class=\"variable\">exceptionValue</span> <span class=\"operator\">=</span> msg.getExceptionValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(exceptionValue != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                promise.setFailure(exceptionValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setSuccess(returnValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h2><h3 id=\"2-1-启动剖析\"><a href=\"#2-1-启动剖析\" class=\"headerlink\" title=\"2.1 启动剖析\"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class=\"line\"><span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class=\"line\"><span class=\"type\">NioServerSocketChannel</span> <span class=\"variable\">attachment</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioServerSocketChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">serverSocketChannel</span> <span class=\"operator\">=</span> ServerSocketChannel.open(); </span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class=\"line\"><span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> serverSocketChannel.register(selector, <span class=\"number\">0</span>, attachment);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//7 绑定端口</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class=\"line\">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ChannelFuture <span class=\"title function_\">doBind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> initAndRegister();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> regFuture.channel();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.1 如果已经完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.isDone()) &#123;</span><br><span class=\"line\">        <span class=\"type\">ChannelPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> channel.newPromise();</span><br><span class=\"line\">        <span class=\"comment\">// 3.1 立刻调用 doBind0</span></span><br><span class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 2.2 还没有完成</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingRegistrationPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PendingRegistrationPromise</span>(channel);</span><br><span class=\"line\">        <span class=\"comment\">// 3.2 回调 doBind0</span></span><br><span class=\"line\">        regFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> future.cause();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cause != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">                    promise.setFailure(cause);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    promise.registered();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 3. 由注册线程去执行 doBind0</span></span><br><span class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">initAndRegister</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        channel = channelFactory.newChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class=\"line\">        init(channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultChannelPromise</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> config().group().register(channel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (options) &#123;</span><br><span class=\"line\">        setChannelOptions(channel, options, logger);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (attrs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class=\"line\">            channel.attr(key).set(e.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">currentChildGroup</span> <span class=\"operator\">=</span> childGroup;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelHandler</span> <span class=\"variable\">currentChildHandler</span> <span class=\"operator\">=</span> childHandler;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childOptions) &#123;</span><br><span class=\"line\">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childAttrs) &#123;</span><br><span class=\"line\">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class=\"line\">    p.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">            <span class=\"type\">ChannelHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> config.handler();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.addLast(handler);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class=\"line\">            ch.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrapAcceptor</span>(</span><br><span class=\"line\">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        <span class=\"comment\">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Close the channel directly to avoid FD leak.</span></span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initMap.add(ctx)) &#123; <span class=\"comment\">// Guard against re-entrance.</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.1 执行初始化</span></span><br><span class=\"line\">            initChannel((C) ctx.channel());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable cause) &#123;</span><br><span class=\"line\">            exceptionCaught(ctx, cause);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.2 移除初始化器</span></span><br><span class=\"line\">            <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ctx.pipeline();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pipeline.context(<span class=\"built_in\">this</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3.1 或 3.2 执行 doBind0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind0</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> ChannelFuture regFuture, <span class=\"keyword\">final</span> Channel channel,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (regFuture.isSuccess()) &#123;</span><br><span class=\"line\">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setFailure(regFuture.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    assertEventLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class=\"line\">        localAddress <span class=\"keyword\">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class=\"line\">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class=\"line\">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">wasActive</span> <span class=\"operator\">=</span> isActive();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.3 执行端口绑定</span></span><br><span class=\"line\">        doBind(localAddress);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">        closeIfClosed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class=\"line\">        invokeLater(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 3.4 触发 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    safeSetSuccess(promise);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind</span><span class=\"params\">(SocketAddress localAddress)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PlatformDependent.javaVersion() &gt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"comment\">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-2-NioEventLoop-剖析\"><a href=\"#2-2-NioEventLoop-剖析\" class=\"headerlink\" title=\"2.2 NioEventLoop 剖析\"></a>2.2 NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>\n<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;task&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">inEventLoop</span> <span class=\"operator\">=</span> inEventLoop();</span><br><span class=\"line\">    <span class=\"comment\">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class=\"line\">    addTask(task);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class=\"line\">        startThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShutdown()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class=\"line\">        wakeup(inEventLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wakeup</span><span class=\"params\">(<span class=\"type\">boolean</span> inEventLoop)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">        selector.wakeup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doStartThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> thread == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class=\"line\">            thread = Thread.currentThread();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (interrupted) &#123;</span><br><span class=\"line\">                thread.interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            updateLastExecutionTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class=\"line\">                SingleThreadEventExecutor.<span class=\"built_in\">this</span>.run();</span><br><span class=\"line\">                success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 清理工作，代码略...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// calculateStrategy 的逻辑如下：</span></span><br><span class=\"line\">                <span class=\"comment\">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class=\"line\">                <span class=\"comment\">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.SELECT:</span><br><span class=\"line\">                        <span class=\"comment\">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class=\"line\">                        <span class=\"comment\">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class=\"line\">                        <span class=\"type\">boolean</span> <span class=\"variable\">oldWakenUp</span> <span class=\"operator\">=</span> wakenUp.getAndSet(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"comment\">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class=\"line\">                        <span class=\"comment\">// 下面的 select 方法不会阻塞</span></span><br><span class=\"line\">                        <span class=\"comment\">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class=\"line\">                        <span class=\"comment\">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class=\"line\">                        <span class=\"comment\">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class=\"line\">                        select(oldWakenUp);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (wakenUp.get()) &#123;</span><br><span class=\"line\">                            selector.wakeup();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                rebuildSelector0();</span><br><span class=\"line\">                handleLoopException(e);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</span><br><span class=\"line\">            needsToSelectAgain = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ioRatio 默认是 50</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ioRatio</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.ioRatio;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ioRatio == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class=\"line\">                    runAllTasks();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioStartTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 记录 io 事件处理耗时</span></span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioTime</span> <span class=\"operator\">=</span> System.nanoTime() - ioStartTime;</span><br><span class=\"line\">                    <span class=\"comment\">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isShuttingDown()) &#123;</span><br><span class=\"line\">                closeAll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-注意\"><a href=\"#⚠️-注意\" class=\"headerlink\" title=\"⚠️ 注意\"></a>⚠️ 注意</h4><blockquote>\n<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>\n<ul>\n<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>\n<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>\n</ul>\n</blockquote>\n<p>参考下图</p>\n<img src=\"img/0032.png\"  />\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">boolean</span> oldWakenUp)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selector;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">selectCnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTimeNanos</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 计算等待时间</span></span><br><span class=\"line\">        <span class=\"comment\">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class=\"line\">        <span class=\"comment\">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">selectDeadLineNanos</span> <span class=\"operator\">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">timeoutMillis</span> <span class=\"operator\">=</span> (selectDeadLineNanos - currentTimeNanos + <span class=\"number\">500000L</span>) / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果超时，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeoutMillis &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectCnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class=\"line\">            <span class=\"comment\">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// select 有限时阻塞</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">selectedKeys</span> <span class=\"operator\">=</span> selector.select(timeoutMillis);</span><br><span class=\"line\">            <span class=\"comment\">// 计数加 1</span></span><br><span class=\"line\">            selectCnt ++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (selectedKeys != <span class=\"number\">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">               \t<span class=\"comment\">// 线程被打断，退出循环</span></span><br><span class=\"line\">                <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"comment\">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class=\"line\">            <span class=\"comment\">// 这是为了解决 nio 空轮询 bug</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重建 selector</span></span><br><span class=\"line\">                selector = selectRebuildSelector(selectCnt);</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKeys</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedKeys != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class=\"line\">        <span class=\"comment\">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class=\"line\">        processSelectedKeysOptimized();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKey</span><span class=\"params\">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AbstractNioChannel.<span class=\"type\">NioUnsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> ch.unsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!k.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无效时处理...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readyOps</span> <span class=\"operator\">=</span> k.readyOps();</span><br><span class=\"line\">        <span class=\"comment\">// 连接事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ops</span> <span class=\"operator\">=</span> k.interestOps();</span><br><span class=\"line\">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class=\"line\">            k.interestOps(ops);</span><br><span class=\"line\"></span><br><span class=\"line\">            unsafe.finishConnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可写事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ch.unsafe().forceFlush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可读或可接入事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class=\"number\">0</span> || readyOps == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class=\"line\">            unsafe.read();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class=\"line\">        unsafe.close(unsafe.voidPromise());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-accept-剖析\"><a href=\"#2-3-accept-剖析\" class=\"headerlink\" title=\"2.3 accept 剖析\"></a>2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 阻塞直到事件发生</span></span><br><span class=\"line\">selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter.hasNext()) &#123;    </span><br><span class=\"line\">    <span class=\"comment\">//2 拿到一个事件</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3 如果是 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//4 执行 accept</span></span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverSocketChannel.accept();</span><br><span class=\"line\">        channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//5 关注 read 事件</span></span><br><span class=\"line\">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>先来看可接入事件处理（accept）</p>\n<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"title function_\">eventLoop</span><span class=\"params\">()</span>.inEventLoop();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> unsafe().recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">closed</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">Throwable</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class=\"line\">                <span class=\"comment\">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">localRead</span> <span class=\"operator\">=</span> doReadMessages(readBuf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    closed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class=\"line\">                allocHandle.incMessagesRead(localRead);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            exception = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> readBuf.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i ++) &#123;</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class=\"line\">            <span class=\"comment\">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class=\"line\">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        readBuf.clear();</span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            closed = closeOnReadError(exception);</span><br><span class=\"line\"></span><br><span class=\"line\">            pipeline.fireExceptionCaught(exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">            inputShutdown = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isOpen()) &#123;</span><br><span class=\"line\">                close(voidPromise());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这时的 msg 是 NioSocketChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> (Channel) msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class=\"line\">    child.pipeline().addLast(childHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置选项</span></span><br><span class=\"line\">    setChannelOptions(child, childOptions, logger);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class=\"line\">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class=\"line\">        childGroup.register(child).addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</span><br><span class=\"line\">                    forceClose(child, future.cause());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        forceClose(child, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\">        <span class=\"comment\">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class=\"line\"></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 触发 pipeline 上 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 这时候 interestOps 是 0</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关注 read 事件</span></span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-read-剖析\"><a href=\"#2-4-read-剖析\" class=\"headerlink\" title=\"2.4 read 剖析\"></a>2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class=\"line\">        clearReadPending();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();</span><br><span class=\"line\">    <span class=\"comment\">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ByteBufAllocator</span> <span class=\"variable\">allocator</span> <span class=\"operator\">=</span> config.getAllocator();</span><br><span class=\"line\">    <span class=\"comment\">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">close</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            byteBuf = allocHandle.allocate(allocator);</span><br><span class=\"line\">            <span class=\"comment\">// 读取</span></span><br><span class=\"line\">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allocHandle.lastBytesRead() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                byteBuf.release();</span><br><span class=\"line\">                byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                close = allocHandle.lastBytesRead() &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">                    readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            allocHandle.incMessagesRead(<span class=\"number\">1</span>);</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class=\"line\">            pipeline.fireChannelRead(byteBuf);</span><br><span class=\"line\">            byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 是否要继续循环</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\"></span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        <span class=\"comment\">// 触发 read complete 事件</span></span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">            closeOnRead(pipeline);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">continueReading</span><span class=\"params\">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">           <span class=\"comment\">// 一般为 true</span></span><br><span class=\"line\">           config.isAutoRead() &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// respectMaybeMoreData 默认为 true</span></span><br><span class=\"line\">           <span class=\"comment\">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class=\"line\">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class=\"line\">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 实际读到了数据</span></span><br><span class=\"line\">           totalBytesRead &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>该笔记是B站黑马的Netty视频的配套笔记4。</p>","more":"<h1 id=\"四-优化与源码\"><a href=\"#四-优化与源码\" class=\"headerlink\" title=\"四. 优化与源码\"></a>四. 优化与源码</h1><h2 id=\"1-优化\"><a href=\"#1-优化\" class=\"headerlink\" title=\"1. 优化\"></a>1. 优化</h2><h3 id=\"1-1-扩展序列化算法\"><a href=\"#1-1-扩展序列化算法\" class=\"headerlink\" title=\"1.1 扩展序列化算法\"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>\n<ul>\n<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>\n<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>\n</ul>\n<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反序列化</span></span><br><span class=\"line\"><span class=\"type\">byte</span>[] body = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[bodyLength];</span><br><span class=\"line\">byteByf.readBytes(body);</span><br><span class=\"line\"><span class=\"type\">ObjectInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(body));</span><br><span class=\"line\"><span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) in.readObject();</span><br><span class=\"line\">message.setSequenceId(sequenceId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 序列化</span></span><br><span class=\"line\"><span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class=\"line\"><span class=\"type\">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure>\n\n<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 反序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 序列化方法</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">SerializerAlgorithm</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializer</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Java 实现</span></span><br><span class=\"line\">    Java &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">object</span> <span class=\"operator\">=</span> in.readObject();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> (T) object;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> out.toByteArray();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, </span><br><span class=\"line\">    <span class=\"comment\">// Json 实现(引入了 Gson 依赖)</span></span><br><span class=\"line\">    Json &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">deserialize</span><span class=\"params\">(Class&lt;T&gt; clazz, <span class=\"type\">byte</span>[] bytes)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().fromJson(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"type\">byte</span>[] serialize(T object) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SerializerAlgorithm <span class=\"title function_\">getByInt</span><span class=\"params\">(<span class=\"type\">int</span> type)</span> &#123;</span><br><span class=\"line\">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type &lt; <span class=\"number\">0</span> || type &gt; array.length - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array[type];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>增加配置类和配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Config</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> Config.class.getResourceAsStream(<span class=\"string\">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class=\"line\">            properties = <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">            properties.load(in);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionInInitializerError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">getServerPort</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;server.port&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">8080</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Integer.parseInt(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Serializer.Algorithm <span class=\"title function_\">getSerializerAlgorithm</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> properties.getProperty(<span class=\"string\">&quot;serializer.algorithm&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(value == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Serializer.Algorithm.Java;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>配置文件</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">serializer.algorithm</span>=<span class=\"string\">Json</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>修改编解码器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodecSharable</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">        outList.add(out);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerAlgorithm</span> <span class=\"operator\">=</span> in.readByte(); <span class=\"comment\">// 0 或 1</span></span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte(); <span class=\"comment\">// 0,1,2...</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 找到反序列化算法</span></span><br><span class=\"line\">        Serializer.<span class=\"type\">Algorithm</span> <span class=\"variable\">algorithm</span> <span class=\"operator\">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class=\"line\">        <span class=\"comment\">// 确定具体消息类型</span></span><br><span class=\"line\">        Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class=\"line\"><span class=\"comment\">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class=\"line\"><span class=\"comment\">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> messageType 消息类型字节</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息 class</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt; getMessageClass(<span class=\"type\">int</span> messageType) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageClasses.get(messageType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> sequenceId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> messageType;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LoginRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">LoginResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ChatRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ChatResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupCreateRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupCreateResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupJoinRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupJoinResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">7</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupQuitRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupQuitResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">9</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupChatRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupChatResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">11</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupMembersRequestMessage</span> <span class=\"operator\">=</span> <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">GroupMembersResponseMessage</span> <span class=\"operator\">=</span> <span class=\"number\">13</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PingMessage</span> <span class=\"operator\">=</span> <span class=\"number\">14</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">PongMessage</span> <span class=\"operator\">=</span> <span class=\"number\">15</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span>&gt;&gt; messageClasses = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-2-参数调优\"><a href=\"#1-2-参数调优\" class=\"headerlink\" title=\"1.2 参数调优\"></a>1.2 参数调优</h3><h4 id=\"1）CONNECT-TIMEOUT-MILLIS\"><a href=\"#1）CONNECT-TIMEOUT-MILLIS\" class=\"headerlink\" title=\"1）CONNECT_TIMEOUT_MILLIS\"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>\n<li><p>属于 SocketChannal 参数</p>\n</li>\n<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>\n</li>\n<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestConnectionTimeout</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>()</span><br><span class=\"line\">                    .group(group)</span><br><span class=\"line\">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">300</span>)</span><br><span class=\"line\">                    .channel(NioSocketChannel.class)</span><br><span class=\"line\">                    .handler(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>());</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">future</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>);</span><br><span class=\"line\">            future.sync().channel().closeFuture().sync(); <span class=\"comment\">// 断点1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;timeout&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">connect</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress remoteAddress, <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// Schedule connect timeout.</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">connectTimeoutMillis</span> <span class=\"operator\">=</span> config().getConnectTimeoutMillis();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connectTimeoutMillis &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        connectTimeoutFuture = eventLoop().schedule(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;                </span><br><span class=\"line\">                <span class=\"type\">ChannelPromise</span> <span class=\"variable\">connectPromise</span> <span class=\"operator\">=</span> AbstractNioChannel.<span class=\"built_in\">this</span>.connectPromise;</span><br><span class=\"line\">                <span class=\"type\">ConnectTimeoutException</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectTimeoutException</span>(<span class=\"string\">&quot;connection timed out: &quot;</span> + remoteAddress); <span class=\"comment\">// 断点2</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (connectPromise != <span class=\"literal\">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class=\"line\">                    close(voidPromise());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）SO-BACKLOG\"><a href=\"#2）SO-BACKLOG\" class=\"headerlink\" title=\"2）SO_BACKLOG\"></a>2）SO_BACKLOG</h4><ul>\n<li>属于 ServerSocketChannal 参数</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sequenceDiagram</span><br><span class=\"line\"></span><br><span class=\"line\">participant c as client</span><br><span class=\"line\">participant s as server</span><br><span class=\"line\">participant sq as syns queue</span><br><span class=\"line\">participant aq as accept queue</span><br><span class=\"line\"></span><br><span class=\"line\">s -&gt;&gt; s : bind()</span><br><span class=\"line\">s -&gt;&gt; s : listen()</span><br><span class=\"line\">c -&gt;&gt; c : connect()</span><br><span class=\"line\">c -&gt;&gt; s : 1. SYN</span><br><span class=\"line\">Note left of c : SYN_SEND</span><br><span class=\"line\">s -&gt;&gt; sq : put</span><br><span class=\"line\">Note right of s : SYN_RCVD</span><br><span class=\"line\">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class=\"line\">Note left of c : ESTABLISHED</span><br><span class=\"line\">c -&gt;&gt; s : 3. ACK</span><br><span class=\"line\">sq -&gt;&gt; aq : put</span><br><span class=\"line\">Note right of s : ESTABLISHED</span><br><span class=\"line\">aq --&gt;&gt; s : </span><br><span class=\"line\">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>\n<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>\n<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>\n</ol>\n<p>其中</p>\n<ul>\n<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>\n</li>\n<li><p>sync queue - 半连接队列</p>\n<ul>\n<li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>\n</ul>\n</li>\n<li><p>accept queue - 全连接队列</p>\n<ul>\n<li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>\n<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>\n</ul>\n</li>\n</ul>\n<p>netty 中</p>\n<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p>\n<p>可以通过下面源码查看默认大小</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultServerSocketChannelConfig</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DefaultChannelConfig</span></span><br><span class=\"line\">                                              <span class=\"keyword\">implements</span> <span class=\"title class_\">ServerSocketChannelConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> <span class=\"variable\">backlog</span> <span class=\"operator\">=</span> NetUtil.SOMAXCONN;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<p>oio 中更容易说明，不用 debug 模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Server</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"type\">ServerSocket</span> <span class=\"variable\">ss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerSocket</span>(<span class=\"number\">8888</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"type\">Socket</span> <span class=\"variable\">accept</span> <span class=\"operator\">=</span> ss.accept();</span><br><span class=\"line\">        System.out.println(accept);</span><br><span class=\"line\">        System.in.read();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端启动 4 个</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Socket</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Socket</span>();</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connecting...&quot;</span>);</span><br><span class=\"line\">            s.connect(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8888</span>),<span class=\"number\">1000</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connected...&quot;</span>);</span><br><span class=\"line\">            s.getOutputStream().write(<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.in.read();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>()+<span class=\"string\">&quot; connecting timeout...&quot;</span>);</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tue Apr <span class=\"number\">21</span> <span class=\"number\">20</span>:<span class=\"number\">30</span>:<span class=\"number\">28</span> CST <span class=\"number\">2020</span> connecting...</span><br><span class=\"line\">Tue Apr <span class=\"number\">21</span> <span class=\"number\">20</span>:<span class=\"number\">30</span>:<span class=\"number\">28</span> CST <span class=\"number\">2020</span> connected...</span><br></pre></td></tr></table></figure>\n\n<p>第 4 个客户端连接时</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class=\"line\">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class=\"line\">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3）ulimit-n\"><a href=\"#3）ulimit-n\" class=\"headerlink\" title=\"3）ulimit -n\"></a>3）ulimit -n</h4><ul>\n<li>属于操作系统参数</li>\n</ul>\n<h4 id=\"4）TCP-NODELAY\"><a href=\"#4）TCP-NODELAY\" class=\"headerlink\" title=\"4）TCP_NODELAY\"></a>4）TCP_NODELAY</h4><ul>\n<li>属于 SocketChannal 参数</li>\n</ul>\n<h4 id=\"5）SO-SNDBUF-amp-SO-RCVBUF\"><a href=\"#5）SO-SNDBUF-amp-SO-RCVBUF\" class=\"headerlink\" title=\"5）SO_SNDBUF &amp; SO_RCVBUF\"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul>\n<li>SO_SNDBUF 属于 SocketChannal 参数</li>\n<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>\n</ul>\n<h4 id=\"6）ALLOCATOR\"><a href=\"#6）ALLOCATOR\" class=\"headerlink\" title=\"6）ALLOCATOR\"></a>6）ALLOCATOR</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>用来分配 ByteBuf， ctx.alloc()</li>\n</ul>\n<h4 id=\"7）RCVBUF-ALLOCATOR\"><a href=\"#7）RCVBUF-ALLOCATOR\" class=\"headerlink\" title=\"7）RCVBUF_ALLOCATOR\"></a>7）RCVBUF_ALLOCATOR</h4><ul>\n<li>属于 SocketChannal 参数</li>\n<li>控制 netty 接收缓冲区大小</li>\n<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>\n</ul>\n<h3 id=\"1-3-RPC-框架\"><a href=\"#1-3-RPC-框架\" class=\"headerlink\" title=\"1.3 RPC 框架\"></a>1.3 RPC 框架</h3><h4 id=\"1）准备工作\"><a href=\"#1）准备工作\" class=\"headerlink\" title=\"1）准备工作\"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>\n<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Message</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 省略旧的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RPC_MESSAGE_TYPE_REQUEST</span> <span class=\"operator\">=</span> <span class=\"number\">101</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span>  <span class=\"variable\">RPC_MESSAGE_TYPE_RESPONSE</span> <span class=\"operator\">=</span> <span class=\"number\">102</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class=\"line\">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请求消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@ToString(callSuper = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcRequestMessage</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String interfaceName;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用接口中的方法名</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String methodName;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法返回类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;?&gt; returnType;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法参数类型数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class[] parameterTypes;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 方法参数值数组</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object[] parameterValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">RpcRequestMessage</span><span class=\"params\">(<span class=\"type\">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>.setSequenceId(sequenceId);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.interfaceName = interfaceName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.methodName = methodName;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.returnType = returnType;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameterTypes = parameterTypes;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameterValue = parameterValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>响应消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Data</span></span><br><span class=\"line\"><span class=\"meta\">@ToString(callSuper = true)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessage</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Message</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object returnValue;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 异常值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Exception exceptionValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMessageType</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器架子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// rpc 请求消息处理器，待实现</span></span><br><span class=\"line\">        <span class=\"type\">RpcRequestMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端架子</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// rpc 响应消息处理器，待实现</span></span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的 service 获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ServicesFactory</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> Properties properties;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"type\">InputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> Config.class.getResourceAsStream(<span class=\"string\">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class=\"line\">            properties = <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">            properties.load(in);</span><br><span class=\"line\">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (name.endsWith(<span class=\"string\">&quot;Service&quot;</span>)) &#123;</span><br><span class=\"line\">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class=\"line\">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class=\"line\">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ExceptionInInitializerError</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getService</span><span class=\"params\">(Class&lt;T&gt; interfaceClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) map.get(interfaceClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相关配置 application.properties</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serializer.algorithm=Json</span><br><span class=\"line\">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2）服务器-handler\"><a href=\"#2）服务器-handler\" class=\"headerlink\" title=\"2）服务器 handler\"></a>2）服务器 handler</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcRequestMessage&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessage</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessage</span>();</span><br><span class=\"line\">        response.setSequenceId(message.getSequenceId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取真正的实现对象</span></span><br><span class=\"line\">            <span class=\"type\">HelloService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> (HelloService)</span><br><span class=\"line\">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 获取要调用的方法</span></span><br><span class=\"line\">            <span class=\"type\">Method</span> <span class=\"variable\">method</span> <span class=\"operator\">=</span> service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 调用方法</span></span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">invoke</span> <span class=\"operator\">=</span> method.invoke(service, message.getParameterValue());</span><br><span class=\"line\">            <span class=\"comment\">// 调用成功</span></span><br><span class=\"line\">            response.setReturnValue(invoke);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"comment\">// 调用异常</span></span><br><span class=\"line\">            response.setExceptionValue(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回结果</span></span><br><span class=\"line\">        ctx.writeAndFlush(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3）客户端代码第一版\"><a href=\"#3）客户端代码第一版\" class=\"headerlink\" title=\"3）客户端代码第一版\"></a>3）客户端代码第一版</h4><p>只发消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">future</span> <span class=\"operator\">=</span> channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessage</span>(</span><br><span class=\"line\">                    <span class=\"number\">1</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;cn.itcast.server.service.HelloService&quot;</span>,</span><br><span class=\"line\">                    <span class=\"string\">&quot;sayHello&quot;</span>,</span><br><span class=\"line\">                    String.class,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;String.class&#125;,</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"string\">&quot;张三&quot;</span>&#125;</span><br><span class=\"line\">            )).addListener(promise -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!promise.isSuccess()) &#123;</span><br><span class=\"line\">                    <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> promise.cause();</span><br><span class=\"line\">                    log.error(<span class=\"string\">&quot;error&quot;</span>, cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"4）客户端-handler-第一版\"><a href=\"#4）客户端-handler-第一版\" class=\"headerlink\" title=\"4）客户端 handler 第一版\"></a>4）客户端 handler 第一版</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"5）客户端代码-第二版\"><a href=\"#5）客户端代码-第二版\" class=\"headerlink\" title=\"5）客户端代码 第二版\"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcClientManager</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">HelloService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> getProxyService(HelloService.class);</span><br><span class=\"line\">        System.out.println(service.sayHello(<span class=\"string\">&quot;zhangsan&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getProxyService</span><span class=\"params\">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loader</span> <span class=\"operator\">=</span> serviceClass.getClassLoader();</span><br><span class=\"line\">        Class&lt;?&gt;[] interfaces = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;serviceClass&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//                                                            sayHello  &quot;张三&quot;</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 将方法调用转换为 消息对象</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> SequenceIdGenerator.nextId();</span><br><span class=\"line\">            <span class=\"type\">RpcRequestMessage</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcRequestMessage</span>(</span><br><span class=\"line\">                    sequenceId,</span><br><span class=\"line\">                    serviceClass.getName(),</span><br><span class=\"line\">                    method.getName(),</span><br><span class=\"line\">                    method.getReturnType(),</span><br><span class=\"line\">                    method.getParameterTypes(),</span><br><span class=\"line\">                    args</span><br><span class=\"line\">            );</span><br><span class=\"line\">            <span class=\"comment\">// 2. 将消息对象发送出去</span></span><br><span class=\"line\">            getChannel().writeAndFlush(msg);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span></span><br><span class=\"line\">            DefaultPromise&lt;Object&gt; promise = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultPromise</span>&lt;&gt;(getChannel().eventLoop());</span><br><span class=\"line\">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//            promise.addListener(future -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                // 线程</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 4. 等待 promise 结果</span></span><br><span class=\"line\">            promise.await();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(promise.isSuccess()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用正常</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> promise.getNow();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用失败</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(promise.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) o;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">LOCK</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取唯一的 channel 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title function_\">getChannel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (LOCK) &#123; <span class=\"comment\">//  t2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (channel != <span class=\"literal\">null</span>) &#123; <span class=\"comment\">// t1</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            initChannel();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化 channel 方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">RpcResponseMessageHandler</span> <span class=\"variable\">RPC_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RpcResponseMessageHandler</span>();</span><br><span class=\"line\">        <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">        bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">        bootstrap.group(group);</span><br><span class=\"line\">        bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            channel = bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class=\"line\">                group.shutdownGracefully();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"6）客户端-handler-第二版\"><a href=\"#6）客户端-handler-第二版\" class=\"headerlink\" title=\"6）客户端 handler 第二版\"></a>6）客户端 handler 第二版</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RpcResponseMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//                       序号      用来接收结果的 promise 对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class=\"keyword\">new</span> <span class=\"title class_\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">        <span class=\"comment\">// 拿到空的 promise</span></span><br><span class=\"line\">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (promise != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Object</span> <span class=\"variable\">returnValue</span> <span class=\"operator\">=</span> msg.getReturnValue();</span><br><span class=\"line\">            <span class=\"type\">Exception</span> <span class=\"variable\">exceptionValue</span> <span class=\"operator\">=</span> msg.getExceptionValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(exceptionValue != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                promise.setFailure(exceptionValue);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setSuccess(returnValue);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"2-源码分析\"><a href=\"#2-源码分析\" class=\"headerlink\" title=\"2. 源码分析\"></a>2. 源码分析</h2><h3 id=\"2-1-启动剖析\"><a href=\"#2-1-启动剖析\" class=\"headerlink\" title=\"2.1 启动剖析\"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class=\"line\"><span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class=\"line\"><span class=\"type\">NioServerSocketChannel</span> <span class=\"variable\">attachment</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioServerSocketChannel</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class=\"line\"><span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">serverSocketChannel</span> <span class=\"operator\">=</span> ServerSocketChannel.open(); </span><br><span class=\"line\">serverSocketChannel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class=\"line\"><span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> serverSocketChannel.register(selector, <span class=\"number\">0</span>, attachment);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//7 绑定端口</span></span><br><span class=\"line\">serverSocketChannel.bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class=\"line\">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ChannelFuture <span class=\"title function_\">doBind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> initAndRegister();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> regFuture.channel();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.1 如果已经完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.isDone()) &#123;</span><br><span class=\"line\">        <span class=\"type\">ChannelPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> channel.newPromise();</span><br><span class=\"line\">        <span class=\"comment\">// 3.1 立刻调用 doBind0</span></span><br><span class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 2.2 还没有完成</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">PendingRegistrationPromise</span> <span class=\"variable\">promise</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PendingRegistrationPromise</span>(channel);</span><br><span class=\"line\">        <span class=\"comment\">// 3.2 回调 doBind0</span></span><br><span class=\"line\">        regFuture.addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"type\">Throwable</span> <span class=\"variable\">cause</span> <span class=\"operator\">=</span> future.cause();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cause != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">                    promise.setFailure(cause);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    promise.registered();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 3. 由注册线程去执行 doBind0</span></span><br><span class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> ChannelFuture <span class=\"title function_\">initAndRegister</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        channel = channelFactory.newChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class=\"line\">        init(channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultChannelPromise</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">regFuture</span> <span class=\"operator\">=</span> config().group().register(channel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (regFuture.cause() != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理异常...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regFuture;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">init</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (options) &#123;</span><br><span class=\"line\">        setChannelOptions(channel, options, logger);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (attrs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class=\"line\">            channel.attr(key).set(e.getValue());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> channel.pipeline();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">EventLoopGroup</span> <span class=\"variable\">currentChildGroup</span> <span class=\"operator\">=</span> childGroup;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelHandler</span> <span class=\"variable\">currentChildHandler</span> <span class=\"operator\">=</span> childHandler;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childOptions) &#123;</span><br><span class=\"line\">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (childAttrs) &#123;</span><br><span class=\"line\">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class=\"line\">    p.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(<span class=\"keyword\">final</span> Channel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ch.pipeline();</span><br><span class=\"line\">            <span class=\"type\">ChannelHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> config.handler();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handler != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.addLast(handler);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class=\"line\">            ch.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    pipeline.addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrapAcceptor</span>(</span><br><span class=\"line\">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        <span class=\"comment\">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Close the channel directly to avoid FD leak.</span></span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initMap.add(ctx)) &#123; <span class=\"comment\">// Guard against re-entrance.</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.1 执行初始化</span></span><br><span class=\"line\">            initChannel((C) ctx.channel());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable cause) &#123;</span><br><span class=\"line\">            exceptionCaught(ctx, cause);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2.2.2 移除初始化器</span></span><br><span class=\"line\">            <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> ctx.pipeline();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pipeline.context(<span class=\"built_in\">this</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                pipeline.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 3.1 或 3.2 执行 doBind0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind0</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> ChannelFuture regFuture, <span class=\"keyword\">final</span> Channel channel,</span></span><br><span class=\"line\"><span class=\"params\">        <span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    channel.eventLoop().execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (regFuture.isSuccess()) &#123;</span><br><span class=\"line\">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                promise.setFailure(regFuture.cause());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">(<span class=\"keyword\">final</span> SocketAddress localAddress, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    assertEventLoop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class=\"line\">        localAddress <span class=\"keyword\">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class=\"line\">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class=\"line\">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">wasActive</span> <span class=\"operator\">=</span> isActive();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 3.3 执行端口绑定</span></span><br><span class=\"line\">        doBind(localAddress);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">        closeIfClosed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class=\"line\">        invokeLater(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 3.4 触发 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    safeSetSuccess(promise);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBind</span><span class=\"params\">(SocketAddress localAddress)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PlatformDependent.javaVersion() &gt;= <span class=\"number\">7</span>) &#123;</span><br><span class=\"line\">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"comment\">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-2-NioEventLoop-剖析\"><a href=\"#2-2-NioEventLoop-剖析\" class=\"headerlink\" title=\"2.2 NioEventLoop 剖析\"></a>2.2 NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>\n<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">execute</span><span class=\"params\">(Runnable task)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>(<span class=\"string\">&quot;task&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">inEventLoop</span> <span class=\"operator\">=</span> inEventLoop();</span><br><span class=\"line\">    <span class=\"comment\">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class=\"line\">    addTask(task);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class=\"line\">        startThread();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isShutdown()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class=\"line\">        wakeup(inEventLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wakeup</span><span class=\"params\">(<span class=\"type\">boolean</span> inEventLoop)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">        selector.wakeup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doStartThread</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> thread == <span class=\"literal\">null</span>;</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class=\"line\">            thread = Thread.currentThread();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (interrupted) &#123;</span><br><span class=\"line\">                thread.interrupt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            updateLastExecutionTime();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class=\"line\">                SingleThreadEventExecutor.<span class=\"built_in\">this</span>.run();</span><br><span class=\"line\">                success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 清理工作，代码略...</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// calculateStrategy 的逻辑如下：</span></span><br><span class=\"line\">                <span class=\"comment\">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class=\"line\">                <span class=\"comment\">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class=\"line\">                <span class=\"keyword\">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.CONTINUE:</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">case</span> SelectStrategy.SELECT:</span><br><span class=\"line\">                        <span class=\"comment\">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class=\"line\">                        <span class=\"comment\">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class=\"line\">                        <span class=\"type\">boolean</span> <span class=\"variable\">oldWakenUp</span> <span class=\"operator\">=</span> wakenUp.getAndSet(<span class=\"literal\">false</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"comment\">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class=\"line\">                        <span class=\"comment\">// 下面的 select 方法不会阻塞</span></span><br><span class=\"line\">                        <span class=\"comment\">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class=\"line\">                        <span class=\"comment\">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class=\"line\">                        <span class=\"comment\">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class=\"line\">                        select(oldWakenUp);</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (wakenUp.get()) &#123;</span><br><span class=\"line\">                            selector.wakeup();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                rebuildSelector0();</span><br><span class=\"line\">                handleLoopException(e);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            cancelledKeys = <span class=\"number\">0</span>;</span><br><span class=\"line\">            needsToSelectAgain = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// ioRatio 默认是 50</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">ioRatio</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.ioRatio;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ioRatio == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class=\"line\">                    runAllTasks();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;                </span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioStartTime</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    processSelectedKeys();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 记录 io 事件处理耗时</span></span><br><span class=\"line\">                    <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ioTime</span> <span class=\"operator\">=</span> System.nanoTime() - ioStartTime;</span><br><span class=\"line\">                    <span class=\"comment\">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class=\"line\">                    runAllTasks(ioTime * (<span class=\"number\">100</span> - ioRatio) / ioRatio);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isShuttingDown()) &#123;</span><br><span class=\"line\">                closeAll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (confirmShutdown()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            handleLoopException(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"⚠️-注意\"><a href=\"#⚠️-注意\" class=\"headerlink\" title=\"⚠️ 注意\"></a>⚠️ 注意</h4><blockquote>\n<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>\n<ul>\n<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>\n<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>\n</ul>\n</blockquote>\n<p>参考下图</p>\n<img src=\"img/0032.png\"  />\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select</span><span class=\"params\">(<span class=\"type\">boolean</span> oldWakenUp)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selector;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">selectCnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">currentTimeNanos</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 计算等待时间</span></span><br><span class=\"line\">        <span class=\"comment\">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class=\"line\">        <span class=\"comment\">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">selectDeadLineNanos</span> <span class=\"operator\">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">timeoutMillis</span> <span class=\"operator\">=</span> (selectDeadLineNanos - currentTimeNanos + <span class=\"number\">500000L</span>) / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果超时，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeoutMillis &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (selectCnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    selector.selectNow();</span><br><span class=\"line\">                    selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class=\"line\">            <span class=\"comment\">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class=\"literal\">false</span>, <span class=\"literal\">true</span>)) &#123;</span><br><span class=\"line\">                selector.selectNow();</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// select 有限时阻塞</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">selectedKeys</span> <span class=\"operator\">=</span> selector.select(timeoutMillis);</span><br><span class=\"line\">            <span class=\"comment\">// 计数加 1</span></span><br><span class=\"line\">            selectCnt ++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (selectedKeys != <span class=\"number\">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">               \t<span class=\"comment\">// 线程被打断，退出循环</span></span><br><span class=\"line\">                <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">time</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"comment\">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class=\"line\">            <span class=\"comment\">// 这是为了解决 nio 空轮询 bug</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重建 selector</span></span><br><span class=\"line\">                selector = selectRebuildSelector(selectCnt);</span><br><span class=\"line\">                selectCnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            currentTimeNanos = time;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录日志</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKeys</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedKeys != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class=\"line\">        <span class=\"comment\">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class=\"line\">        processSelectedKeysOptimized();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">processSelectedKey</span><span class=\"params\">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> AbstractNioChannel.<span class=\"type\">NioUnsafe</span> <span class=\"variable\">unsafe</span> <span class=\"operator\">=</span> ch.unsafe();</span><br><span class=\"line\">    <span class=\"comment\">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!k.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无效时处理...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readyOps</span> <span class=\"operator\">=</span> k.readyOps();</span><br><span class=\"line\">        <span class=\"comment\">// 连接事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">ops</span> <span class=\"operator\">=</span> k.interestOps();</span><br><span class=\"line\">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class=\"line\">            k.interestOps(ops);</span><br><span class=\"line\"></span><br><span class=\"line\">            unsafe.finishConnect();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可写事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ch.unsafe().forceFlush();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可读或可接入事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class=\"number\">0</span> || readyOps == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class=\"line\">            unsafe.read();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class=\"line\">        unsafe.close(unsafe.voidPromise());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-accept-剖析\"><a href=\"#2-3-accept-剖析\" class=\"headerlink\" title=\"2.3 accept 剖析\"></a>2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 阻塞直到事件发生</span></span><br><span class=\"line\">selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter.hasNext()) &#123;    </span><br><span class=\"line\">    <span class=\"comment\">//2 拿到一个事件</span></span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> iter.next();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3 如果是 accept 事件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//4 执行 accept</span></span><br><span class=\"line\">        <span class=\"type\">SocketChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverSocketChannel.accept();</span><br><span class=\"line\">        channel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//5 关注 read 事件</span></span><br><span class=\"line\">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>先来看可接入事件处理（accept）</p>\n<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"title function_\">eventLoop</span><span class=\"params\">()</span>.inEventLoop();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> unsafe().recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">closed</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"type\">Throwable</span> <span class=\"variable\">exception</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class=\"line\">                <span class=\"comment\">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">localRead</span> <span class=\"operator\">=</span> doReadMessages(readBuf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (localRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    closed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class=\"line\">                allocHandle.incMessagesRead(localRead);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            exception = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> readBuf.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i ++) &#123;</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class=\"line\">            <span class=\"comment\">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class=\"line\">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        readBuf.clear();</span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (exception != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            closed = closeOnReadError(exception);</span><br><span class=\"line\"></span><br><span class=\"line\">            pipeline.fireExceptionCaught(exception);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">            inputShutdown = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isOpen()) &#123;</span><br><span class=\"line\">                close(voidPromise());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这时的 msg 是 NioSocketChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">Channel</span> <span class=\"variable\">child</span> <span class=\"operator\">=</span> (Channel) msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class=\"line\">    child.pipeline().addLast(childHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置选项</span></span><br><span class=\"line\">    setChannelOptions(child, childOptions, logger);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class=\"line\">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class=\"line\">        childGroup.register(child).addListener(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelFutureListener</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">operationComplete</span><span class=\"params\">(ChannelFuture future)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!future.isSuccess()) &#123;</span><br><span class=\"line\">                    forceClose(child, future.cause());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        forceClose(child, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register</span><span class=\"params\">(EventLoop eventLoop, <span class=\"keyword\">final</span> ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一些检查，略...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    AbstractChannel.<span class=\"built_in\">this</span>.eventLoop = eventLoop;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class=\"line\">        register0(promise);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class=\"line\">            eventLoop.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    register0(promise);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 日志记录...</span></span><br><span class=\"line\">            closeForcibly();</span><br><span class=\"line\">            closeFuture.setClosed();</span><br><span class=\"line\">            safeSetFailure(promise, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">register0</span><span class=\"params\">(ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">firstRegistration</span> <span class=\"operator\">=</span> neverRegistered;</span><br><span class=\"line\">        doRegister();</span><br><span class=\"line\">        neverRegistered = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        registered = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        <span class=\"comment\">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class=\"line\">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class=\"line\">        <span class=\"comment\">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class=\"line\"></span><br><span class=\"line\">        safeSetSuccess(promise);</span><br><span class=\"line\">        pipeline.fireChannelRegistered();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isActive()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstRegistration) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 触发 pipeline 上 active 事件</span></span><br><span class=\"line\">                pipeline.fireChannelActive();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (config().isAutoRead()) &#123;</span><br><span class=\"line\">                beginRead();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        closeForcibly();</span><br><span class=\"line\">        closeFuture.setClosed();</span><br><span class=\"line\">        safeSetFailure(promise, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">    ctx.fireChannelActive();</span><br><span class=\"line\">\t<span class=\"comment\">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class=\"line\">    readIfIsAutoRead();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doBeginRead</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">SelectionKey</span> <span class=\"variable\">selectionKey</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.selectionKey;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!selectionKey.isValid()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    readPending = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 这时候 interestOps 是 0</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">interestOps</span> <span class=\"operator\">=</span> selectionKey.interestOps();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((interestOps &amp; readInterestOp) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关注 read 事件</span></span><br><span class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-read-剖析\"><a href=\"#2-4-read-剖析\" class=\"headerlink\" title=\"2.4 read 剖析\"></a>2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">read</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelConfig</span> <span class=\"variable\">config</span> <span class=\"operator\">=</span> config();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class=\"line\">        clearReadPending();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ChannelPipeline</span> <span class=\"variable\">pipeline</span> <span class=\"operator\">=</span> pipeline();</span><br><span class=\"line\">    <span class=\"comment\">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">ByteBufAllocator</span> <span class=\"variable\">allocator</span> <span class=\"operator\">=</span> config.getAllocator();</span><br><span class=\"line\">    <span class=\"comment\">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> RecvByteBufAllocator.<span class=\"type\">Handle</span> <span class=\"variable\">allocHandle</span> <span class=\"operator\">=</span> recvBufAllocHandle();</span><br><span class=\"line\">    allocHandle.reset(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">ByteBuf</span> <span class=\"variable\">byteBuf</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">close</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            byteBuf = allocHandle.allocate(allocator);</span><br><span class=\"line\">            <span class=\"comment\">// 读取</span></span><br><span class=\"line\">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (allocHandle.lastBytesRead() &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                byteBuf.release();</span><br><span class=\"line\">                byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                close = allocHandle.lastBytesRead() &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">                    readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            allocHandle.incMessagesRead(<span class=\"number\">1</span>);</span><br><span class=\"line\">            readPending = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class=\"line\">            pipeline.fireChannelRead(byteBuf);</span><br><span class=\"line\">            byteBuf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"comment\">// 是否要继续循环</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (allocHandle.continueReading());</span><br><span class=\"line\"></span><br><span class=\"line\">        allocHandle.readComplete();</span><br><span class=\"line\">        <span class=\"comment\">// 触发 read complete 事件</span></span><br><span class=\"line\">        pipeline.fireChannelReadComplete();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (close) &#123;</span><br><span class=\"line\">            closeOnRead(pipeline);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class=\"line\">            removeReadOp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">continueReading</span><span class=\"params\">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">           <span class=\"comment\">// 一般为 true</span></span><br><span class=\"line\">           config.isAutoRead() &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// respectMaybeMoreData 默认为 true</span></span><br><span class=\"line\">           <span class=\"comment\">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class=\"line\">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class=\"line\">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class=\"line\">           <span class=\"comment\">// 实际读到了数据</span></span><br><span class=\"line\">           totalBytesRead &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Netty03-进阶","date":"2023-05-06T13:25:02.000Z","_content":"\n该笔记是B站黑马的Netty视频的配套笔记3。\n<!-- more -->\n# 三. Netty 进阶\n\n## 1. 粘包与半包\n\n### 1.1 粘包现象\n\n服务端代码\n\n```java\npublic class HelloWorldServer {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"connected {}\", ctx.channel());\n                            super.channelActive(ctx);\n                        }\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"disconnect {}\", ctx.channel());\n                            super.channelInactive(ctx);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = serverBootstrap.bind(8080);\n            log.debug(\"{} binding...\", channelFuture.channel());\n            channelFuture.sync();\n            log.debug(\"{} bound...\", channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(\"stoped\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HelloWorldServer().start();\n    }\n}\n```\n\n客户端代码希望发送 10 个消息，每个消息是 16 字节\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            for (int i = 0; i < 10; i++) {\n                                ByteBuf buffer = ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                                ctx.writeAndFlush(buffer);\n                            }\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"127.0.0.1\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\n\n```\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE\n```\n\n\n\n### 1.2 半包现象\n\n客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\n\n```java\nByteBuf buffer = ctx.alloc().buffer();\nfor (int i = 0; i < 10; i++) {\n    buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n}\nctx.writeAndFlush(buffer);\n```\n\n为现象明显，服务端修改一下接收缓冲区，其它代码不变\n\n```java\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);\n```\n\n服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\n\n```\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n```\n\n> **注意**\n>\n> serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\n\n\n\n### 1.3 现象分析\n\n粘包\n\n* 现象，发送 abc def，接收 abcdef\n* 原因\n  * 应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\n  * 滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\n  * Nagle 算法：会造成粘包\n\n半包\n\n* 现象，发送 abcdef，接收 abc def\n* 原因\n  * 应用层：接收方 ByteBuf 小于实际发送数据量\n  * 滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\n  * MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\n\n\n本质是因为 TCP 是流式协议，消息无边界\n\n\n\n> 滑动窗口\n>\n> * TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\n>\n>   ![](img/0049.png)\n>\n> \n>\n> * 为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\n>\n>   ![](img/0051.png)\n>\n> * 窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\n>\n>   * 图中深色的部分即要发送的数据，高亮的部分即窗口\n>   * 窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\n>   * 如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\n>   * 接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\n>\n\n\n\n>  MSS 限制\n>\n>  * 链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\n>\n>   * 以太网的 MTU 是 1500\n>   * FDDI（光纤分布式数据接口）的 MTU 是 4352\n>   * 本地回环地址的 MTU 是 65535 - 本地测试不走网卡\n>\n>  * MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\n>\n>   * ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\n>   * TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\n>   * MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\n>\n>   <img src=\"img/0031.jpg\" style=\"zoom:50%;\" />\n\n\n\n> Nagle 算法\n>\n> * 即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由\n> * 该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送\n>   * 如果 SO_SNDBUF 的数据达到 MSS，则需要发送\n>   * 如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\n>   * 如果 TCP_NODELAY = true，则需要发送\n>   * 已发送的数据都收到 ack 时，则需要发送\n>   * 上述条件不满足，但发生超时（一般为 200ms）则需要发送\n>   * 除上述情况，延迟发送\n\n\n\n### 1.4 解决方案\n\n1. 短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\n2. 每一条消息采用固定长度，缺点浪费空间\n3. 每一条消息采用分隔符，例如 \\n，缺点需要转义\n4. 每一条消息分为 head 和 body，head 中包含 body 的长度\n\n\n\n#### 方法1，短链接\n\n以解决粘包为例\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        // 分 10 次发送\n        for (int i = 0; i < 10; i++) {\n            send();\n        }\n    }\n\n    private static void send() {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"conneted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                            ctx.writeAndFlush(buffer);\n                            // 发完即关\n                            ctx.close();\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n输出，略\n\n> 半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\n\n\n\n#### 方法2，固定长度\n\n让所有数据包长度固定（假设长度为 8 字节），服务器端加入\n\n```java\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));\n```\n\n客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            // 发送内容随机的数据包\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte[] bytes = new byte[8];\n                                for (int j = 0; j < r.nextInt(8); j++) {\n                                    bytes[j] = (byte) c;\n                                }\n                                c++;\n                                buffer.writeBytes(bytes);\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE\n```\n\n缺点是，数据包的大小不好把握\n\n* 长度定的太大，浪费\n* 长度定的太小，对某些数据包又显得不够\n\n\n\n#### 方法3，固定分隔符\n\n服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\n\n```java\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n```\n\n客户端在每条消息之后，加入 \\n 分隔符\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                for (int j = 1; j <= r.nextInt(16)+1; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                buffer.writeByte(10);\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE\n```\n\n缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\n\n\n\n#### 方法4，预设长度\n\n在发送消息前，先约定用定长字节表示接下来数据的长度\n\n```java\n// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));\n```\n\n客户端代码\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte length = (byte) (r.nextInt(16) + 1);\n                                // 先写入长度\n                                buffer.writeByte(length);\n                                // 再\n                                for (int j = 1; j <= length; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n客户端输出\n\n```\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE\n\n```\n\n\n\n## 2. 协议设计与解析\n\n### 2.1 为什么需要协议？\n\nTCP/IP 中消息传输基于流的方式，没有边界。\n\n协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\n\n例如：在网络上传输\n\n```\n下雨天留客天留我不留\n```\n\n是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\n\n一种解读\n\n```\n下雨天留客，天留，我不留\n```\n\n另一种解读\n\n```\n下雨天，留客天，留我不？留\n```\n\n\n\n如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\n\n``` \n定长字节表示内容长度 + 实际内容\n```\n\n例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\n\n```\n0f下雨天留客06天留09我不留\n```\n\n\n\n> 小故事\n>\n> 很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\n>\n> 年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\n>\n> 私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\n>\n> 双方唇枪舌战，你来我往，真个是不亦乐乎！\n>\n> 这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\n\n\n\n### 2.2 redis 协议举例\n\n```java\nNioEventLoopGroup worker = new NioEventLoopGroup();\nbyte[] LINE = {13, 10};\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                // 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) {\n                    set(ctx);\n                    get(ctx);\n                }\n                private void get(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*2\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"get\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n                private void set(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"set\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"bbb\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    ByteBuf buf = (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                }\n            });\n        }\n    });\n    ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 6379).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"client error\", e);\n} finally {\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.3 http 协议举例\n\n```java\nNioEventLoopGroup boss = new NioEventLoopGroup();\nNioEventLoopGroup worker = new NioEventLoopGroup();\ntry {\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {\n                    // 获取请求\n                    log.debug(msg.uri());\n\n                    // 返回响应\n                    DefaultFullHttpResponse response =\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes = \"<h1>Hello, world!</h1>\".getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                    response.content().writeBytes(bytes);\n\n                    // 写回响应\n                    ctx.writeAndFlush(response);\n                }\n            });\n            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    log.debug(\"{}\", msg.getClass());\n\n                    if (msg instanceof HttpRequest) { // 请求行，请求头\n\n                    } else if (msg instanceof HttpContent) { //请求体\n\n                    }\n                }\n            });*/\n        }\n    });\n    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"server error\", e);\n} finally {\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.4 自定义协议要素\n\n* 魔数，用来在第一时间判定是否是无效数据包\n* 版本号，可以支持协议的升级\n* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk\n* 指令类型，是登录、注册、单聊、群聊... 跟业务相关\n* 请求序号，为了双工通信，提供异步能力\n* 正文长度\n* 消息正文\n\n\n\n#### 编解码器\n\n根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\n\n```java\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec<Message> {\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n测试\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n// encode\nLoginRequestMessage message = new LoginRequestMessage(\"zhangsan\", \"123\", \"张三\");\n//        channel.writeOutbound(message);\n// decode\nByteBuf buf = ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 = buf.slice(0, 100);\nByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); // 引用计数 2\nchannel.writeInbound(s1); // release 1\nchannel.writeInbound(s2);\n```\n\n\n\n解读\n\n![](img/0013.png)\n\n\n\n#### 💡 什么时候可以加 @Sharable\n\n* 当 handler 不保存状态时，就可以安全地在多线程下被共享\n* 但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\n* 如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n## 3. 聊天室案例\n\n### 3.1 聊天室业务介绍\n\n```java\n/**\n * 用户管理接口\n */\npublic interface UserService {\n\n    /**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     */\n    boolean login(String username, String password);\n}\n```\n\n\n\n```java\n/**\n * 会话管理接口\n */\npublic interface Session {\n\n    /**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     */\n    void bind(Channel channel, String username);\n\n    /**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     */\n    void unbind(Channel channel);\n\n    /**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     */\n    Object getAttribute(Channel channel, String name);\n\n    /**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     */\n    void setAttribute(Channel channel, String name, Object value);\n\n    /**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     */\n    Channel getChannel(String username);\n}\n```\n\n\n\n```java\n/**\n * 聊天组会话管理接口\n */\npublic interface GroupSession {\n\n    /**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     */\n    Group createGroup(String name, Set<String> members);\n\n    /**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group joinMember(String name, String member);\n\n    /**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeMember(String name, String member);\n\n    /**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeGroup(String name);\n\n    /**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     */\n    Set<String> getMembers(String name);\n\n    /**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     */\n    List<Channel> getMembersChannel(String name);\n}\n```\n\n\n\n### 3.2 聊天室业务-登录\n\n```java\n@Slf4j\npublic class ChatServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n                            String username = msg.getUsername();\n                            String password = msg.getPassword();\n                            boolean login = UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) {\n                                message = new LoginResponseMessage(true, \"登录成功\");\n                            } else {\n                                message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n                            }\n                            ctx.writeAndFlush(message);\n                        }\n                    });\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n```java\n@Slf4j\npublic class ChatClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);\n        AtomicBoolean LOGIN = new AtomicBoolean(false);\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n//                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(\"client handler\", new ChannelInboundHandlerAdapter() {\n                        // 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                            log.debug(\"msg: {}\", msg);\n                            if ((msg instanceof LoginResponseMessage)) {\n                                LoginResponseMessage response = (LoginResponseMessage) msg;\n                                if (response.isSuccess()) {\n                                    // 如果登录成功\n                                    LOGIN.set(true);\n                                }\n                                // 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            }\n                        }\n\n                        // 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -> {\n                                Scanner scanner = new Scanner(System.in);\n                                System.out.println(\"请输入用户名:\");\n                                String username = scanner.nextLine();\n                                System.out.println(\"请输入密码:\");\n                                String password = scanner.nextLine();\n                                // 构造消息对象\n                                LoginRequestMessage message = new LoginRequestMessage(username, password);\n                                // 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(\"等待后续操作...\");\n                                try {\n                                    WAIT_FOR_LOGIN.await();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                                // 如果登录失败\n                                if (!LOGIN.get()) {\n                                    ctx.channel().close();\n                                    return;\n                                }\n                                while (true) {\n                                    System.out.println(\"==================================\");\n                                    System.out.println(\"send [username] [content]\");\n                                    System.out.println(\"gsend [group name] [content]\");\n                                    System.out.println(\"gcreate [group name] [m1,m2,m3...]\");\n                                    System.out.println(\"gmembers [group name]\");\n                                    System.out.println(\"gjoin [group name]\");\n                                    System.out.println(\"gquit [group name]\");\n                                    System.out.println(\"quit\");\n                                    System.out.println(\"==================================\");\n                                    String command = scanner.nextLine();\n                                    String[] s = command.split(\" \");\n                                    switch (s[0]){\n                                        case \"send\":\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gsend\":\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gcreate\":\n                                            Set<String> set = new HashSet<>(Arrays.asList(s[2].split(\",\")));\n                                            set.add(username); // 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case \"gmembers\":\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case \"gjoin\":\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case \"gquit\":\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case \"quit\":\n                                            ctx.channel().close();\n                                            return;\n                                    }\n                                }\n                            }, \"system in\").start();\n                        }\n                    });\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n### 3.3 聊天室业务-单聊\n\n服务器端将 handler 独立出来\n\n登录 handler\n\n```java\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n        String username = msg.getUsername();\n        String password = msg.getPassword();\n        boolean login = UserServiceFactory.getUserService().login(username, password);\n        LoginResponseMessage message;\n        if(login) {\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message = new LoginResponseMessage(true, \"登录成功\");\n        } else {\n            message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n        }\n        ctx.writeAndFlush(message);\n    }\n}\n```\n\n单聊 handler\n\n```java\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception {\n        String to = msg.getTo();\n        Channel channel = SessionFactory.getSession().getChannel(to);\n        // 在线\n        if(channel != null) {\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n        // 不在线\n        else {\n            ctx.writeAndFlush(new ChatResponseMessage(false, \"对方用户不存在或者不在线\"));\n        }\n    }\n}\n```\n\n\n\n### 3.4 聊天室业务-群聊\n\n创建群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception {\n        String groupName = msg.getGroupName();\n        Set<String> members = msg.getMembers();\n        // 群管理器\n        GroupSession groupSession = GroupSessionFactory.getGroupSession();\n        Group group = groupSession.createGroup(groupName, members);\n        if (group == null) {\n            // 发生成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + \"创建成功\"));\n            // 发送拉群消息\n            List<Channel> channels = groupSession.getMembersChannel(groupName);\n            for (Channel channel : channels) {\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, \"您已被拉入\" + groupName));\n            }\n        } else {\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + \"已经存在\"));\n        }\n    }\n}\n```\n\n群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception {\n        List<Channel> channels = GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n    }\n}\n```\n\n加入群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群加入成功\"));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n退出群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, \"已退出群\" + msg.getGroupName()));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n查看成员\n\n```java\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception {\n        Set<String> members = GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    }\n}\n```\n\n\n\n### 3.5 聊天室业务-退出\n\n```\n@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter {\n\n    // 当连接断开时触发 inactive 事件\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经断开\", ctx.channel());\n    }\n\n\t// 当出现异常时触发\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经异常断开 异常是{}\", ctx.channel(), cause.getMessage());\n    }\n}\n```\n\n\n\n### 3.6 聊天室业务-空闲检测\n\n\n\n#### 连接假死\n\n原因\n\n* 网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\n* 公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\n* 应用程序线程阻塞，无法进行数据读写\n\n问题\n\n* 假死的连接占用的资源不能自动释放\n* 向假死的连接发送数据，得到的反馈是发送超时\n\n服务器端解决\n\n* 怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了读空闲事件\n        if (event.state() == IdleState.READER_IDLE) {\n            log.debug(\"已经 5s 没有读到数据了\");\n            ctx.channel().close();\n        }\n    }\n});\n```\n\n\n\n客户端定时心跳\n\n* 客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了写空闲事件\n        if (event.state() == IdleState.WRITER_IDLE) {\n            //                                log.debug(\"3s 没有写数据了，发送一个心跳包\");\n            ctx.writeAndFlush(new PingMessage());\n        }\n    }\n});\n```\n\n\n\n\n\n\n","source":"_posts/2023-05-06-Netty03-进阶.md","raw":"---\ntitle: Netty03-进阶\ndate: 2023-05-06 21:25:02\ntags: \n- Netty\n- programing\n- Java\ncategories: Netty\n---\n\n该笔记是B站黑马的Netty视频的配套笔记3。\n<!-- more -->\n# 三. Netty 进阶\n\n## 1. 粘包与半包\n\n### 1.1 粘包现象\n\n服务端代码\n\n```java\npublic class HelloWorldServer {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldServer.class);\n    void start() {\n        NioEventLoopGroup boss = new NioEventLoopGroup(1);\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"connected {}\", ctx.channel());\n                            super.channelActive(ctx);\n                        }\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"disconnect {}\", ctx.channel());\n                            super.channelInactive(ctx);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = serverBootstrap.bind(8080);\n            log.debug(\"{} binding...\", channelFuture.channel());\n            channelFuture.sync();\n            log.debug(\"{} bound...\", channelFuture.channel());\n            channelFuture.channel().closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(\"stoped\");\n        }\n    }\n\n    public static void main(String[] args) {\n        new HelloWorldServer().start();\n    }\n}\n```\n\n客户端代码希望发送 10 个消息，每个消息是 16 字节\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            for (int i = 0; i < 10; i++) {\n                                ByteBuf buffer = ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                                ctx.writeAndFlush(buffer);\n                            }\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"127.0.0.1\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收\n\n```\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...\n08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE\n```\n\n\n\n### 1.2 半包现象\n\n客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为\n\n```java\nByteBuf buffer = ctx.alloc().buffer();\nfor (int i = 0; i < 10; i++) {\n    buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n}\nctx.writeAndFlush(buffer);\n```\n\n为现象明显，服务端修改一下接收缓冲区，其它代码不变\n\n```java\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);\n```\n\n服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节\n\n```\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...\n08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE\n08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |\n+--------+-------------------------------------------------+----------------+\n08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE\n```\n\n> **注意**\n>\n> serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\n\n\n\n### 1.3 现象分析\n\n粘包\n\n* 现象，发送 abc def，接收 abcdef\n* 原因\n  * 应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）\n  * 滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\n  * Nagle 算法：会造成粘包\n\n半包\n\n* 现象，发送 abcdef，接收 abc def\n* 原因\n  * 应用层：接收方 ByteBuf 小于实际发送数据量\n  * 滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\n  * MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\n\n\n本质是因为 TCP 是流式协议，消息无边界\n\n\n\n> 滑动窗口\n>\n> * TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差\n>\n>   ![](img/0049.png)\n>\n> \n>\n> * 为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值\n>\n>   ![](img/0051.png)\n>\n> * 窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用\n>\n>   * 图中深色的部分即要发送的数据，高亮的部分即窗口\n>   * 窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动\n>   * 如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动\n>   * 接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收\n>\n\n\n\n>  MSS 限制\n>\n>  * 链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如\n>\n>   * 以太网的 MTU 是 1500\n>   * FDDI（光纤分布式数据接口）的 MTU 是 4352\n>   * 本地回环地址的 MTU 是 65535 - 本地测试不走网卡\n>\n>  * MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数\n>\n>   * ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460\n>   * TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送\n>   * MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS\n>\n>   <img src=\"img/0031.jpg\" style=\"zoom:50%;\" />\n\n\n\n> Nagle 算法\n>\n> * 即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由\n> * 该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送\n>   * 如果 SO_SNDBUF 的数据达到 MSS，则需要发送\n>   * 如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭\n>   * 如果 TCP_NODELAY = true，则需要发送\n>   * 已发送的数据都收到 ack 时，则需要发送\n>   * 上述条件不满足，但发生超时（一般为 200ms）则需要发送\n>   * 除上述情况，延迟发送\n\n\n\n### 1.4 解决方案\n\n1. 短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低\n2. 每一条消息采用固定长度，缺点浪费空间\n3. 每一条消息采用分隔符，例如 \\n，缺点需要转义\n4. 每一条消息分为 head 和 body，head 中包含 body 的长度\n\n\n\n#### 方法1，短链接\n\n以解决粘包为例\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        // 分 10 次发送\n        for (int i = 0; i < 10; i++) {\n            send();\n        }\n    }\n\n    private static void send() {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"conneted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            buffer.writeBytes(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n                            ctx.writeAndFlush(buffer);\n                            // 发完即关\n                            ctx.close();\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n输出，略\n\n> 半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的\n\n\n\n#### 方法2，固定长度\n\n让所有数据包长度固定（假设长度为 8 字节），服务器端加入\n\n```java\nch.pipeline().addLast(new FixedLengthFrameDecoder(8));\n```\n\n客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            // 发送内容随机的数据包\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte[] bytes = new byte[8];\n                                for (int j = 0; j < r.nextInt(8); j++) {\n                                    bytes[j] = (byte) c;\n                                }\n                                c++;\n                                buffer.writeBytes(bytes);\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|\n|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|\n|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|\n|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|\n|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH\n```\n\n服务端输出\n\n```\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...\n12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 00 00 00 00 00 00 00                         |b.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00                         |cc......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 00 00 00 00 00 00 00                         |d.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 00 00 00 00 00                         |........        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 00 00 00 00 00 00 00                         |h.......        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |\n+--------+-------------------------------------------------+----------------+\n12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE\n```\n\n缺点是，数据包的大小不好把握\n\n* 长度定的太大，浪费\n* 长度定的太小，对某些数据包又显得不够\n\n\n\n#### 方法3，固定分隔符\n\n服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常\n\n```java\nch.pipeline().addLast(new LineBasedFrameDecoder(1024));\n```\n\n客户端在每条消息之后，加入 \\n 分隔符\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                for (int j = 1; j <= r.nextInt(16)+1; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                buffer.writeByte(10);\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n客户端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|\n|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|\n|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|\n|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61                                              |a               |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63                                        |ccc             |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64                                           |dd              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66                                           |ff              |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67 67 67 67 67 67                            |ggggggg         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68 68 68                                     |hhhh            |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |\n+--------+-------------------------------------------------+----------------+\n14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE\n```\n\n缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误\n\n\n\n#### 方法4，预设长度\n\n在发送消息前，先约定用定长字节表示接下来数据的长度\n\n```java\n// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数\nch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));\n```\n\n客户端代码\n\n```java\npublic class HelloWorldClient {\n    static final Logger log = LoggerFactory.getLogger(HelloWorldClient.class);\n\n    public static void main(String[] args) {\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    log.debug(\"connetted...\");\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            log.debug(\"sending...\");\n                            Random r = new Random();\n                            char c = 'a';\n                            ByteBuf buffer = ctx.alloc().buffer();\n                            for (int i = 0; i < 10; i++) {\n                                byte length = (byte) (r.nextInt(16) + 1);\n                                // 先写入长度\n                                buffer.writeByte(length);\n                                // 再\n                                for (int j = 1; j <= length; j++) {\n                                    buffer.writeByte((byte) c);\n                                }\n                                c++;\n                            }\n                            ctx.writeAndFlush(buffer);\n                        }\n                    });\n                }\n            });\n            ChannelFuture channelFuture = bootstrap.connect(\"192.168.0.103\", 9090).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        } catch (InterruptedException e) {\n            log.error(\"client error\", e);\n        } finally {\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n客户端输出\n\n```\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|\n|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|\n|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|\n|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|\n|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|\n|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|\n|00000060| 6a                                              |j               |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH\n```\n\n\n\n服务端输出\n\n```\n14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...\n14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 63 63 63 63                               |cccccc          |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 67 67                                           |gg              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 68 68                                           |hh              |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |\n+--------+-------------------------------------------------+----------------+\n14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE\n\n```\n\n\n\n## 2. 协议设计与解析\n\n### 2.1 为什么需要协议？\n\nTCP/IP 中消息传输基于流的方式，没有边界。\n\n协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\n\n例如：在网络上传输\n\n```\n下雨天留客天留我不留\n```\n\n是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性\n\n一种解读\n\n```\n下雨天留客，天留，我不留\n```\n\n另一种解读\n\n```\n下雨天，留客天，留我不？留\n```\n\n\n\n如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用\n\n``` \n定长字节表示内容长度 + 实际内容\n```\n\n例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了\n\n```\n0f下雨天留客06天留09我不留\n```\n\n\n\n> 小故事\n>\n> 很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。\n>\n> 年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”\n>\n> 私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”\n>\n> 双方唇枪舌战，你来我往，真个是不亦乐乎！\n>\n> 这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬\n\n\n\n### 2.2 redis 协议举例\n\n```java\nNioEventLoopGroup worker = new NioEventLoopGroup();\nbyte[] LINE = {13, 10};\ntry {\n    Bootstrap bootstrap = new Bootstrap();\n    bootstrap.channel(NioSocketChannel.class);\n    bootstrap.group(worker);\n    bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) {\n            ch.pipeline().addLast(new LoggingHandler());\n            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                // 会在连接 channel 建立成功后，会触发 active 事件\n                @Override\n                public void channelActive(ChannelHandlerContext ctx) {\n                    set(ctx);\n                    get(ctx);\n                }\n                private void get(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*2\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"get\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n                private void set(ChannelHandlerContext ctx) {\n                    ByteBuf buf = ctx.alloc().buffer();\n                    buf.writeBytes(\"*3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"set\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"aaa\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"$3\".getBytes());\n                    buf.writeBytes(LINE);\n                    buf.writeBytes(\"bbb\".getBytes());\n                    buf.writeBytes(LINE);\n                    ctx.writeAndFlush(buf);\n                }\n\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    ByteBuf buf = (ByteBuf) msg;\n                    System.out.println(buf.toString(Charset.defaultCharset()));\n                }\n            });\n        }\n    });\n    ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 6379).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"client error\", e);\n} finally {\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.3 http 协议举例\n\n```java\nNioEventLoopGroup boss = new NioEventLoopGroup();\nNioEventLoopGroup worker = new NioEventLoopGroup();\ntry {\n    ServerBootstrap serverBootstrap = new ServerBootstrap();\n    serverBootstrap.channel(NioServerSocketChannel.class);\n    serverBootstrap.group(boss, worker);\n    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n        @Override\n        protected void initChannel(SocketChannel ch) throws Exception {\n            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n            ch.pipeline().addLast(new HttpServerCodec());\n            ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {\n                @Override\n                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {\n                    // 获取请求\n                    log.debug(msg.uri());\n\n                    // 返回响应\n                    DefaultFullHttpResponse response =\n                            new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n\n                    byte[] bytes = \"<h1>Hello, world!</h1>\".getBytes();\n\n                    response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                    response.content().writeBytes(bytes);\n\n                    // 写回响应\n                    ctx.writeAndFlush(response);\n                }\n            });\n            /*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n                @Override\n                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                    log.debug(\"{}\", msg.getClass());\n\n                    if (msg instanceof HttpRequest) { // 请求行，请求头\n\n                    } else if (msg instanceof HttpContent) { //请求体\n\n                    }\n                }\n            });*/\n        }\n    });\n    ChannelFuture channelFuture = serverBootstrap.bind(8080).sync();\n    channelFuture.channel().closeFuture().sync();\n} catch (InterruptedException e) {\n    log.error(\"server error\", e);\n} finally {\n    boss.shutdownGracefully();\n    worker.shutdownGracefully();\n}\n```\n\n\n\n### 2.4 自定义协议要素\n\n* 魔数，用来在第一时间判定是否是无效数据包\n* 版本号，可以支持协议的升级\n* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk\n* 指令类型，是登录、注册、单聊、群聊... 跟业务相关\n* 请求序号，为了双工通信，提供异步能力\n* 正文长度\n* 消息正文\n\n\n\n#### 编解码器\n\n根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发\n\n```java\n@Slf4j\npublic class MessageCodec extends ByteToMessageCodec<Message> {\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n测试\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(\n    new LoggingHandler(),\n    new LengthFieldBasedFrameDecoder(\n        1024, 12, 4, 0, 0),\n    new MessageCodec()\n);\n// encode\nLoginRequestMessage message = new LoginRequestMessage(\"zhangsan\", \"123\", \"张三\");\n//        channel.writeOutbound(message);\n// decode\nByteBuf buf = ByteBufAllocator.DEFAULT.buffer();\nnew MessageCodec().encode(null, message, buf);\n\nByteBuf s1 = buf.slice(0, 100);\nByteBuf s2 = buf.slice(100, buf.readableBytes() - 100);\ns1.retain(); // 引用计数 2\nchannel.writeInbound(s1); // release 1\nchannel.writeInbound(s2);\n```\n\n\n\n解读\n\n![](img/0013.png)\n\n\n\n#### 💡 什么时候可以加 @Sharable\n\n* 当 handler 不保存状态时，就可以安全地在多线程下被共享\n* 但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制\n* 如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类\n\n```java\n@Slf4j\n@ChannelHandler.Sharable\n/**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n */\npublic class MessageCodecSharable extends MessageToMessageCodec<ByteBuf, Message> {\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List<Object> outList) throws Exception {\n        ByteBuf out = ctx.alloc().buffer();\n        // 1. 4 字节的魔数\n        out.writeBytes(new byte[]{1, 2, 3, 4});\n        // 2. 1 字节的版本,\n        out.writeByte(1);\n        // 3. 1 字节的序列化方式 jdk 0 , json 1\n        out.writeByte(0);\n        // 4. 1 字节的指令类型\n        out.writeByte(msg.getMessageType());\n        // 5. 4 个字节\n        out.writeInt(msg.getSequenceId());\n        // 无意义，对齐填充\n        out.writeByte(0xff);\n        // 6. 获取内容的字节数组\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes = bos.toByteArray();\n        // 7. 长度\n        out.writeInt(bytes.length);\n        // 8. 写入内容\n        out.writeBytes(bytes);\n        outList.add(out);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        int magicNum = in.readInt();\n        byte version = in.readByte();\n        byte serializerType = in.readByte();\n        byte messageType = in.readByte();\n        int sequenceId = in.readInt();\n        in.readByte();\n        int length = in.readInt();\n        byte[] bytes = new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message = (Message) ois.readObject();\n        log.debug(\"{}, {}, {}, {}, {}, {}\", magicNum, version, serializerType, messageType, sequenceId, length);\n        log.debug(\"{}\", message);\n        out.add(message);\n    }\n}\n```\n\n\n\n## 3. 聊天室案例\n\n### 3.1 聊天室业务介绍\n\n```java\n/**\n * 用户管理接口\n */\npublic interface UserService {\n\n    /**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     */\n    boolean login(String username, String password);\n}\n```\n\n\n\n```java\n/**\n * 会话管理接口\n */\npublic interface Session {\n\n    /**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     */\n    void bind(Channel channel, String username);\n\n    /**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     */\n    void unbind(Channel channel);\n\n    /**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     */\n    Object getAttribute(Channel channel, String name);\n\n    /**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     */\n    void setAttribute(Channel channel, String name, Object value);\n\n    /**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     */\n    Channel getChannel(String username);\n}\n```\n\n\n\n```java\n/**\n * 聊天组会话管理接口\n */\npublic interface GroupSession {\n\n    /**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     */\n    Group createGroup(String name, Set<String> members);\n\n    /**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group joinMember(String name, String member);\n\n    /**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeMember(String name, String member);\n\n    /**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     */\n    Group removeGroup(String name);\n\n    /**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 没有成员会返回 empty set\n     */\n    Set<String> getMembers(String name);\n\n    /**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     */\n    List<Channel> getMembersChannel(String name);\n}\n```\n\n\n\n### 3.2 聊天室业务-登录\n\n```java\n@Slf4j\npublic class ChatServer {\n    public static void main(String[] args) {\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        try {\n            ServerBootstrap serverBootstrap = new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(new SimpleChannelInboundHandler<LoginRequestMessage>() {\n                        @Override\n                        protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n                            String username = msg.getUsername();\n                            String password = msg.getPassword();\n                            boolean login = UserServiceFactory.getUserService().login(username, password);\n                            LoginResponseMessage message;\n                            if(login) {\n                                message = new LoginResponseMessage(true, \"登录成功\");\n                            } else {\n                                message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n                            }\n                            ctx.writeAndFlush(message);\n                        }\n                    });\n                }\n            });\n            Channel channel = serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (InterruptedException e) {\n            log.error(\"server error\", e);\n        } finally {\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n```java\n@Slf4j\npublic class ChatClient {\n    public static void main(String[] args) {\n        NioEventLoopGroup group = new NioEventLoopGroup();\n        LoggingHandler LOGGING_HANDLER = new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable MESSAGE_CODEC = new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN = new CountDownLatch(1);\n        AtomicBoolean LOGIN = new AtomicBoolean(false);\n        try {\n            Bootstrap bootstrap = new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception {\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n//                    ch.pipeline().addLast(LOGGING_HANDLER);\n                    ch.pipeline().addLast(MESSAGE_CODEC);\n                    ch.pipeline().addLast(\"client handler\", new ChannelInboundHandlerAdapter() {\n                        // 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                            log.debug(\"msg: {}\", msg);\n                            if ((msg instanceof LoginResponseMessage)) {\n                                LoginResponseMessage response = (LoginResponseMessage) msg;\n                                if (response.isSuccess()) {\n                                    // 如果登录成功\n                                    LOGIN.set(true);\n                                }\n                                // 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            }\n                        }\n\n                        // 在连接建立后触发 active 事件\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n                            // 负责接收用户在控制台的输入，负责向服务器发送各种消息\n                            new Thread(() -> {\n                                Scanner scanner = new Scanner(System.in);\n                                System.out.println(\"请输入用户名:\");\n                                String username = scanner.nextLine();\n                                System.out.println(\"请输入密码:\");\n                                String password = scanner.nextLine();\n                                // 构造消息对象\n                                LoginRequestMessage message = new LoginRequestMessage(username, password);\n                                // 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(\"等待后续操作...\");\n                                try {\n                                    WAIT_FOR_LOGIN.await();\n                                } catch (InterruptedException e) {\n                                    e.printStackTrace();\n                                }\n                                // 如果登录失败\n                                if (!LOGIN.get()) {\n                                    ctx.channel().close();\n                                    return;\n                                }\n                                while (true) {\n                                    System.out.println(\"==================================\");\n                                    System.out.println(\"send [username] [content]\");\n                                    System.out.println(\"gsend [group name] [content]\");\n                                    System.out.println(\"gcreate [group name] [m1,m2,m3...]\");\n                                    System.out.println(\"gmembers [group name]\");\n                                    System.out.println(\"gjoin [group name]\");\n                                    System.out.println(\"gquit [group name]\");\n                                    System.out.println(\"quit\");\n                                    System.out.println(\"==================================\");\n                                    String command = scanner.nextLine();\n                                    String[] s = command.split(\" \");\n                                    switch (s[0]){\n                                        case \"send\":\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gsend\":\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case \"gcreate\":\n                                            Set<String> set = new HashSet<>(Arrays.asList(s[2].split(\",\")));\n                                            set.add(username); // 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case \"gmembers\":\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case \"gjoin\":\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case \"gquit\":\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case \"quit\":\n                                            ctx.channel().close();\n                                            return;\n                                    }\n                                }\n                            }, \"system in\").start();\n                        }\n                    });\n                }\n            });\n            Channel channel = bootstrap.connect(\"localhost\", 8080).sync().channel();\n            channel.closeFuture().sync();\n        } catch (Exception e) {\n            log.error(\"client error\", e);\n        } finally {\n            group.shutdownGracefully();\n        }\n    }\n}\n```\n\n\n\n### 3.3 聊天室业务-单聊\n\n服务器端将 handler 独立出来\n\n登录 handler\n\n```java\n@ChannelHandler.Sharable\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler<LoginRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception {\n        String username = msg.getUsername();\n        String password = msg.getPassword();\n        boolean login = UserServiceFactory.getUserService().login(username, password);\n        LoginResponseMessage message;\n        if(login) {\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message = new LoginResponseMessage(true, \"登录成功\");\n        } else {\n            message = new LoginResponseMessage(false, \"用户名或密码不正确\");\n        }\n        ctx.writeAndFlush(message);\n    }\n}\n```\n\n单聊 handler\n\n```java\n@ChannelHandler.Sharable\npublic class ChatRequestMessageHandler extends SimpleChannelInboundHandler<ChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, ChatRequestMessage msg) throws Exception {\n        String to = msg.getTo();\n        Channel channel = SessionFactory.getSession().getChannel(to);\n        // 在线\n        if(channel != null) {\n            channel.writeAndFlush(new ChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n        // 不在线\n        else {\n            ctx.writeAndFlush(new ChatResponseMessage(false, \"对方用户不存在或者不在线\"));\n        }\n    }\n}\n```\n\n\n\n### 3.4 聊天室业务-群聊\n\n创建群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupCreateRequestMessageHandler extends SimpleChannelInboundHandler<GroupCreateRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupCreateRequestMessage msg) throws Exception {\n        String groupName = msg.getGroupName();\n        Set<String> members = msg.getMembers();\n        // 群管理器\n        GroupSession groupSession = GroupSessionFactory.getGroupSession();\n        Group group = groupSession.createGroup(groupName, members);\n        if (group == null) {\n            // 发生成功消息\n            ctx.writeAndFlush(new GroupCreateResponseMessage(true, groupName + \"创建成功\"));\n            // 发送拉群消息\n            List<Channel> channels = groupSession.getMembersChannel(groupName);\n            for (Channel channel : channels) {\n                channel.writeAndFlush(new GroupCreateResponseMessage(true, \"您已被拉入\" + groupName));\n            }\n        } else {\n            ctx.writeAndFlush(new GroupCreateResponseMessage(false, groupName + \"已经存在\"));\n        }\n    }\n}\n```\n\n群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupChatRequestMessageHandler extends SimpleChannelInboundHandler<GroupChatRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupChatRequestMessage msg) throws Exception {\n        List<Channel> channels = GroupSessionFactory.getGroupSession()\n                .getMembersChannel(msg.getGroupName());\n\n        for (Channel channel : channels) {\n            channel.writeAndFlush(new GroupChatResponseMessage(msg.getFrom(), msg.getContent()));\n        }\n    }\n}\n```\n\n加入群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupJoinRequestMessageHandler extends SimpleChannelInboundHandler<GroupJoinRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupJoinRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群加入成功\"));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n退出群聊\n\n```java\n@ChannelHandler.Sharable\npublic class GroupQuitRequestMessageHandler extends SimpleChannelInboundHandler<GroupQuitRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupQuitRequestMessage msg) throws Exception {\n        Group group = GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());\n        if (group != null) {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, \"已退出群\" + msg.getGroupName()));\n        } else {\n            ctx.writeAndFlush(new GroupJoinResponseMessage(true, msg.getGroupName() + \"群不存在\"));\n        }\n    }\n}\n```\n\n查看成员\n\n```java\n@ChannelHandler.Sharable\npublic class GroupMembersRequestMessageHandler extends SimpleChannelInboundHandler<GroupMembersRequestMessage> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, GroupMembersRequestMessage msg) throws Exception {\n        Set<String> members = GroupSessionFactory.getGroupSession()\n                .getMembers(msg.getGroupName());\n        ctx.writeAndFlush(new GroupMembersResponseMessage(members));\n    }\n}\n```\n\n\n\n### 3.5 聊天室业务-退出\n\n```\n@Slf4j\n@ChannelHandler.Sharable\npublic class QuitHandler extends ChannelInboundHandlerAdapter {\n\n    // 当连接断开时触发 inactive 事件\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经断开\", ctx.channel());\n    }\n\n\t// 当出现异常时触发\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        SessionFactory.getSession().unbind(ctx.channel());\n        log.debug(\"{} 已经异常断开 异常是{}\", ctx.channel(), cause.getMessage());\n    }\n}\n```\n\n\n\n### 3.6 聊天室业务-空闲检测\n\n\n\n#### 连接假死\n\n原因\n\n* 网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。\n* 公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着\n* 应用程序线程阻塞，无法进行数据读写\n\n问题\n\n* 假死的连接占用的资源不能自动释放\n* 向假死的连接发送数据，得到的反馈是发送超时\n\n服务器端解决\n\n* 怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了读空闲事件\n        if (event.state() == IdleState.READER_IDLE) {\n            log.debug(\"已经 5s 没有读到数据了\");\n            ctx.channel().close();\n        }\n    }\n});\n```\n\n\n\n客户端定时心跳\n\n* 客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器\n\n```java\n// 用来判断是不是 读空闲时间过长，或 写空闲时间过长\n// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n// ChannelDuplexHandler 可以同时作为入站和出站处理器\nch.pipeline().addLast(new ChannelDuplexHandler() {\n    // 用来触发特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{\n        IdleStateEvent event = (IdleStateEvent) evt;\n        // 触发了写空闲事件\n        if (event.state() == IdleState.WRITER_IDLE) {\n            //                                log.debug(\"3s 没有写数据了，发送一个心跳包\");\n            ctx.writeAndFlush(new PingMessage());\n        }\n    }\n});\n```\n\n\n\n\n\n\n","slug":"Netty03-进阶","published":1,"updated":"2023-05-06T13:27:59.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clhc0tpoz0004d8we0ltfd7w9","content":"<p>该笔记是B站黑马的Netty视频的配套笔记3。</p>\n<span id=\"more\"></span>\n<h1 id=\"三-Netty-进阶\"><a href=\"#三-Netty-进阶\" class=\"headerlink\" title=\"三. Netty 进阶\"></a>三. Netty 进阶</h1><h2 id=\"1-粘包与半包\"><a href=\"#1-粘包与半包\" class=\"headerlink\" title=\"1. 粘包与半包\"></a>1. 粘包与半包</h2><h3 id=\"1-1-粘包现象\"><a href=\"#1-1-粘包现象\" class=\"headerlink\" title=\"1.1 粘包现象\"></a>1.1 粘包现象</h3><p>服务端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelActive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelInactive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            channelFuture.sync();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;stoped&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">HelloWorldServer</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                                buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">                                ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class=\"line\">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-2-半包现象\"><a href=\"#1-2-半包现象\" class=\"headerlink\" title=\"1.2 半包现象\"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class=\"line\">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000010| 00 01 02 03                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong></p>\n<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>\n</blockquote>\n<h3 id=\"1-3-现象分析\"><a href=\"#1-3-现象分析\" class=\"headerlink\" title=\"1.3 现象分析\"></a>1.3 现象分析</h3><p>粘包</p>\n<ul>\n<li>现象，发送 abc def，接收 abcdef</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>\n<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>\n<li>Nagle 算法：会造成粘包</li>\n</ul>\n</li>\n</ul>\n<p>半包</p>\n<ul>\n<li>现象，发送 abcdef，接收 abc def</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>\n<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>\n<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>\n</ul>\n</li>\n</ul>\n<p>本质是因为 TCP 是流式协议，消息无边界</p>\n<blockquote>\n<p>滑动窗口</p>\n<ul>\n<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>\n<p><img src=\"/img/0049.png\"></p>\n</li>\n<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>\n<p><img src=\"/img/0051.png\"></p>\n</li>\n<li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p>\n<ul>\n<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>\n<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>\n<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>\n<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> MSS 限制</p>\n<ul>\n<li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>\n</li>\n<li><p>以太网的 MTU 是 1500</p>\n</li>\n<li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p>\n</li>\n<li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p>\n</li>\n<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>\n</li>\n<li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</p>\n</li>\n<li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p>\n</li>\n<li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p>\n</li>\n</ul>\n  <img src=\"img/0031.jpg\" style=\"zoom:50%;\" />\n</blockquote>\n<blockquote>\n<p>Nagle 算法</p>\n<ul>\n<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>\n<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>\n<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>\n<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>\n<li>如果 TCP_NODELAY &#x3D; true，则需要发送</li>\n<li>已发送的数据都收到 ack 时，则需要发送</li>\n<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>\n<li>除上述情况，延迟发送</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"1-4-解决方案\"><a href=\"#1-4-解决方案\" class=\"headerlink\" title=\"1.4 解决方案\"></a>1.4 解决方案</h3><ol>\n<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>\n<li>每一条消息采用固定长度，缺点浪费空间</li>\n<li>每一条消息采用分隔符，例如 \\n，缺点需要转义</li>\n<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>\n</ol>\n<h4 id=\"方法1，短链接\"><a href=\"#方法1，短链接\" class=\"headerlink\" title=\"方法1，短链接\"></a>方法1，短链接</h4><p>以解决粘包为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分 10 次发送</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            send();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;conneted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                            <span class=\"comment\">// 发完即关</span></span><br><span class=\"line\">                            ctx.close();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出，略</p>\n<blockquote>\n<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>\n</blockquote>\n<h4 id=\"方法2，固定长度\"><a href=\"#方法2，固定长度\" class=\"headerlink\" title=\"方法2，固定长度\"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">FixedLengthFrameDecoder</span>(<span class=\"number\">8</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"comment\">// 发送内容随机的数据包</span></span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>];</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; r.nextInt(<span class=\"number\">8</span>); j++) &#123;</span><br><span class=\"line\">                                    bytes[j] = (<span class=\"type\">byte</span>) c;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                                buffer.writeBytes(bytes);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class=\"line\">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class=\"line\">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class=\"line\">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class=\"line\">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class=\"line\">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<p>缺点是，数据包的大小不好把握</p>\n<ul>\n<li>长度定的太大，浪费</li>\n<li>长度定的太小，对某些数据包又显得不够</li>\n</ul>\n<h4 id=\"方法3，固定分隔符\"><a href=\"#方法3，固定分隔符\" class=\"headerlink\" title=\"方法3，固定分隔符\"></a>方法3，固定分隔符</h4><p>服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LineBasedFrameDecoder</span>(<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端在每条消息之后，加入 \\n 分隔符</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= r.nextInt(<span class=\"number\">16</span>)+<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                                    buffer.writeByte((<span class=\"type\">byte</span>) c);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                buffer.writeByte(<span class=\"number\">10</span>);</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class=\"line\">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class=\"line\">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class=\"line\">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61                                              |a               |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 62 62                                        |bbb             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 63                                        |ccc             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 64                                           |dd              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66                                           |ff              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>\n<h4 id=\"方法4，预设长度\"><a href=\"#方法4，预设长度\" class=\"headerlink\" title=\"方法4，预设长度\"></a>方法4，预设长度</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(<span class=\"number\">1024</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">byte</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (r.nextInt(<span class=\"number\">16</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                <span class=\"comment\">// 先写入长度</span></span><br><span class=\"line\">                                buffer.writeByte(length);</span><br><span class=\"line\">                                <span class=\"comment\">// 再</span></span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= length; j++) &#123;</span><br><span class=\"line\">                                    buffer.writeByte((<span class=\"type\">byte</span>) c);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class=\"line\">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class=\"line\">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class=\"line\">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class=\"line\">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class=\"line\">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class=\"line\">|00000060| 6a                                              |j               |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class=\"line\">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67                                           |gg              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 68                                           |hh              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-协议设计与解析\"><a href=\"#2-协议设计与解析\" class=\"headerlink\" title=\"2. 协议设计与解析\"></a>2. 协议设计与解析</h2><h3 id=\"2-1-为什么需要协议？\"><a href=\"#2-1-为什么需要协议？\" class=\"headerlink\" title=\"2.1 为什么需要协议？\"></a>2.1 为什么需要协议？</h3><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界。</p>\n<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>\n<p>例如：在网络上传输</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天留客天留我不留</span><br></pre></td></tr></table></figure>\n\n<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>\n<p>一种解读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天留客，天留，我不留</span><br></pre></td></tr></table></figure>\n\n<p>另一种解读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天，留客天，留我不？留</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>\n\n<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0f下雨天留客06天留09我不留</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>小故事</p>\n<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>\n<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p>\n<p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p>\n<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>\n<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p>\n</blockquote>\n<h3 id=\"2-2-redis-协议举例\"><a href=\"#2-2-redis-协议举例\" class=\"headerlink\" title=\"2.2 redis 协议举例\"></a>2.2 redis 协议举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">byte</span>[] LINE = &#123;<span class=\"number\">13</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">    bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">    bootstrap.group(worker);</span><br><span class=\"line\">    bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    set(ctx);</span><br><span class=\"line\">                    get(ctx);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">get</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;*2&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;get&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;aaa&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    ctx.writeAndFlush(buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;*3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;set&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;aaa&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;bbb&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    ctx.writeAndFlush(buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">6379</span>).sync();</span><br><span class=\"line\">    channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    worker.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-http-协议举例\"><a href=\"#2-3-http-协议举例\" class=\"headerlink\" title=\"2.3 http 协议举例\"></a>2.3 http 协议举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">    serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">    serverBootstrap.group(boss, worker);</span><br><span class=\"line\">    serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">HttpServerCodec</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取请求</span></span><br><span class=\"line\">                    log.debug(msg.uri());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回响应</span></span><br><span class=\"line\">                    <span class=\"type\">DefaultFullHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"type\">byte</span>[] bytes = <span class=\"string\">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">                    response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class=\"line\">                    response.content().writeBytes(bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 写回响应</span></span><br><span class=\"line\">                    ctx.writeAndFlush(response);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"comment\">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                @Override</span></span><br><span class=\"line\"><span class=\"comment\">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;);*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">    channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    boss.shutdownGracefully();</span><br><span class=\"line\">    worker.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-自定义协议要素\"><a href=\"#2-4-自定义协议要素\" class=\"headerlink\" title=\"2.4 自定义协议要素\"></a>2.4 自定义协议要素</h3><ul>\n<li>魔数，用来在第一时间判定是否是无效数据包</li>\n<li>版本号，可以支持协议的升级</li>\n<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>\n<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>\n<li>请求序号，为了双工通信，提供异步能力</li>\n<li>正文长度</li>\n<li>消息正文</li>\n</ul>\n<h4 id=\"编解码器\"><a href=\"#编解码器\" class=\"headerlink\" title=\"编解码器\"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodec</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bos);</span><br><span class=\"line\">        oos.writeObject(msg);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) ois.readObject();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EmbeddedChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EmbeddedChannel</span>(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(</span><br><span class=\"line\">        <span class=\"number\">1024</span>, <span class=\"number\">12</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodec</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\"><span class=\"type\">LoginRequestMessage</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginRequestMessage</span>(<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        channel.writeOutbound(message);</span></span><br><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodec</span>().encode(<span class=\"literal\">null</span>, message, buf);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> buf.slice(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> buf.slice(<span class=\"number\">100</span>, buf.readableBytes() - <span class=\"number\">100</span>);</span><br><span class=\"line\">s1.retain(); <span class=\"comment\">// 引用计数 2</span></span><br><span class=\"line\">channel.writeInbound(s1); <span class=\"comment\">// release 1</span></span><br><span class=\"line\">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解读</p>\n<p><img src=\"/img/0013.png\"></p>\n<h4 id=\"💡-什么时候可以加-Sharable\"><a href=\"#💡-什么时候可以加-Sharable\" class=\"headerlink\" title=\"💡 什么时候可以加 @Sharable\"></a>💡 什么时候可以加 @Sharable</h4><ul>\n<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>\n<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>\n<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodecSharable</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bos);</span><br><span class=\"line\">        oos.writeObject(msg);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">        outList.add(out);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) ois.readObject();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-聊天室案例\"><a href=\"#3-聊天室案例\" class=\"headerlink\" title=\"3. 聊天室案例\"></a>3. 聊天室案例</h2><h3 id=\"3-1-聊天室业务介绍\"><a href=\"#3-1-聊天室业务介绍\" class=\"headerlink\" title=\"3.1 聊天室业务介绍\"></a>3.1 聊天室业务介绍</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用户管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 登录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> password 密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 会话管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 会话绑定用户</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">(Channel channel, String username)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unbind</span><span class=\"params\">(Channel channel)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取属性</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getAttribute</span><span class=\"params\">(Channel channel, String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置属性</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setAttribute</span><span class=\"params\">(Channel channel, String name, Object value)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据用户名获取 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> channel</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Channel <span class=\"title function_\">getChannel</span><span class=\"params\">(String username)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 聊天组会话管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupSession</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> members 成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">createGroup</span><span class=\"params\">(String name, Set&lt;String&gt; members)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加入聊天组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> member 成员名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">joinMember</span><span class=\"params\">(String name, String member)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除组成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> member 成员名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">removeMember</span><span class=\"params\">(String name, String member)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除聊天组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">removeGroup</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取组成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Set&lt;String&gt; <span class=\"title function_\">getMembers</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成员 channel 集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    List&lt;Channel&gt; <span class=\"title function_\">getMembersChannel</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-聊天室业务-登录\"><a href=\"#3-2-聊天室业务-登录\" class=\"headerlink\" title=\"3.2 聊天室业务-登录\"></a>3.2 聊天室业务-登录</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> msg.getUsername();</span><br><span class=\"line\">                            <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> msg.getPassword();</span><br><span class=\"line\">                            <span class=\"type\">boolean</span> <span class=\"variable\">login</span> <span class=\"operator\">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class=\"line\">                            LoginResponseMessage message;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(login) &#123;</span><br><span class=\"line\">                                message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;登录成功&quot;</span>);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;用户名或密码不正确&quot;</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(message);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">CountDownLatch</span> <span class=\"variable\">WAIT_FOR_LOGIN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">AtomicBoolean</span> <span class=\"variable\">LOGIN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicBoolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\"><span class=\"comment\">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"string\">&quot;client handler&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 接收响应消息</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((msg <span class=\"keyword\">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class=\"line\">                                <span class=\"type\">LoginResponseMessage</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> (LoginResponseMessage) msg;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (response.isSuccess()) &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// 如果登录成功</span></span><br><span class=\"line\">                                    LOGIN.set(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 唤醒 system in 线程</span></span><br><span class=\"line\">                                WAIT_FOR_LOGIN.countDown();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 在连接建立后触发 active 事件</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                                <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;请输入用户名:&quot;</span>);</span><br><span class=\"line\">                                <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;请输入密码:&quot;</span>);</span><br><span class=\"line\">                                <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                <span class=\"comment\">// 构造消息对象</span></span><br><span class=\"line\">                                <span class=\"type\">LoginRequestMessage</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginRequestMessage</span>(username, password);</span><br><span class=\"line\">                                <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">                                ctx.writeAndFlush(message);</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;等待后续操作...&quot;</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                    WAIT_FOR_LOGIN.await();</span><br><span class=\"line\">                                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                                    e.printStackTrace();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 如果登录失败</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!LOGIN.get()) &#123;</span><br><span class=\"line\">                                    ctx.channel().close();</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;==================================&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;send [username] [content]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gmembers [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gjoin [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gquit [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;quit&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;==================================&quot;</span>);</span><br><span class=\"line\">                                    <span class=\"type\">String</span> <span class=\"variable\">command</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                    String[] s = command.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">                                    <span class=\"keyword\">switch</span> (s[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;send&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatRequestMessage</span>(username, s[<span class=\"number\">1</span>], s[<span class=\"number\">2</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gsend&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupChatRequestMessage</span>(username, s[<span class=\"number\">1</span>], s[<span class=\"number\">2</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gcreate&quot;</span>:</span><br><span class=\"line\">                                            Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class=\"number\">2</span>].split(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">                                            set.add(username); <span class=\"comment\">// 加入自己</span></span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateRequestMessage</span>(s[<span class=\"number\">1</span>], set));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gmembers&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupMembersRequestMessage</span>(s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gjoin&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinRequestMessage</span>(username, s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gquit&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupQuitRequestMessage</span>(username, s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;quit&quot;</span>:</span><br><span class=\"line\">                                            ctx.channel().close();</span><br><span class=\"line\">                                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;, <span class=\"string\">&quot;system in&quot;</span>).start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-聊天室业务-单聊\"><a href=\"#3-3-聊天室业务-单聊\" class=\"headerlink\" title=\"3.3 聊天室业务-单聊\"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p>\n<p>登录 handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> msg.getUsername();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> msg.getPassword();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">login</span> <span class=\"operator\">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class=\"line\">        LoginResponseMessage message;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(login) &#123;</span><br><span class=\"line\">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class=\"line\">            message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;登录成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;用户名或密码不正确&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.writeAndFlush(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单聊 handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> msg.getTo();</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> SessionFactory.getSession().getChannel(to);</span><br><span class=\"line\">        <span class=\"comment\">// 在线</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(channel != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不在线</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-聊天室业务-群聊\"><a href=\"#3-4-聊天室业务-群聊\" class=\"headerlink\" title=\"3.4 聊天室业务-群聊\"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupCreateRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">groupName</span> <span class=\"operator\">=</span> msg.getGroupName();</span><br><span class=\"line\">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class=\"line\">        <span class=\"comment\">// 群管理器</span></span><br><span class=\"line\">        <span class=\"type\">GroupSession</span> <span class=\"variable\">groupSession</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession();</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> groupSession.createGroup(groupName, members);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生成功消息</span></span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">true</span>, groupName + <span class=\"string\">&quot;创建成功&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">// 发送拉群消息</span></span><br><span class=\"line\">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">false</span>, groupName + <span class=\"string\">&quot;已经存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupChatRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class=\"line\">                .getMembersChannel(msg.getGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupJoinRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群加入成功&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群不存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>退出群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupQuitRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群不存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看成员</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupMembersRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class=\"line\">                .getMembers(msg.getGroupName());</span><br><span class=\"line\">        ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupMembersResponseMessage</span>(members));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-5-聊天室业务-退出\"><a href=\"#3-5-聊天室业务-退出\" class=\"headerlink\" title=\"3.5 聊天室业务-退出\"></a>3.5 聊天室业务-退出</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Slf4j</span><br><span class=\"line\">@ChannelHandler.Sharable</span><br><span class=\"line\">public class QuitHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当连接断开时触发 inactive 事件</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class=\"line\">        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 当出现异常时触发</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class=\"line\">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class=\"line\">        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-6-聊天室业务-空闲检测\"><a href=\"#3-6-聊天室业务-空闲检测\" class=\"headerlink\" title=\"3.6 聊天室业务-空闲检测\"></a>3.6 聊天室业务-空闲检测</h3><h4 id=\"连接假死\"><a href=\"#连接假死\" class=\"headerlink\" title=\"连接假死\"></a>连接假死</h4><p>原因</p>\n<ul>\n<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>\n<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>\n<li>应用程序线程阻塞，无法进行数据读写</li>\n</ul>\n<p>问题</p>\n<ul>\n<li>假死的连接占用的资源不能自动释放</li>\n<li>向假死的连接发送数据，得到的反馈是发送超时</li>\n</ul>\n<p>服务器端解决</p>\n<ul>\n<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class=\"line\"><span class=\"comment\">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来触发特殊事件</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;</span><br><span class=\"line\">        <span class=\"comment\">// 触发了读空闲事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class=\"line\">            ctx.channel().close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>客户端定时心跳</p>\n<ul>\n<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class=\"line\"><span class=\"comment\">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来触发特殊事件</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;</span><br><span class=\"line\">        <span class=\"comment\">// 触发了写空闲事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">PingMessage</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>该笔记是B站黑马的Netty视频的配套笔记3。</p>","more":"<h1 id=\"三-Netty-进阶\"><a href=\"#三-Netty-进阶\" class=\"headerlink\" title=\"三. Netty 进阶\"></a>三. Netty 进阶</h1><h2 id=\"1-粘包与半包\"><a href=\"#1-粘包与半包\" class=\"headerlink\" title=\"1. 粘包与半包\"></a>1. 粘包与半包</h2><h3 id=\"1-1-粘包现象\"><a href=\"#1-1-粘包现象\" class=\"headerlink\" title=\"1.1 粘包现象\"></a>1.1 粘包现象</h3><p>服务端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">start</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelActive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelInactive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class=\"line\">                            <span class=\"built_in\">super</span>.channelInactive(ctx);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>);</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            channelFuture.sync();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;stoped&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">HelloWorldServer</span>().start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                                buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">                                ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class=\"line\">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"1-2-半包现象\"><a href=\"#1-2-半包现象\" class=\"headerlink\" title=\"1.2 半包现象\"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>\n\n<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n\n<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class=\"line\">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class=\"line\">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class=\"line\">|00000010| 00 01 02 03                                     |....            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class=\"line\">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong></p>\n<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>\n</blockquote>\n<h3 id=\"1-3-现象分析\"><a href=\"#1-3-现象分析\" class=\"headerlink\" title=\"1.3 现象分析\"></a>1.3 现象分析</h3><p>粘包</p>\n<ul>\n<li>现象，发送 abc def，接收 abcdef</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>\n<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>\n<li>Nagle 算法：会造成粘包</li>\n</ul>\n</li>\n</ul>\n<p>半包</p>\n<ul>\n<li>现象，发送 abcdef，接收 abc def</li>\n<li>原因<ul>\n<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>\n<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>\n<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>\n</ul>\n</li>\n</ul>\n<p>本质是因为 TCP 是流式协议，消息无边界</p>\n<blockquote>\n<p>滑动窗口</p>\n<ul>\n<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>\n<p><img src=\"/img/0049.png\"></p>\n</li>\n<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>\n<p><img src=\"/img/0051.png\"></p>\n</li>\n<li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p>\n<ul>\n<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>\n<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>\n<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>\n<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> MSS 限制</p>\n<ul>\n<li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>\n</li>\n<li><p>以太网的 MTU 是 1500</p>\n</li>\n<li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p>\n</li>\n<li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p>\n</li>\n<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>\n</li>\n<li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</p>\n</li>\n<li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p>\n</li>\n<li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p>\n</li>\n</ul>\n  <img src=\"img/0031.jpg\" style=\"zoom:50%;\" />\n</blockquote>\n<blockquote>\n<p>Nagle 算法</p>\n<ul>\n<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>\n<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>\n<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>\n<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>\n<li>如果 TCP_NODELAY &#x3D; true，则需要发送</li>\n<li>已发送的数据都收到 ack 时，则需要发送</li>\n<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>\n<li>除上述情况，延迟发送</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"1-4-解决方案\"><a href=\"#1-4-解决方案\" class=\"headerlink\" title=\"1.4 解决方案\"></a>1.4 解决方案</h3><ol>\n<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>\n<li>每一条消息采用固定长度，缺点浪费空间</li>\n<li>每一条消息采用分隔符，例如 \\n，缺点需要转义</li>\n<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>\n</ol>\n<h4 id=\"方法1，短链接\"><a href=\"#方法1，短链接\" class=\"headerlink\" title=\"方法1，短链接\"></a>方法1，短链接</h4><p>以解决粘包为例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分 10 次发送</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            send();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;conneted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            buffer.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>, <span class=\"number\">14</span>, <span class=\"number\">15</span>&#125;);</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                            <span class=\"comment\">// 发完即关</span></span><br><span class=\"line\">                            ctx.close();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出，略</p>\n<blockquote>\n<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>\n</blockquote>\n<h4 id=\"方法2，固定长度\"><a href=\"#方法2，固定长度\" class=\"headerlink\" title=\"方法2，固定长度\"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">FixedLengthFrameDecoder</span>(<span class=\"number\">8</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"comment\">// 发送内容随机的数据包</span></span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>];</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; r.nextInt(<span class=\"number\">8</span>); j++) &#123;</span><br><span class=\"line\">                                    bytes[j] = (<span class=\"type\">byte</span>) c;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                                buffer.writeBytes(bytes);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class=\"line\">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class=\"line\">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class=\"line\">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class=\"line\">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class=\"line\">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<p>缺点是，数据包的大小不好把握</p>\n<ul>\n<li>长度定的太大，浪费</li>\n<li>长度定的太小，对某些数据包又显得不够</li>\n</ul>\n<h4 id=\"方法3，固定分隔符\"><a href=\"#方法3，固定分隔符\" class=\"headerlink\" title=\"方法3，固定分隔符\"></a>方法3，固定分隔符</h4><p>服务端加入，默认以 \\n 或 \\r\\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LineBasedFrameDecoder</span>(<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端在每条消息之后，加入 \\n 分隔符</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= r.nextInt(<span class=\"number\">16</span>)+<span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                                    buffer.writeByte((<span class=\"type\">byte</span>) c);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                buffer.writeByte(<span class=\"number\">10</span>);</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class=\"line\">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class=\"line\">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class=\"line\">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61                                              |a               |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 62 62                                        |bbb             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 63                                        |ccc             |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 64                                           |dd              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66                                           |ff              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>\n\n<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>\n<h4 id=\"方法4，预设长度\"><a href=\"#方法4，预设长度\" class=\"headerlink\" title=\"方法4，预设长度\"></a>方法4，预设长度</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(<span class=\"number\">1024</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HelloWorldClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Logger</span> <span class=\"variable\">log</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(worker);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    log.debug(<span class=\"string\">&quot;connetted...&quot;</span>);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;sending...&quot;</span>);</span><br><span class=\"line\">                            <span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">                            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">                            <span class=\"type\">ByteBuf</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                                <span class=\"type\">byte</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> (<span class=\"type\">byte</span>) (r.nextInt(<span class=\"number\">16</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                <span class=\"comment\">// 先写入长度</span></span><br><span class=\"line\">                                buffer.writeByte(length);</span><br><span class=\"line\">                                <span class=\"comment\">// 再</span></span><br><span class=\"line\">                                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= length; j++) &#123;</span><br><span class=\"line\">                                    buffer.writeByte((<span class=\"type\">byte</span>) c);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                c++;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(buffer);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;192.168.0.103&quot;</span>, <span class=\"number\">9090</span>).sync();</span><br><span class=\"line\">            channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>客户端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class=\"line\">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class=\"line\">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class=\"line\">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class=\"line\">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class=\"line\">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class=\"line\">|00000060| 6a                                              |j               |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>\n\n\n\n<p>服务端输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class=\"line\">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 67 67                                           |gg              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 68 68                                           |hh              |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class=\"line\">         +-------------------------------------------------+</span><br><span class=\"line\">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class=\"line\">+--------+-------------------------------------------------+----------------+</span><br><span class=\"line\">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-协议设计与解析\"><a href=\"#2-协议设计与解析\" class=\"headerlink\" title=\"2. 协议设计与解析\"></a>2. 协议设计与解析</h2><h3 id=\"2-1-为什么需要协议？\"><a href=\"#2-1-为什么需要协议？\" class=\"headerlink\" title=\"2.1 为什么需要协议？\"></a>2.1 为什么需要协议？</h3><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界。</p>\n<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>\n<p>例如：在网络上传输</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天留客天留我不留</span><br></pre></td></tr></table></figure>\n\n<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>\n<p>一种解读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天留客，天留，我不留</span><br></pre></td></tr></table></figure>\n\n<p>另一种解读</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">下雨天，留客天，留我不？留</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>\n\n<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0f下雨天留客06天留09我不留</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>小故事</p>\n<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>\n<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p>\n<p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p>\n<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>\n<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p>\n</blockquote>\n<h3 id=\"2-2-redis-协议举例\"><a href=\"#2-2-redis-协议举例\" class=\"headerlink\" title=\"2.2 redis 协议举例\"></a>2.2 redis 协议举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">byte</span>[] LINE = &#123;<span class=\"number\">13</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">    bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">    bootstrap.group(worker);</span><br><span class=\"line\">    bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    set(ctx);</span><br><span class=\"line\">                    get(ctx);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">get</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;*2&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;get&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;aaa&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    ctx.writeAndFlush(buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;*3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;set&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;aaa&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;$3&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    buf.writeBytes(<span class=\"string\">&quot;bbb&quot;</span>.getBytes());</span><br><span class=\"line\">                    buf.writeBytes(LINE);</span><br><span class=\"line\">                    ctx.writeAndFlush(buf);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> (ByteBuf) msg;</span><br><span class=\"line\">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">6379</span>).sync();</span><br><span class=\"line\">    channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    worker.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-3-http-协议举例\"><a href=\"#2-3-http-协议举例\" class=\"headerlink\" title=\"2.3 http 协议举例\"></a>2.3 http 协议举例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">    serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">    serverBootstrap.group(boss, worker);</span><br><span class=\"line\">    serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">HttpServerCodec</span>());</span><br><span class=\"line\">            ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 获取请求</span></span><br><span class=\"line\">                    log.debug(msg.uri());</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 返回响应</span></span><br><span class=\"line\">                    <span class=\"type\">DefaultFullHttpResponse</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span></span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"type\">byte</span>[] bytes = <span class=\"string\">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">                    response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class=\"line\">                    response.content().writeBytes(bytes);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 写回响应</span></span><br><span class=\"line\">                    ctx.writeAndFlush(response);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"comment\">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                @Override</span></span><br><span class=\"line\"><span class=\"comment\">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">                    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;);*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"type\">ChannelFuture</span> <span class=\"variable\">channelFuture</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync();</span><br><span class=\"line\">    channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">    log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    boss.shutdownGracefully();</span><br><span class=\"line\">    worker.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-4-自定义协议要素\"><a href=\"#2-4-自定义协议要素\" class=\"headerlink\" title=\"2.4 自定义协议要素\"></a>2.4 自定义协议要素</h3><ul>\n<li>魔数，用来在第一时间判定是否是无效数据包</li>\n<li>版本号，可以支持协议的升级</li>\n<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>\n<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>\n<li>请求序号，为了双工通信，提供异步能力</li>\n<li>正文长度</li>\n<li>消息正文</li>\n</ul>\n<h4 id=\"编解码器\"><a href=\"#编解码器\" class=\"headerlink\" title=\"编解码器\"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodec</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bos);</span><br><span class=\"line\">        oos.writeObject(msg);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) ois.readObject();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">EmbeddedChannel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">EmbeddedChannel</span>(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">LengthFieldBasedFrameDecoder</span>(</span><br><span class=\"line\">        <span class=\"number\">1024</span>, <span class=\"number\">12</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodec</span>()</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// encode</span></span><br><span class=\"line\"><span class=\"type\">LoginRequestMessage</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginRequestMessage</span>(<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//        channel.writeOutbound(message);</span></span><br><span class=\"line\"><span class=\"comment\">// decode</span></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodec</span>().encode(<span class=\"literal\">null</span>, message, buf);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">s1</span> <span class=\"operator\">=</span> buf.slice(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"type\">ByteBuf</span> <span class=\"variable\">s2</span> <span class=\"operator\">=</span> buf.slice(<span class=\"number\">100</span>, buf.readableBytes() - <span class=\"number\">100</span>);</span><br><span class=\"line\">s1.retain(); <span class=\"comment\">// 引用计数 2</span></span><br><span class=\"line\">channel.writeInbound(s1); <span class=\"comment\">// release 1</span></span><br><span class=\"line\">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>解读</p>\n<p><img src=\"/img/0013.png\"></p>\n<h4 id=\"💡-什么时候可以加-Sharable\"><a href=\"#💡-什么时候可以加-Sharable\" class=\"headerlink\" title=\"💡 什么时候可以加 @Sharable\"></a>💡 什么时候可以加 @Sharable</h4><ul>\n<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>\n<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>\n<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MessageCodecSharable</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">encode</span><span class=\"params\">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">ByteBuf</span> <span class=\"variable\">out</span> <span class=\"operator\">=</span> ctx.alloc().buffer();</span><br><span class=\"line\">        <span class=\"comment\">// 1. 4 字节的魔数</span></span><br><span class=\"line\">        out.writeBytes(<span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 1 字节的版本,</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4. 1 字节的指令类型</span></span><br><span class=\"line\">        out.writeByte(msg.getMessageType());</span><br><span class=\"line\">        <span class=\"comment\">// 5. 4 个字节</span></span><br><span class=\"line\">        out.writeInt(msg.getSequenceId());</span><br><span class=\"line\">        <span class=\"comment\">// 无意义，对齐填充</span></span><br><span class=\"line\">        out.writeByte(<span class=\"number\">0xff</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 6. 获取内容的字节数组</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(bos);</span><br><span class=\"line\">        oos.writeObject(msg);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = bos.toByteArray();</span><br><span class=\"line\">        <span class=\"comment\">// 7. 长度</span></span><br><span class=\"line\">        out.writeInt(bytes.length);</span><br><span class=\"line\">        <span class=\"comment\">// 8. 写入内容</span></span><br><span class=\"line\">        out.writeBytes(bytes);</span><br><span class=\"line\">        outList.add(out);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">decode</span><span class=\"params\">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">magicNum</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">version</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">serializerType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">byte</span> <span class=\"variable\">messageType</span> <span class=\"operator\">=</span> in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sequenceId</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        in.readByte();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> in.readInt();</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[length];</span><br><span class=\"line\">        in.readBytes(bytes, <span class=\"number\">0</span>, length);</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(bytes));</span><br><span class=\"line\">        <span class=\"type\">Message</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> (Message) ois.readObject();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class=\"line\">        out.add(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-聊天室案例\"><a href=\"#3-聊天室案例\" class=\"headerlink\" title=\"3. 聊天室案例\"></a>3. 聊天室案例</h2><h3 id=\"3-1-聊天室业务介绍\"><a href=\"#3-1-聊天室业务介绍\" class=\"headerlink\" title=\"3.1 聊天室业务介绍\"></a>3.1 聊天室业务介绍</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 用户管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 登录</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> password 密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">login</span><span class=\"params\">(String username, String password)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 会话管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Session</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 会话绑定用户</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">bind</span><span class=\"params\">(Channel channel, String username)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 解绑会话</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unbind</span><span class=\"params\">(Channel channel)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取属性</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getAttribute</span><span class=\"params\">(Channel channel, String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 设置属性</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> channel 哪个 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 属性名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 属性值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">setAttribute</span><span class=\"params\">(Channel channel, String name, Object value)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据用户名获取 channel</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> channel</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Channel <span class=\"title function_\">getChannel</span><span class=\"params\">(String username)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 聊天组会话管理接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupSession</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> members 成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">createGroup</span><span class=\"params\">(String name, Set&lt;String&gt; members)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加入聊天组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> member 成员名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">joinMember</span><span class=\"params\">(String name, String member)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除组成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> member 成员名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">removeMember</span><span class=\"params\">(String name, String member)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除聊天组</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Group <span class=\"title function_\">removeGroup</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取组成员</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Set&lt;String&gt; <span class=\"title function_\">getMembers</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> name 组名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成员 channel 集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    List&lt;Channel&gt; <span class=\"title function_\">getMembersChannel</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-2-聊天室业务-登录\"><a href=\"#3-2-聊天室业务-登录\" class=\"headerlink\" title=\"3.2 聊天室业务-登录\"></a>3.2 聊天室业务-登录</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatServer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">boss</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">worker</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ServerBootstrap</span> <span class=\"variable\">serverBootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ServerBootstrap</span>();</span><br><span class=\"line\">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class=\"line\">            serverBootstrap.group(boss, worker);</span><br><span class=\"line\">            serverBootstrap.childHandler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> msg.getUsername();</span><br><span class=\"line\">                            <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> msg.getPassword();</span><br><span class=\"line\">                            <span class=\"type\">boolean</span> <span class=\"variable\">login</span> <span class=\"operator\">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class=\"line\">                            LoginResponseMessage message;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(login) &#123;</span><br><span class=\"line\">                                message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;登录成功&quot;</span>);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;用户名或密码不正确&quot;</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            ctx.writeAndFlush(message);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> serverBootstrap.bind(<span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;server error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            boss.shutdownGracefully();</span><br><span class=\"line\">            worker.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NioEventLoopGroup</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NioEventLoopGroup</span>();</span><br><span class=\"line\">        <span class=\"type\">LoggingHandler</span> <span class=\"variable\">LOGGING_HANDLER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class=\"line\">        <span class=\"type\">MessageCodecSharable</span> <span class=\"variable\">MESSAGE_CODEC</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageCodecSharable</span>();</span><br><span class=\"line\">        <span class=\"type\">CountDownLatch</span> <span class=\"variable\">WAIT_FOR_LOGIN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">AtomicBoolean</span> <span class=\"variable\">LOGIN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicBoolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Bootstrap</span> <span class=\"variable\">bootstrap</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Bootstrap</span>();</span><br><span class=\"line\">            bootstrap.channel(NioSocketChannel.class);</span><br><span class=\"line\">            bootstrap.group(group);</span><br><span class=\"line\">            bootstrap.handler(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ProcotolFrameDecoder</span>());</span><br><span class=\"line\"><span class=\"comment\">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class=\"line\">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class=\"line\">                    ch.pipeline().addLast(<span class=\"string\">&quot;client handler&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 接收响应消息</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            log.debug(<span class=\"string\">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((msg <span class=\"keyword\">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class=\"line\">                                <span class=\"type\">LoginResponseMessage</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> (LoginResponseMessage) msg;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (response.isSuccess()) &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// 如果登录成功</span></span><br><span class=\"line\">                                    LOGIN.set(<span class=\"literal\">true</span>);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 唤醒 system in 线程</span></span><br><span class=\"line\">                                WAIT_FOR_LOGIN.countDown();</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">// 在连接建立后触发 active 事件</span></span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelActive</span><span class=\"params\">(ChannelHandlerContext ctx)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">                            <span class=\"comment\">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">                                <span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;请输入用户名:&quot;</span>);</span><br><span class=\"line\">                                <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;请输入密码:&quot;</span>);</span><br><span class=\"line\">                                <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                <span class=\"comment\">// 构造消息对象</span></span><br><span class=\"line\">                                <span class=\"type\">LoginRequestMessage</span> <span class=\"variable\">message</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LoginRequestMessage</span>(username, password);</span><br><span class=\"line\">                                <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">                                ctx.writeAndFlush(message);</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">&quot;等待后续操作...&quot;</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                                    WAIT_FOR_LOGIN.await();</span><br><span class=\"line\">                                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                                    e.printStackTrace();</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// 如果登录失败</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!LOGIN.get()) &#123;</span><br><span class=\"line\">                                    ctx.channel().close();</span><br><span class=\"line\">                                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;==================================&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;send [username] [content]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gmembers [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gjoin [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;gquit [group name]&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;quit&quot;</span>);</span><br><span class=\"line\">                                    System.out.println(<span class=\"string\">&quot;==================================&quot;</span>);</span><br><span class=\"line\">                                    <span class=\"type\">String</span> <span class=\"variable\">command</span> <span class=\"operator\">=</span> scanner.nextLine();</span><br><span class=\"line\">                                    String[] s = command.split(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">                                    <span class=\"keyword\">switch</span> (s[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;send&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatRequestMessage</span>(username, s[<span class=\"number\">1</span>], s[<span class=\"number\">2</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gsend&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupChatRequestMessage</span>(username, s[<span class=\"number\">1</span>], s[<span class=\"number\">2</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gcreate&quot;</span>:</span><br><span class=\"line\">                                            Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class=\"number\">2</span>].split(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">                                            set.add(username); <span class=\"comment\">// 加入自己</span></span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateRequestMessage</span>(s[<span class=\"number\">1</span>], set));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gmembers&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupMembersRequestMessage</span>(s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gjoin&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinRequestMessage</span>(username, s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;gquit&quot;</span>:</span><br><span class=\"line\">                                            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupQuitRequestMessage</span>(username, s[<span class=\"number\">1</span>]));</span><br><span class=\"line\">                                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                        <span class=\"keyword\">case</span> <span class=\"string\">&quot;quit&quot;</span>:</span><br><span class=\"line\">                                            ctx.channel().close();</span><br><span class=\"line\">                                            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;, <span class=\"string\">&quot;system in&quot;</span>).start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> bootstrap.connect(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>).sync().channel();</span><br><span class=\"line\">            channel.closeFuture().sync();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">&quot;client error&quot;</span>, e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            group.shutdownGracefully();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-3-聊天室业务-单聊\"><a href=\"#3-3-聊天室业务-单聊\" class=\"headerlink\" title=\"3.3 聊天室业务-单聊\"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p>\n<p>登录 handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">username</span> <span class=\"operator\">=</span> msg.getUsername();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> msg.getPassword();</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">login</span> <span class=\"operator\">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class=\"line\">        LoginResponseMessage message;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(login) &#123;</span><br><span class=\"line\">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class=\"line\">            message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;登录成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            message = <span class=\"keyword\">new</span> <span class=\"title class_\">LoginResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;用户名或密码不正确&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.writeAndFlush(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单聊 handler</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ChatRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">to</span> <span class=\"operator\">=</span> msg.getTo();</span><br><span class=\"line\">        <span class=\"type\">Channel</span> <span class=\"variable\">channel</span> <span class=\"operator\">=</span> SessionFactory.getSession().getChannel(to);</span><br><span class=\"line\">        <span class=\"comment\">// 在线</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(channel != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不在线</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">ChatResponseMessage</span>(<span class=\"literal\">false</span>, <span class=\"string\">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-4-聊天室业务-群聊\"><a href=\"#3-4-聊天室业务-群聊\" class=\"headerlink\" title=\"3.4 聊天室业务-群聊\"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupCreateRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">groupName</span> <span class=\"operator\">=</span> msg.getGroupName();</span><br><span class=\"line\">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class=\"line\">        <span class=\"comment\">// 群管理器</span></span><br><span class=\"line\">        <span class=\"type\">GroupSession</span> <span class=\"variable\">groupSession</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession();</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> groupSession.createGroup(groupName, members);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发生成功消息</span></span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">true</span>, groupName + <span class=\"string\">&quot;创建成功&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">// 发送拉群消息</span></span><br><span class=\"line\">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">                channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupCreateResponseMessage</span>(<span class=\"literal\">false</span>, groupName + <span class=\"string\">&quot;已经存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupChatRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class=\"line\">                .getMembersChannel(msg.getGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Channel channel : channels) &#123;</span><br><span class=\"line\">            channel.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加入群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupJoinRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群加入成功&quot;</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群不存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>退出群聊</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupQuitRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"type\">Group</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (group != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, <span class=\"string\">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupJoinResponseMessage</span>(<span class=\"literal\">true</span>, msg.getGroupName() + <span class=\"string\">&quot;群不存在&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看成员</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ChannelHandler</span>.Sharable</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GroupMembersRequestMessageHandler</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class=\"line\">                .getMembers(msg.getGroupName());</span><br><span class=\"line\">        ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">GroupMembersResponseMessage</span>(members));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-5-聊天室业务-退出\"><a href=\"#3-5-聊天室业务-退出\" class=\"headerlink\" title=\"3.5 聊天室业务-退出\"></a>3.5 聊天室业务-退出</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Slf4j</span><br><span class=\"line\">@ChannelHandler.Sharable</span><br><span class=\"line\">public class QuitHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 当连接断开时触发 inactive 事件</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class=\"line\">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class=\"line\">        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t// 当出现异常时触发</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class=\"line\">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class=\"line\">        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-6-聊天室业务-空闲检测\"><a href=\"#3-6-聊天室业务-空闲检测\" class=\"headerlink\" title=\"3.6 聊天室业务-空闲检测\"></a>3.6 聊天室业务-空闲检测</h3><h4 id=\"连接假死\"><a href=\"#连接假死\" class=\"headerlink\" title=\"连接假死\"></a>连接假死</h4><p>原因</p>\n<ul>\n<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>\n<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>\n<li>应用程序线程阻塞，无法进行数据读写</li>\n</ul>\n<p>问题</p>\n<ul>\n<li>假死的连接占用的资源不能自动释放</li>\n<li>向假死的连接发送数据，得到的反馈是发送超时</li>\n</ul>\n<p>服务器端解决</p>\n<ul>\n<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class=\"line\"><span class=\"comment\">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来触发特殊事件</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;</span><br><span class=\"line\">        <span class=\"comment\">// 触发了读空闲事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class=\"line\">            ctx.channel().close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>客户端定时心跳</p>\n<ul>\n<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class=\"line\"><span class=\"comment\">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">IdleStateHandler</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class=\"line\">ch.pipeline().addLast(<span class=\"keyword\">new</span> <span class=\"title class_\">ChannelDuplexHandler</span>() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用来触发特殊事件</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">userEventTriggered</span><span class=\"params\">(ChannelHandlerContext ctx, Object evt)</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"type\">IdleStateEvent</span> <span class=\"variable\">event</span> <span class=\"operator\">=</span> (IdleStateEvent) evt;</span><br><span class=\"line\">        <span class=\"comment\">// 触发了写空闲事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class=\"line\">            ctx.writeAndFlush(<span class=\"keyword\">new</span> <span class=\"title class_\">PingMessage</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/2023-05-05-hahaha/dog.jpg","slug":"dog.jpg","post":"clhasln9b0001mkwegm5jb6zz","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/1.png","slug":"1.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/4cb065a31ddd414e8c45a4a08754c823.jpg","slug":"4cb065a31ddd414e8c45a4a08754c823.jpg","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/75fad2d93da642fcb6006e7d538cba88.jpg","slug":"75fad2d93da642fcb6006e7d538cba88.jpg","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/a6179f036c6a428fa92a5a541482490c.jpg","slug":"a6179f036c6a428fa92a5a541482490c.jpg","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存击穿.png","slug":"缓存击穿.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存击穿方案.png","slug":"缓存击穿方案.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存穿透.png","slug":"缓存穿透.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/缓存雪崩.png","slug":"缓存雪崩.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0},{"_id":"source/_posts/2023-05-06-redis应用问题解决/雪崩失效.png","slug":"雪崩失效.png","post":"clhbvc46v00045swe64teb98l","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clhbvc46v00045swe64teb98l","category_id":"clhbvc46y000b5swec8c9avpe","_id":"clhbvc46z000i5swe28lp21rk"},{"post_id":"clhasln9h0003mkweeap8a1ci","category_id":"clhbvc46w00055swe2igy3696","_id":"clhbvc46z000m5sweghiw33au"},{"post_id":"clhasln9b0001mkwegm5jb6zz","category_id":"clhbvo2qh000r5swe8h826yri","_id":"clhbvo2qj000s5swe3wc9aixx"},{"post_id":"clhbvc46p00015swebt8903lv","category_id":"clhbvo2qh000r5swe8h826yri","_id":"clhbvod3h000t5swe2oypc098"},{"post_id":"clhasln9o0005mkwedbvy12jt","category_id":"clhbvc46w00055swe2igy3696","_id":"clhbvp9ks000u5swe59lxgaqn"},{"post_id":"clhc0tpoz0004d8we0ltfd7w9","category_id":"clhc0tpow0001d8we03td8on6","_id":"clhc0tpp10007d8wehkli2pmp"},{"post_id":"clhc0j23w0000r8wegitx18sn","category_id":"clhc0tpow0001d8we03td8on6","_id":"clhc0tpp2000ad8we7wq8dghk"},{"post_id":"clhc0tpou0000d8wef0w30lps","category_id":"clhc0tpow0001d8we03td8on6","_id":"clhc0tpp2000cd8wecznp84sk"},{"post_id":"clhc0tpoy0003d8we5kg68stk","category_id":"clhc0tpow0001d8we03td8on6","_id":"clhc0tpp3000gd8we8ppx5vgh"}],"PostTag":[{"post_id":"clhasln9b0001mkwegm5jb6zz","tag_id":"clhbvc46s00035swe4zm7dcfg","_id":"clhbvc46w00075swe7d5sh5k3"},{"post_id":"clhbvc46p00015swebt8903lv","tag_id":"clhbvc46w00065swe0kyp2h2c","_id":"clhbvc46x000a5swe4resck5j"},{"post_id":"clhasln9h0003mkweeap8a1ci","tag_id":"clhbvc46x00095sweajf9grv3","_id":"clhbvc46y000d5swehlrsc586"},{"post_id":"clhbvc46v00045swe64teb98l","tag_id":"clhbvc46y000c5swe86n9fql9","_id":"clhbvc46z000j5swe2inqhxl3"},{"post_id":"clhbvc46v00045swe64teb98l","tag_id":"clhbvc46z000g5swe6ykf3vhs","_id":"clhbvc46z000l5swegs51h50n"},{"post_id":"clhc0j23w0000r8wegitx18sn","tag_id":"clhc0tpoy0002d8we55p04lna","_id":"clhc0tpp2000bd8we9lpybtgs"},{"post_id":"clhc0j23w0000r8wegitx18sn","tag_id":"clhbvc46w00065swe0kyp2h2c","_id":"clhc0tpp2000dd8we5e371cuo"},{"post_id":"clhc0j23w0000r8wegitx18sn","tag_id":"clhc0tpp00006d8weabfuajyx","_id":"clhc0tpp3000fd8we29rs1k2r"},{"post_id":"clhc0tpou0000d8wef0w30lps","tag_id":"clhc0tpoy0002d8we55p04lna","_id":"clhc0tpp3000id8wegeiiejvj"},{"post_id":"clhc0tpou0000d8wef0w30lps","tag_id":"clhbvc46w00065swe0kyp2h2c","_id":"clhc0tpp3000jd8we96ep2peu"},{"post_id":"clhc0tpou0000d8wef0w30lps","tag_id":"clhc0tpp00006d8weabfuajyx","_id":"clhc0tpp3000ld8we67c26cpd"},{"post_id":"clhc0tpoy0003d8we5kg68stk","tag_id":"clhc0tpoy0002d8we55p04lna","_id":"clhc0tpp4000nd8we7u5z13pg"},{"post_id":"clhc0tpoy0003d8we5kg68stk","tag_id":"clhbvc46w00065swe0kyp2h2c","_id":"clhc0tpp4000od8we4o1ock9f"},{"post_id":"clhc0tpoy0003d8we5kg68stk","tag_id":"clhc0tpp00006d8weabfuajyx","_id":"clhc0tpp4000pd8wee7nrckgu"},{"post_id":"clhc0tpoz0004d8we0ltfd7w9","tag_id":"clhc0tpoy0002d8we55p04lna","_id":"clhc0tpp4000qd8we4qb7axo2"},{"post_id":"clhc0tpoz0004d8we0ltfd7w9","tag_id":"clhbvc46w00065swe0kyp2h2c","_id":"clhc0tpp4000rd8wehidr954o"},{"post_id":"clhc0tpoz0004d8we0ltfd7w9","tag_id":"clhc0tpp00006d8weabfuajyx","_id":"clhc0tpp4000sd8wefngwc1be"}],"Tag":[{"name":"诗词歌赋","_id":"clhbvc46s00035swe4zm7dcfg"},{"name":"programing","_id":"clhbvc46w00065swe0kyp2h2c"},{"name":"hello,world","_id":"clhbvc46x00095sweajf9grv3"},{"name":"redis","_id":"clhbvc46y000c5swe86n9fql9"},{"name":"解决方案","_id":"clhbvc46z000g5swe6ykf3vhs"},{"name":"Netty","_id":"clhc0tpoy0002d8we55p04lna"},{"name":"Java","_id":"clhc0tpp00006d8weabfuajyx"}]}}